<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[课堂笔记] 软件过程改进</title>
    <url>/2021/04/12/cmmi/</url>
    <content><![CDATA[<h1 id="cmmi-模型概述">CMMI 模型概述</h1>
<h2 id="过程改进">过程改进</h2>
<h3 id="过程的定义">过程的定义</h3>
<blockquote>
<ul>
<li><strong>IEEE: Sequence of steps performed for a given purpose</strong></li>
<li><strong>PALL: Logical organization of people, materials, energy, equipment, and procedures into work activities designed to produce a specified end result</strong></li>
<li><strong>CMMI GLOSSARY: A set of interrelated activities, which transform in puts into outputs, to achieve a given purpose</strong></li>
</ul>
</blockquote>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413091924.png" /></p>
<p><strong>如上图所示，将这三个重要方面结合到一起的是组织中所使用的过程。</strong></p>
<h3 id="过程改进的好处">过程改进的好处</h3>
<ul>
<li>过程使您能够了解正在发生的事情。</li>
<li>通过定义，测量和控制过程，改进将更加成功和持久。</li>
<li>成功引入适当的技术，技巧和工具的可能性增加。</li>
<li>人们可以更加充分地发挥潜力，更加有效。</li>
</ul>
<hr />
<h2 id="连续式表示法与阶段式表示法">连续式表示法与阶段式表示法</h2>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413092723.png" /></p>
<blockquote>
<p>CMMI 支持两种使用级别的改进路径。一条路径使组织能够逐步改进其选定的单个过程域（或一组过程域）所对应的过程。另一条路径使组织能够以增量方式应对层次相继的过程域集合来改进相关的过程集。连续式表示法的关注点在于由能力等级度量的过程域能力，而阶段式表示法的关注点在于由成熟度级别度量的总体成熟度。</p>
<p>随着组织达成某一成熟度级别中一系列过程域的通用目标和特定目标，组织在提升组织级成熟度的同时也收获了过程改进带来的收益。 由于每一成熟度级别都为下一级别打下必要的基础，因此，<strong>在成熟度级别上的跳级尝试往往会导致反效果。</strong></p>
<p><strong>同时</strong>，需要认识到的是，过程改进活动应该关注于以组织的业务环境为背景的组织需要上，并认识到更高的成熟度级别中的过程域可以应对组织或项目的当前的与未来的需要。<strong>例如虽然过程组并非成熟度级别 2 级组织的必要特征，但是它可以成为组织达成成熟度级别 2 级途径中的有用部分。</strong></p>
<p>大多数组织对其所选的过程域，至少会选择能力等级 1 级作为目标，这要求达成所有选定过程域的特定目标。然而，将目标定于高于能力等级 1 级的组织会通过实施通用目标与通用实践，来专注于组织内所选过程的制度化。适用于每个过程域的通用目标也已预设完成。通用目标 2 适用于成熟度级别 2 级，通用目标 3 适用于成熟度级别 3 级到 5 级。</p>
</blockquote>
<hr />
<h2 id="等价阶段式定级">等价阶段式定级</h2>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413165108.png" /></p>
<h2 id="关于-cmmi-模型的一系列理解">关于 CMMI 模型的一系列理解</h2>
<blockquote>
<p>能力成熟度模型（Capability Maturity Model，CMM），包括 CMMI，都是对现实世界的简化表述，它涵盖了开发产品与服务的活动。CMMI 开发模型是一个参考模型，是实践的结构化集合，描述了有效过程的特征。CMMI 开发模型并不规定项目或组织必须遵循特定的过程顺序，或每天必须开发出一定数量的产品，或必须达成特定的绩效指标。模型所规定的是项目或组织应该具备应对开发相关实践的过程。项目或组织可将其过程映射至本模型中的过程域，以确定这些过程是否具备。</p>
</blockquote>
<h3 id="为什么要有标准过程">为什么要有标准过程</h3>
<blockquote>
<p>标准过程并不是教条主义，而是为了让项目小组更好地识别其他团队的优秀做法，促进共享。</p>
</blockquote>
<h3 id="如何使用过程模型">如何使用过程模型？</h3>
<blockquote>
<p>帮助设定过程改进目标和优先级; 帮助确保稳定，有能力且成熟的过程;作为改善项目和组织过程的指南;通过评估方法来诊断组织当前的实践状态</p>
</blockquote>
<h3 id="为什么过程模型很重要">为什么过程模型很重要</h3>
<blockquote>
<p>过程模型提供一个开始改进的地方;社区先前经验的好处;共同的语言和共同的愿景;优先行动的框架 定义改进对组织意味着什么的方法</p>
</blockquote>
<h2 id="关于-cmmi-模型的一系列知识点">关于 CMMI 模型的一系列知识点</h2>
<ol type="1">
<li>CMMIv1.2分为哪三个集群</li>
</ol>
<blockquote>
<ul>
<li>面向开发的CMMI（CMMI-DEV）</li>
<li>面向采购的CMMI（CMMI-ACQ）</li>
<li>面向服务的CMMI（CMMI-SVC）</li>
</ul>
</blockquote>
<ol start="2" type="1">
<li>CMMI来源于那三个模型 ，研究机构</li>
</ol>
<blockquote>
<ul>
<li>软件工程 sw-cmm</li>
<li>系统工程 EIA/IS</li>
<li>集成化产品和过程开发 IPD-CMM</li>
</ul>
</blockquote>
<ol start="3" type="1">
<li>评估方法简述，评估三种类型、评估的主要依据、评估的结果</li>
</ol>
<blockquote>
<ul>
<li>SCAMPI评估方法是用于过程改进的标准CMMI评估方法</li>
<li>SCAMPI评估方法有三种类型：
<ul>
<li>Class A:凡是按体系要求的项目都需要按体系要求做，评估的时候采取抽样评估；</li>
<li>Class B:评估试点项目与体系文档、CMMI模型的符合度；</li>
<li>Class C:评估完成的过程体系与CMMI模型的差距；</li>
</ul></li>
<li>目标下的全部实践被全部实施或者被大部分实施，所有缺点不会影响目标的达成。</li>
</ul>
</blockquote>
<hr />
<h2 id="过程域之间的关系">过程域之间的关系</h2>
<h3 id="过程管理类">过程管理类</h3>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094344.png" /></p>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094416.png" /></p>
<h3 id="项目管理类">项目管理类</h3>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094441.png" /></p>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094504.png" /></p>
<h3 id="工程类">工程类</h3>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094525.png" /></p>
<h3 id="支持类">支持类</h3>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094548.png" /></p>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094612.png" /></p>
<hr />
<h1 id="通用目标与通用实践">通用目标与通用实践</h1>
<h2 id="已执行已管理已定义之间的区别">已执行、已管理、已定义之间的区别</h2>
<blockquote>
<p>已执行与已管理之间的关键区别在于过程得到管理的程度。已管理的过程得到了计划（该计划可以是一份更全面的计划的一部分），并且过程的执行依据计划得到了管理。当实际结果与执行情况显著偏离计 划时，会采取纠正措施。已管理的过程能达成该计划的目标，并得到了制度化以实现执行上的一致。</p>
<p>已管理与已定义之间的关键区别在于过程描述、标准与规程 的适用范围。对于已管理的过程，其过程描述、标准与规程适用于特定的 项目、组或组织级功能。因此，同一组织内的两个项目，其已管理的过程可能并不相同。</p>
<p>另一项关键区别在于，相比已管理的过程，已定义的过程描述更为详细， 执行更为严格。这一区别意味着改进信息更容易被理解、分析并使用。最后，已定义过程的管理建立在更为深入的理解之上，包括在过程活动的相互关系方面的理解，以及在过程、过程工作产品与过程服务的详细度量项方面的理解。</p>
</blockquote>
<h2 id="过程之间的关系">过程之间的关系</h2>
<blockquote>
<p>达成过程域的 GG 1，就等于说你达成了该过程域的特定目标。</p>
<p>达成过程域的GG 2，就等于说你管理了与该过程域相关联的过程的执行。过程就如同任何项目或 支持活动那样得到了计划与监督。</p>
<p>达成过程域的 GG 3，就等于说存在组织级标准过程，能够对其进行裁剪(按标准原样执行也是一种裁剪)得到你将要使用的过程。</p>
</blockquote>
<h2 id="通用目标与通用实践-1">通用目标与通用实践</h2>
<h3 id="gg1-达成特定目标">GG1 达成特定目标</h3>
<blockquote>
<p>过程域的特定目标得到过程的支持，过程的支持通过将可识别的输入工作产品转换为可识别的输出工作产品来实现。</p>
</blockquote>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>通用实践</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GP 1.1 执行特定实践</td>
<td>本通用实践的目的在于产生工作产品与交付服务，这些产品与服务是实施（即执行）过程所期望得到的。这些实践能够以非正式方式完成，而不用遵循文档化的过程描述或计划。执行这些实践的严格程度取决于管理与实施该项工作的个人，并可能有很大的差异。</td>
</tr>
</tbody>
</table>
<h3 id="gg2-制度化为已管理的过程">GG2 制度化为已管理的过程</h3>
<blockquote>
<p>过程得到制度化为已管理的过程。</p>
</blockquote>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>通用实践</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GP 2.1 建立组织级方针</td>
<td><strong>建立并维护组织级方针，以计划并执行过程。</strong>本通用实践的目的在于定义对过程的组织级期望，并实现这些期望对组织中受影响的人员的可视化。一般来说，高层管理人员负责建立并沟通组织 的指导原则、指示与期望。并非所有来自高层管理人员的指示都带有“方针”的标签。存在适当的组织级指示是本通用实践所期望的，无论其被称作什么，或通过什么手段进行传达。</td>
</tr>
<tr class="even">
<td>GP 2.2 计划过程</td>
<td><strong>建立并维护计划，以执行过程。</strong>本通用实践的目的在于确定需要什么来执行过程并达成已建立的目标，以准备执行过程的计划，准备过程的描述，并获得相关干系人对计划的同意。</td>
</tr>
<tr class="odd">
<td>GP 2.3 提供资源</td>
<td><strong>提供充分的资源，以执行过程、开发工作产品并提供过程的服务。</strong>本通用实践的目的在于确保计划所定义的、执行过程所必需的资源在需要 时可用。资源包括充分的资金、适当的实体设施、有技能的人员以及适当 的工具等。 对于术语“充分的”，其解释取决于诸多因素，并且可能随着时间而变化。 资源不充分可以通过增加资源或者减少需求、约束与承诺等手段来解决。</td>
</tr>
<tr class="even">
<td>GP 2.4 分派职责</td>
<td><strong>分派职责与职权，以执行过程、开发工作产品并提供过程的服务。</strong>本通用实践的目的在于确保在过程的整个生命期中都存在执行过程与达 成所规定结果的责任。所分派的人员必须拥有执行所分派职责的适当职权。职责的分派可以使用详细的岗位描述来进行，或使用如过程执行计划那样 的活文档来进行。职责的动态分派是实施本通用实践的另一种合理方式， 只要在过程的整个生命期中都能够确保职责的分派与接受。<strong>子实践</strong>1. 分派执行过程的总体职责与职权。2. 分派执行过程的特定任务的职责与职权。3. 确定人员理解并接受分派给他们的职责与职权。</td>
</tr>
<tr class="odd">
<td>GP 2.5 培训人员</td>
<td><strong>必要时，培训过程的执行或支持人员。</strong>本通用实践的目的在于确保人员拥有执行或支持过程所需要的技能与专长。 为将要执行工作的人员提供适当的培训。为那些与执行工作的人员有交互的人员提供概要培训使其了解情况。提供培训的方法的实例有：自学；自主培训；自定进度的程序化教学；正式的在岗培训（on-the-job training）；辅导；以及正式的课堂培训等。培训建立起对过程的共同理解，并传授执行过程所需的技能与知识，从而支持过程的成功执行。</td>
</tr>
<tr class="even">
<td>GP 2.6 控制工作产品</td>
<td><strong>将所选择的过程工作产品置于适当的控制级别。</strong>本通用实践的目的在于建立并维护所选择的过程工作产品（或其描述）在其使用寿命内的完整性。所选择的工作产品在执行过程的计划中进行明确识别，同时明确说明适当的控制级别。不同的控制级别适用于不同的工作产品与不同的时间点。对有些工作产品来说，进行版本控制可能已经足够，这样就可以了解在过去或现在的任何给定时间点所使用工作产品的版本，并且变更的纳入是受控的。版本控制 往往处于工作产品所有者（可能是个人、小组或团队）的单独控制之下。有时，将工作产品置于正式的或者是有基线的配置管理之下会很重要。此类控制包含了在预先确定的节点定义与建立基线。这些基线得到了正式评审与批准，并作为进一步开发所指定的工作产品的基础。参阅“配置管理”过程域以进一步了解如何使用配置识别、配置控制、配置状态记录与报告以及配置审计来建立并维护工作产品的完整性。介于版本控制与正式配置管理之间的其它控制级别也是可能的。所识别的工作产品可能在不同时间点被置于各种不同的控制级别之下。</td>
</tr>
<tr class="odd">
<td>GP 2.7 识别相关干系人，并使之参与</td>
<td><strong>识别过程的相关干系人，并使之按计划参与。</strong>本通用实践的目的在于建立并维护在执行过程时所期望的相关干系人的参与。<strong>子实践</strong>1. 对与过程相关的干系人及其适当的参与进行识别。可从过程活动的输入提供者、输出使用者和活动执行者之中识别相关干系人。一旦识别出相关干系人，就要对他们参与过程活动的适当级别进行计划。2. 在适当的情况下，与项目计划人员或其他计划人员分享这些识别结果。3. 使相关干系人按计划参与。</td>
</tr>
<tr class="even">
<td>GP 2.8 监督并控制过程</td>
<td><strong>对照执行过程的计划，监督并控制过程，并采取适当的纠正措施。</strong>本通用实践的目的在于对过程进行日常的直接监督与控制。通过维护对过 程适当的可视性，必要时就能够采取适当的纠正措施。对过程进行监督与 控制可能涉及到对过程或其产生的工作产品的适当属性进行度量。</td>
</tr>
<tr class="odd">
<td>GP 2.9 客观评价遵守程度</td>
<td><strong>对照过程描述、标准与规程，对过程与所选工作产品的遵守程度进行客观评价，并处理不符合的情况。</strong>本通用实践的目的在于提供可信的保证，确保过程与所选的工作产品按照 计划得到了实施，并且遵守过程描述、标准与规程。评价遵守程度的工作通常由不直接负责管理或执行过程活动的人员来从 事。很多情况下，对遵守程度的评价都由过程外部或项目外部的组织内人 员来进行，或者由组织外人员来完成。因此，即使在过程处于压力之下的 时候（例如：工作落后于进度时，工作超出预算时），仍然能够取得对遵 守程度的可信保证。</td>
</tr>
<tr class="even">
<td>GP 2.10 与上级管理层一起进行状态评审</td>
<td><strong>与上级管理层一起对过程的活动、状态与结果进行评审，并解决问题。</strong></td>
</tr>
</tbody>
</table>
<h3 id="gg3-制度化为已定义的过程">GG3 制度化为已定义的过程</h3>
<blockquote>
<p>过程得到制度化为已定义的过程</p>
</blockquote>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>通用实践</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GP 3.1 建立已定义的过程</td>
<td><strong>建立并维护已定义过程的描述。</strong>本通用实践的目的在于建立并维护从组织的标准过程集中裁剪得到的过 程描述，以应对具体实例的需要。组织应该具备覆盖过程域的标准过程， 同时拥有裁剪这些标准过程的指南，以满足项目或组织级功能的需要。具 备了已定义的过程，就能降低在全组织范围内执行过程方面的差异性，从 而能够有效地分享过程资产、数据与经验总结。</td>
</tr>
<tr class="even">
<td>GP 3.2 收集与过程相关的经验</td>
<td><strong>收集源于过程的计划与执行的、与过程相关的经验，以支持组织过程与过程资产未来的使用与改进。</strong>本通用实践的目的在于收集过程相关的经验，包括源于过程的计划与执行的信息与产物。过程相关的经验实例有工作产品、度量项、度量结果、经验教训与过程改进建议。对信息与产物进行收集，这样它们能够被包含在组织级过程资产中，使那些（或那些将要）计划与执行相同或相似过程的人员可以使用。信息与产物被存储在组织的度量库与组织的过程资产库中。</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="过程域">过程域</h1>
<hr />
<h1 id="术语表">术语表</h1>
<hr />
<hr />
<h1 id="ppt-中问题整理">PPT 中问题整理</h1>
]]></content>
      <tags>
        <tag>lecture</tag>
      </tags>
  </entry>
  <entry>
    <title>Citrine: Providing Intelligent Copy-and-Paste</title>
    <url>/2020/09/25/paper/copy-and-paste-1/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>

</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
  </entry>
  <entry>
    <title>GUI-report</title>
    <url>/2020/07/02/report/GUI-report/</url>
    <content><![CDATA[<h2 id="看清gui-widgets-人工智能如何解决这些问题">看清gui widgets 人工智能如何解决这些问题</h2>
<p>gui widget detection - 重点之一是判断bounding box - 另一个重点是region分类</p>
<p>gui widget detection目前的困难： - 数据方面 - nature scene - 图文并茂 - 全景检测 - physical object - 各种各样的组件同种之间差距比较大，没有固定的feature很难区别 - 策略问题 - 目前大多数的策略都是bottom-up，会造成很大噪音 - cnn神经网络更适合学习architecture而不是shape - gui detection需要更高的识别准确度，而目前一般的识别准度只是要求超过0.5 - 模型选择问题</p>
<h2 id="overall-performance">overall performance</h2>
<p>faster Rcnn &gt; deep learning &gt; 传统方法</p>
]]></content>
      <categories>
        <category>report</category>
      </categories>
      <tags>
        <tag>gui</tag>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title>[MIT Lecture] How to Speak</title>
    <url>/2020/10/21/report/MIT-how-to-speck/</url>
    <content><![CDATA[<h3 id="如何开始一个talk">如何开始一个talk</h3>
<p>不要在一开始就使用一个玩笑作为开场: 因为大部分人在这个时候正在习惯你的用词、声音，或者正在调整笔记本电脑。而是应该使用一个Promise，告诉听众们他们会在接下一段时间中听到什么东西。</p>
<h3 id="一些启发式的例子">一些启发式的例子</h3>
<p><strong><em>cycle</em></strong>： 你应该重复三次左右去确保你的每个听众在被弄混乱的时候都能够意识到你要说的是什么，这是一个概率问题 <strong><em>build fence</em></strong>：把自己的想法包围起来以区分于其他人的想法、其它的工作，划定一个边界 <strong><em>verbal punctuation</em></strong>：划定一些里程碑/标志点一样的东西让听众可以快速的回忆起来之前的内容，从整体上面把握对talk的理解，就像一个outline一样的东西。也方便talker快速的回到某个点 <strong><em>question</em></strong>：谨慎的选择问题，一般会等待7秒钟</p>
<h3 id="一些演讲的选择">一些演讲的选择</h3>
<p>time ： 11 AM 比较合适 place ： 尽量光线充足 cased ：提前适应场地 populated ： 场地大小要合适</p>
<p>board - 可以方便的使用图形 - 写字的速度和思考的速度接近 - 能找到放手的位置</p>
<p>props - 使用一些道具来让陈述更加有趣更加具有说服力</p>
<blockquote>
<p>board 和 props 也许都能够让人更感受到所说的东西的存在，但是 ppt 做不到这个效果</p>
</blockquote>
<h3 id="ppt中的一些技巧">ppt中的一些技巧</h3>
<ul>
<li>不要只是重复阅读ppt中的文字</li>
<li>每个透明度应该都只有很少的词，并且这些词应该易于阅读</li>
<li>不要有太多的字</li>
<li>尽量在ppt的旁边讲述，以免听众反复转移视线</li>
<li>去除掉无用的杂乱的背景、logo、去掉无用的单词，甚至可以去掉title（但是需要告知听众title）</li>
<li>用箭头代替激光笔、指挥棒</li>
</ul>
<h3 id="如何激励听众">如何激励听众</h3>
<blockquote>
<p>talker对自己的演讲充满热情</p>
</blockquote>
<h3 id="steps-of-giving-a-job-talk-technical-talk">Steps of giving a job talk / technical talk</h3>
<ol type="1">
<li>vision</li>
</ol>
<ul>
<li>probelms</li>
<li>approaches</li>
</ul>
<ol start="2" type="1">
<li>have done something 列举出来每一步需要做什么， 一些约束，怎么才能够完成这些事情</li>
<li>contributions</li>
</ol>
]]></content>
      <categories>
        <category>report</category>
      </categories>
  </entry>
  <entry>
    <title>How to write and publish technical papers in English</title>
    <url>/2021/04/08/report/english-writing/</url>
    <content><![CDATA[<h3 id="paper">Paper</h3>
<h4 id="title">Title</h4>
<ul>
<li>Use fewest possible words</li>
<li>Adequately describe the contents of the paper</li>
<li>To be read by thousands of people. Few may read the entire paper.</li>
<li>Choose all words in the title with great care</li>
<li>Carefully manage their association from one with each other</li>
</ul>
<h4 id="abstract">Abstract</h4>
<ul>
<li>A sumary of the information in a document</li>
<li>A single paragraph of 100-200 words</li>
<li>Self contained, no bibliographic, figure, or table references</li>
<li>No obscure abbreviations and acronyms</li>
<li>Write the paper before writing the Abstarct</li>
</ul>
<h4 id="introduction">Introduction</h4>
<ul>
<li>Answer the question "What was the problem?" Why is it important</li>
<li>Supply sufficient background information to allow the reader to understand and evaluate the results of the present study without needing to refer to previous on the topic.</li>
<li>Provide the rationale for the present study (e.g. a motivating example).</li>
<li>State briefly and clearly your purpose in writing the paper and <strong>your contributions</strong>.</li>
<li>Choose references carefully to provide the most important background infomation.</li>
</ul>
<h4 id="results">Results</h4>
<ul>
<li>Answer the question "What did you find?"</li>
<li>Experimental performance evaluation for system work</li>
<li>Empirical study for user interaction work</li>
<li>Complexity analysis for algorithm work</li>
<li>Case studies with real world applications</li>
</ul>
<h4 id="discussion">Discussion</h4>
<ul>
<li>Answer the question "What do these findings mean?"</li>
</ul>
<h4 id="related-work">Related Work</h4>
<ul>
<li>Review most relevant work</li>
<li>Comment on the similarity and differences of your work from them</li>
<li>What makes your work unique and worth doing?</li>
<li>Usually as Section 2, or second last section</li>
</ul>
<h4 id="conclusion-and-future-work">Conclusion and Future Work</h4>
<ul>
<li>Answer the question "What do you conclude?"</li>
<li>What actions need to be taken as future work?</li>
<li>Any discussion of controversial issues</li>
</ul>
<h4 id="acknowledgements">Acknowledgements</h4>
<ul>
<li>Give credit to individuals who have helped you</li>
<li>Acknowledge funding agencies that have partially supported your work</li>
</ul>
<h4 id="references">References</h4>
<ul>
<li>Use statndard bibliographic style</li>
<li>Be complete and consistent with sytle</li>
<li>Use more recent and more influential papers</li>
</ul>
<h3 id="practices">Practices</h3>
<ul>
<li>Read as many good papers as possible</li>
<li><strong>Adapt</strong> good sense of writing from good papers</li>
<li>Write as many papers (in English) as possible</li>
<li>Be serious with reviewers' comments and learn from them</li>
<li>Collaborate with other researchers</li>
<li>Volunteer to review papers</li>
</ul>
<h3 id="specific-rules">Specific Rules</h3>
<ul>
<li>A sentence should be under 3 lines in a single column or 5 lines in a double-column.</li>
<li>Without comparison, do not use "more" or "less"</li>
<li>Issues on passive voice ...
<ul>
<li>避免被动语态除非主语很明确，可以给系统一个名字让系统作为主语</li>
<li>不要总是用 "we"，可以加上半句 "Having done this, we decide ..."</li>
</ul></li>
<li>Issues on tense ...
<ul>
<li>过去时态用于描述过去的一个工作</li>
<li>将来时态只用在 future work 中</li>
<li>完成时只用在 conclusion 中</li>
</ul></li>
<li>Typical Chinglish
<ul>
<li>A lot of -&gt; <strong>Many or Much</strong></li>
<li>Actually -&gt; <strong>In fact</strong></li>
<li>Based on -&gt; <strong>unnecessary in many contexts</strong></li>
<li>Be considered as -&gt; <strong>Be considered</strong></li>
<li>Besides -&gt; <strong>Apart from (和 Except 不一样，后者是不包含， Except for 也是错误用法)</strong></li>
<li>Especially -&gt; <strong>Particularly, or In particular</strong></li>
<li>Firstly, ..., Secondly -&gt; <strong>First, ..., Second -&gt; Bullet list</strong></li>
<li>For "A" (noun), we (verb) it -&gt; <strong>We (verb) "A"</strong></li>
<li>Kind of -&gt; <strong>Type of</strong></li>
<li>Not only A, but also B -&gt; <strong>除非真的想强调A和B不可或缺且互补，否则用and</strong></li>
<li>Painted with red color -&gt; <strong>Colored red</strong></li>
<li>Researches -&gt; <strong>只有 Researchers 或者 Research</strong></li>
<li>Some -&gt; <strong>你想说某些，因为你不知道哪些，所以delete它 (避免不能精确的字)</strong></li>
<li>Very -&gt; <strong>delete it!</strong></li>
<li>Want -&gt; <strong>Wish</strong></li>
<li>We can see from Figure X that -&gt; <strong>Figure X shows that</strong></li>
<li>Whole -&gt; <strong>Entire</strong></li>
</ul></li>
<li>Common Phrases and Suggested Subsitutes
<ul>
<li>For the reason why -&gt; <strong>Why</strong></li>
<li>Starting a sentence with "And" -&gt; <strong>delete "And"</strong></li>
<li>The authors are unaware of the fact that -&gt; <strong>The authors are unaware that</strong></li>
<li>Their alogorithm is a fast one -&gt; <strong>Their alogorithm is fast</strong></li>
<li>Try to -&gt; <strong>Attempt to</strong></li>
</ul></li>
</ul>
]]></content>
      <tags>
        <tag>writing</tag>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetbrains Report 重构？重写？</title>
    <url>/2020/07/31/report/jetbrain-report/</url>
    <content><![CDATA[<p>问题1: 长方法：不是一个很容易解决的问题 根源的原因：重复</p>
<p>重构过程中尽可能的去运行测试以免破坏任何的逻辑</p>
<p>工具：提取方法</p>
<p>问题2: 变量扎堆出现 -&gt; 多个变量同时表达了一个概念 工具：introduce parameter object 但是会引起一些比较长的调用逻辑</p>
<p>问题3： 用一个看起来简单的表示一个复杂的对象 -&gt; 为什么不直接用一个原来的来表示？</p>
<p>问题4: 违反迪米特法则 -&gt; 提取方法，把逻辑封装起来</p>
]]></content>
      <categories>
        <category>report</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Bridging the gap between AI and SE</title>
    <url>/2020/10/19/report/school-report-1/</url>
    <content><![CDATA[<p>background : 大量的软件开发过程中间产品 problem : 大量的噪音和数据具有异构性 key point : 把软件过程中产生的产品逆向来造各种各样的工具 + 机器来理解人的行为 -&gt; 智能软件开发</p>
<p>research topics: - intelligent code assistant - code completion - clone detection - API recommenddation - stackoverflow + API doc - knowledge graphbased api misuse detection - automated answer - interactive query refinement for technical question retrieval - intelligent bug management and fixing - feature engineering for invalid bug determination - just in time defect identification and localization(data from github) - automatic document generation - code summarization - code comment updating - commit message generation - pull request generation - hunman-centric software engineering - predicting coding context - development intention and behavior</p>
<p>research methodology: empirical study -&gt; (intelligent tools &lt;-&gt; empirical study)</p>
]]></content>
      <categories>
        <category>report</category>
      </categories>
  </entry>
  <entry>
    <title>mobileperf</title>
    <url>/2020/06/30/source%20code/mobileperf/</url>
    <content><![CDATA[<h1 id="需求场景">需求场景</h1>
<h2 id="硬件配置差">硬件配置差</h2>
<ol type="1">
<li>压测时间长 72小时左右</li>
<li>需要同时测的app比较多</li>
</ol>
<h2 id="优势">优势</h2>
<ol type="1">
<li>adb方式兼容性强、侵入性小，不需要考虑保活问题</li>
<li>pc端占用资源极少，移动端主要是系统调用</li>
</ol>
<h1 id="源码分析">源码分析</h1>
<p>原作者在博客里已经把几乎所有的关键点都讲了，实际代码中也并没有更多的技术性的细节，和操作系统的交互基本都是对adb shell的封装和对top等指令的调用，以及生成xlsx、csv文件和绘图 博客地址(https://testerhome.com/topics/23449)</p>
<table>
<thead>
<tr class="header">
<th>模块</th>
<th>和操作系统交互</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>连接</td>
<td>adb usb &gt; adb wifi</td>
</tr>
<tr class="even">
<td>CPU</td>
<td>top指令</td>
</tr>
<tr class="odd">
<td>内存</td>
<td>dumpsys meminfo</td>
</tr>
<tr class="even">
<td>FPS</td>
<td>dumpsys SurfaceFlinger/gfxinfo(after 8)</td>
</tr>
<tr class="odd">
<td>网络流</td>
<td>/proc/net/xt_qtaguid/stats （TrafficStats的底层实现）</td>
</tr>
<tr class="even">
<td>电量</td>
<td>dumpsys batteryproperties/dumpsys battery（after）</td>
</tr>
<tr class="odd">
<td>进程数统计</td>
<td>ls -lt /proc/pid/task</td>
</tr>
<tr class="even">
<td>其他</td>
<td>monkey logcat</td>
</tr>
</tbody>
</table>
<h1 id="问题">问题</h1>
<p>mobileperf只是做了统计，并且不能知道某个时刻到底做了什么事情，这样的一个工具是如何和其他工具结合起来来定位某个时刻的操作？ &gt; 讨论前的想法： 用录制好的测试序列作为测试，同时记录进行的操作与时间点，在监测结束后通过人工/按某个阈值筛选出可疑的范围，复现当时的操作找出性能问题 这样的做法有两个延伸问题：首先，假设在很久之前的某个操作带来了副作用导致在很后面的一个操作发生了性能问题要如何检查出来？其次，阈值的设置在业界实际中是怎么确定出来的？(作者提到的是用的是线上指标)</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>[课堂笔记] 程序设计语言的形式语义</title>
    <url>/2020/09/10/lecture/fspl/fspl-notes/</url>
    <content><![CDATA[<h3 id="introduction">Introduction</h3>
<ul>
<li>PL的核心：构建抽象，以程序语言为中心去解决计算问题</li>
<li>PL能做到的是什么
<ul>
<li>用形式化的方式去描述语言的结构和程序的作用</li>
<li>用一种更严格的方法的方法去证明程序的正确性 more than testing</li>
</ul></li>
</ul>
<p>如何定义语言的行为 operational / denotational / axiomatic semantics(操作 / 指称 / 公理语义)</p>
<p>数学基础 1. lambda 演算 - functional programming 函数式 - imperative programming 命令式 - declarative programming 声明式</p>
<h3 id="coq">coq</h3>
<p>inductive data type</p>
<p>constructor 是用来构造的而不是计算的 &gt; Think about standard decimal numerals: the numeral [1] is not a computation; it's a piece of data. When we write [111] to mean the number one hundred and eleven, we are using [1] three times, to write down a concrete representation of a number.</p>
<p>如果对一个函数的传参不完整那么它还是一个函数，直到所有的参数都被获取到才会变成值</p>
<h3 id="lambda-calculus">lambda calculus</h3>
<p>一般一个lambda的程序就叫做一个term（项）或者叫做lambda表达式 todo：BNF范式</p>
<p>pure lambda calculus：(Terms) M,N ::= x | lambdax.M | M N 1. x: 默认用xyz等小写变量来表示程序变量 2. lambdax.M ： lambda抽象，例如 int f (int x)return x -&gt; lambdax.x 3. M N :lambda应用，例如 int f(int x){return x} ; f(3) -&gt; (lambdax.x) 3 4. 本身不接受3作为一个参数，但是可以用 | n扩展语义，还可以引入一些整数计算</p>
<p>表达式简化： 每一个lambda尽可能管到最右边 函数应用是左结合的 一个lambda abstraction中只有一个参数</p>
<p>自由变量，不能随意改名 约束变量，可以改名</p>
<p>求解约束变量的集合 bv(x) = empty bv(lambdax.M) = {x} ∪ bv(M) bv(M N) = bv(M) ∪ bv(N)</p>
<p>substitution (lambdax.M)[N/M] = lambdax.M 原因 （lambdax.M）N -&gt; M[N/x] 这里直接的lambdax.M相当于 (lambdax.(lambdax.M))[N/x]，N代换的是前面的隐藏的x （相当于代换了形参，但是形参又是可以随便换名字的所以相当于什么都不做）</p>
<p>"-&gt;"这个代表这 term x term 上的一个relation 合流性定理：选择一个 <strong><em>特定</em></strong> 的M' 并且选择 <strong><em>特定</em></strong> 的策略使得M1，M2都能通过0至多步到达它</p>
<p>两种化简的策略： normal order reduction：总是选择最左最外的（out-most）redex去做reduction，也就是最优先选择化简function body applicative order reduction：总是选择最左最内的（inner-most）redex去做reduction，也就是最优先选择化简参数。相比于normal order可能效率更低因为参数不一定会被使用到</p>
<hr />
<h3 id="simply-typed-lambda-calculus">Simply-Typed Lambda calculus</h3>
<p>一竖一横 <span class="math inline">\(\vdash\)</span> 表示是否能推出来 一竖两横 <span class="math inline">\(\models\)</span> 表示含义</p>
<p>Value v::constants | <span class="math inline">\(\lambda x.M\)</span> | &lt;v...v&gt; | left v | right v Value无法继续做reduction, Value 也是具备类型的</p>
<h3 id="curry-howard-isomorphism">Curry-Howard Isomorphism</h3>
<p>"命题就是类型，证明就是程序"</p>
<p>如何知道一个类型是非空的，即这个集合中至少存在一个term满足该类型？ 根据Curry-Howard同构来替换 Example可以从后往前看，“如果我们要证明这个，那么我们应该首先获得这个前提...”</p>
<p>项的定型过程就是命题的证明过程，因此可以把项本身就做一个证明</p>
<p>STLC只和constructive propositional logic对应 STLC中没有一个closed term能够定型出 𝜌+(𝜌→𝜎)</p>
<h3 id="operational-semantics">Operational Semantics</h3>
<p>operational semantics 操作语义：指明了程序该如何运行 denotational semanticcs 指称语义：总是把程序指称到一个域上 axiomatic semantics 公理语义：howel logic</p>
<p>small-step <span class="math inline">\((c,\sigma)\rightarrow(c&#39;,\sigma)\)</span> big-step <span class="math inline">\((c,\sigma)\implies(c&#39;,\sigma)\)</span></p>
<p>我们认为state是variable到生活中的n的映射，即我们会对这些符号赋予含义</p>
<h3 id="contextual-semantics">contextual semantics</h3>
<p>见pdf标注</p>
]]></content>
      <categories>
        <category>FSPL</category>
      </categories>
      <tags>
        <tag>lecture notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Types and Programming Languages notes</title>
    <url>/2020/09/25/lecture/fspl/tpl-notes/</url>
    <content><![CDATA[<h2 id="ch3-untyped-arithmetic-expressions">ch3 Untyped Arithmetic Expressions</h2>
]]></content>
  </entry>
  <entry>
    <title>[课堂笔记] 软件工程研究入门</title>
    <url>/2020/09/18/lecture/iser/iser-notes/</url>
    <content><![CDATA[<h3 id="conduct-rigorous-and-scientific-research">Conduct Rigorous And Scientific Research</h3>
<h4 id="写作中的presentation">写作中的presentation</h4>
<ul>
<li>前后用词一致</li>
<li>类似句子不要换用句式</li>
<li>并排枚举的时候强制加上逗号</li>
<li>宾语从句里面也不要省略that，例如Suppose that / We assume that</li>
</ul>
<h4 id="research-formulation">Research Formulation</h4>
<p>整体上来说，做科研和写论文通常是一起进行的。</p>
<p>关键概念：必须先定义再使用，用数学上可表达或者机器可执行的形式去定义 非关键概念：尽量把它扔掉 在同一篇论文中每个概念都需要一个很明确的指代，而不能经常变换</p>
<p>Research Problem 需要有明确的定义的问题边界，不要over claim</p>
<p>Motivating Example 找到一些有区分度的例子——已有工作在这个例子中不能做，而我们的工作可以做</p>
<p>Inadequacy Of Related Work 只需要展示不同点，而不要去批判</p>
<p>Insight 最重要的点，为什么我们的工作比相关工作做的更好</p>
<h4 id="experimentation">Experimentation</h4>
<p>Experimentation 和 Case Study的区别：实验环节是可以控制变量的，并且是在一个实验室的环境中。case study是无法控制变量的，是在实际生产环境中的结果</p>
<h5 id="questions-and-subjects">Questions and Subjects</h5>
<p>问题设置：在<strong><em>什么条件下</em></strong>通过<strong><em>什么途径</em></strong>在什么<strong><em>方面</em></strong>做得好 主体的选择是否具有代表性</p>
<h5 id="experimentation-design">Experimentation Design</h5>
<p>Variable Independent variables（factors） ： 类似与函数中的自变量 Dependent variables ：类似于函数中的应变量，是用于衡量实验结果的一些指标 Controlled variables ：由于难以控制因此一些被固定下来的值，但是这些值对实验不会产生决定性的影响</p>
<h5 id="threats-to-validity">Threats to Validity</h5>
<ul>
<li>constuct validity</li>
<li>internal validity</li>
<li>external validity</li>
<li>concluusion validity</li>
</ul>
<p>todo：看一下原文</p>
<h5 id="exercise-and-discussion">Exercise and discussion</h5>
<p>回答为什么这些threats会影响实验数据<strong><em>但是</em></strong>为什么不会影响结论的正确性</p>
]]></content>
      <tags>
        <tag>lecture notes</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM习题</title>
    <url>/2020/07/03/lecture/jvm/jvm-test/</url>
    <content><![CDATA[<ol type="1">
<li>对于一个数组对象int[] arr，什么能够使 "arr instanceof ___"的结果为true</li>
</ol>
<p>1 java.lang.Object 2 java.io.Serializable 3 java.lang.Cloneable 4 java.lang.Runable</p>
<p>A. 123 ✅ B. 134 C. 234 D. 1234</p>
<ol start="2" type="1">
<li>类的生命周期有：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载，其中类加载的哪个/哪些阶段的发生顺序不是固定的</li>
</ol>
<p>A. 初始化 B. 初始化 解析 C. 解析 验证 D. 解析 ✅</p>
<ol start="3" type="1">
<li>使用真实的java指令执行某个类时，假设在目录src下存在一个被修改过的java/lang/Object.class和一个Main.class,并且所有的检验机制都判定其合法，那么以下说法正确的是</li>
</ol>
<p>A. 除了直接覆盖掉JDK目录对应类这个文件以外，存在一个方法使得自己修改的这个Object类替换掉官方的实现 ✅ B. 无论如何也不可能加载到自己修改过的Object C. 能加载但是会被官方的覆盖掉 D. 以上均不对</p>
<ol start="4" type="1">
<li><p>以下代码中执行doSomething方法时调用到的invoke相关指令是？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Child c &#x3D; new Child();</span><br><span class="line">        c.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent implements B&#123;</span><br><span class="line">    public void doSomething()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A&#123;</span><br><span class="line">    public void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A. invokespecial B. invokestatic C. invokevirtual ✅ D. invokeinterface E. invokedynamic</p></li>
<li><p>以下代码中执行doSomething方法时调用到的invoke相关指令是？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A c &#x3D; new Child();</span><br><span class="line">        c.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent implements B&#123;</span><br><span class="line">    public void doSomething()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A&#123;</span><br><span class="line">    public void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A. invokespecial B. invokestatic C. invokevirtual D. invokeinterface ✅ E. invokedynamic</p></li>
<li><p>以下代码执行结果为 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class E5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parent c &#x3D; new Child();</span><br><span class="line">        c.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">        System.out.print(&quot;in Child &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent implements A&#123;</span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">        System.out.print(&quot;in Parent &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A&#123;</span><br><span class="line">    default void doSomething()&#123;</span><br><span class="line">        System.out.print(&quot;in interface A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>A. in Child ✅ B. in Parent C. in interface A D. in Child in interface A</p>
<ol type="1">
<li>以下代码执行结果为 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Child child &#x3D; new Child();</span><br><span class="line">        child.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    public Child()&#123;</span><br><span class="line">        super();</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">        System.out.print(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">    public Parent()&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">        System.out.print(&quot;B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>A. "BABAB" B. "ABAAB" C. "BABAA" ✅ D. "ABABB"</p>
<ol start="8" type="1">
<li>以下代码执行结果为 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parent child &#x3D; new Child();</span><br><span class="line">        child.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    public Child()&#123;</span><br><span class="line">        super();</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">        System.out.print(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">    public Parent()&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">        System.out.print(&quot;B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>A. "BABAB" ✅ B. "ABAAB" C. "BABAA" D. "ABABB"</p>
<ol start="9" type="1">
<li>以下代码执行结果为 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            Parent child &#x3D; (Parent) new Child();</span><br><span class="line">            child.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Child extends Parent&#123;</span><br><span class="line">        static private int val&#x3D;2;</span><br><span class="line">        public Child()&#123;</span><br><span class="line">            super();</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            val++;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void doSomething()&#123;</span><br><span class="line">            System.out.print(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Parent&#123;</span><br><span class="line">        static private int val&#x3D;1;</span><br><span class="line">        public Parent()&#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static&#123;</span><br><span class="line">            val++;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void doSomething()&#123;</span><br><span class="line">            System.out.print(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>A. 23333 B. 22222 C. 22333 D. 23232 ✅</p>
<ol start="10" type="1">
<li>以下代码执行结果为 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parent child1 &#x3D; new Child();</span><br><span class="line">        child1.doSomething();</span><br><span class="line">        Child child2 &#x3D; new Child();</span><br><span class="line">        child2.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    static private int val&#x3D;2;</span><br><span class="line">    public Child()&#123;</span><br><span class="line">        super();</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ++val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        val++;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">        System.out.print(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent&#123;</span><br><span class="line">    static private int val&#x3D;1;</span><br><span class="line">    public Parent()&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ++val;</span><br><span class="line">    &#125;</span><br><span class="line">    static&#123;</span><br><span class="line">        val++;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">        System.out.print(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>A. 23343455 ✅ B. 23343454 C. 23344455 D. 23344454 C. 2334445565 D. 2234345565 E. 2334445465 F. 2234345465</p>
<ol start="11" type="1">
<li><p>以下哪个选项中的内容全部能够被线程共享 A. 堆中实例对象、字符串常量池、本地方法栈 B. 运行时常量池、堆中实例对象 ✅ C. 方法区、本地方法栈 D. 局部变量表、方法区</p></li>
<li><p>下列表述正确的数量有（）个 “每个frame的操作数栈最大栈深度是运行时决定的” “类的initiating loader和defining loader可以是同一个loader” “<clinit>方法是类加载阶段由jvm动态生成的” “final static类型的变量是在类加载的准备阶段被赋值的”</p></li>
</ol>
<p>A. 0 B. 1 ✅ C. 2 D. 3 E. 4</p>
<ol start="13" type="1">
<li>下列表述正确的数量有（）个 “multianewarray中第一个从操作数栈中被pop出来的值代表第一维的长度，第二个代表第二维，以此类推...” “multianewarray对于长度的规定是不允许有负值但允许出现0，这种情况下它会被处理成1” “多维基本类型数组类的加载中不需要链接阶段” “数组加载过程中不会抛出IllegalAccessError”</li>
</ol>
<p>A. 0 B. 1 ✅ C. 2 D. 3 E. 4</p>
<ol start="14" type="1">
<li><p>方法签名“Object m(int i, double d, Thread t) {...}”的描述符是 A.(IDLjava/lang/Thread;)Ljava/lang/Object; ✅ B.(IDLjava/lang/Thread;)Ljava/lang/Object C.Ljava/lang/Object(IDLjava/lang/Thread;); D.Ljava/lang/Object(IDLjava/lang/Thread;)</p></li>
<li><p>下列表述正确的数量有（）个 “每个常量最多需要2byte的tag来标明自己的类型” “UTF8info中包含了一个对StringInfo的index，而StringInfo中真正存储了字符串” “由于java无法表示无符号short类型，因此可以把数据读取到int，再进行 value || 0xff的操作来获取低16位” “常量池表的有效索引是从1到constant_pool_count”</p></li>
</ol>
<p>A. 0 ✅ B. 1 C. 2 D. 3 E. 4</p>
<ol start="16" type="1">
<li>下列表述正确的数量有（）个 “在设置加载器的搜索路径时，dir/* 这样的表示会递归搜索dir目录以及子目录中所有的jar包” “加载器搜索时如果能够在多个路径中找到某个类，那么以最先找到的结果作为返回结果” “java.lang.Object这个类在实际的jar包中的文件名是Object.class” “多个路径设置可以使用File.separator作为分割”</li>
</ol>
<p>A. 0 B. 1 C. 2 ✅ D. 3 E. 4</p>
<ol start="17" type="1">
<li><p>下列表述正确的数量有（）个 “双亲委托中用户类加载器会同时委托给bootstrap加载器和ext加载器” “双亲委托中当加载器无法从自己的搜索空间中找到类时才会向其他加载器发出委托” “一个类可以加载同一个包下面声明为protected的另一个类” <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这三个类在同一个包中，Visitor无法通过编译</span><br><span class="line">public class Visitor&#123;</span><br><span class="line">    Visible1.Unknown v1 &#x3D; new Visible1.Unknown();</span><br><span class="line">    Visible2.Unknown v2 &#x3D; new Visible2.Unknown();</span><br><span class="line">&#125;</span><br><span class="line">public class Visible1&#123;</span><br><span class="line">    private static class Unknown&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Visible2&#123;</span><br><span class="line">    public static class Unknown&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> A. 0 B. 1 C. 2 ✅ D. 3 E. 4</p></li>
<li><p>输入java -h得到的结果中包含“java [-options] -jar jarfile [args...]”，下列说法正确的是 A. []中的内容代表可选；jarfile不是一个必须的参数，可以先输入args再通过别的指令额外指定 B. []中的内容是必须至少选择一个的意思；jarfile是一个必须的参数 C. []中的内容代表可选；jarfile是一个必须的参数 ✅ D. []中的内容是必须至少选择一个的意思；jarfile不是一个必须的参数，可以先输入args再通过别的指令额外指定</p></li>
<li><p>如果要使用commons cli的库实现自己的命令行接口，其中哪个流程是不涉及的 A. 预定义 B. 解析 C. 通过用户输入参数动态新增定义 ✅ D. 使用（实现业务逻辑）</p></li>
<li><p>类加载的链接阶段不包括什么子阶段 A. 验证 Verification B. 准备 Preparation C. 解析 Resolution D. 创建 Creation ✅</p></li>
<li><p>下列哪种功能IDEA的debugger没有提供：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. 在抛出特定异常之前暂停程序的异常断点</span><br><span class="line">B. 符合特定条件（如某个变量等于某个值）时才触发的断点</span><br><span class="line">C. 在某个断点被触发之后才生效的断点</span><br><span class="line">D. 以上功能都提供了 ✅</span><br></pre></td></tr></table></figure></li>
<li><p>下列关于字节码的说法中，错误的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. Java字节码之所以叫字节码是因为指令的操作码(opcode)只有一个字节</span><br><span class="line">B. GOTO的offset是相对于GOTO的操作码的地址的</span><br><span class="line">C. Java字节码储存在classfile的常量池（constantpool）字段中 ✅</span><br><span class="line">D. invokeVirtual 比 invokeInterface 指令短</span><br></pre></td></tr></table></figure></li>
<li><p>在使用Java程序读取数据类型<code>u2</code>时，应该使用哪种类型的变量？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. unsigned short</span><br><span class="line">B. int ✅</span><br><span class="line">C. short</span><br><span class="line">D. char</span><br></pre></td></tr></table></figure></li>
<li><p>关于指令<code>FCMPG</code>和指令<code>FCMPL</code>的说法中，正确的是：（假设当前操作数栈的情况是: ...op1,op2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. 如果op1&gt;op2，FCMPG压栈1，FCMPL压栈-1</span><br><span class="line">B. 如果op1&gt;op2，FCMPG压栈-1，FCMPL压栈1</span><br><span class="line">C. 如果op1&#x3D;&#x3D;op2, FCMPL和FCMPG都压栈-1</span><br><span class="line">D. FCMPL和FCMPG仅在op1和(或)op2中有NaN的时候行为才有区别 ✅</span><br></pre></td></tr></table></figure></li>
<li><p><code>byte a = 0xff;</code>那么在Java中，表达式<code>a &amp; 0xff</code>的值和类型分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. -1, int ✅</span><br><span class="line">B. 0xff, int</span><br><span class="line">C. -1, short</span><br><span class="line">D. 0xff, byte</span><br></pre></td></tr></table></figure></li>
<li><p>关于指令<code>ILOAD</code>，下面说法中正确的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. ILOAD 把一个4字节的数据当作int从局部变量表(LocalVars)加载到操作数栈(OperandStack)中 ✅</span><br><span class="line">B. ILOAD 把一个4字节的数据当作int从操作数栈加载到局部变量表中</span><br><span class="line">C. ILOAD 把一个4字节的数据当作int从常量池(ConstantPool) 加载到操作数栈中</span><br><span class="line">D. 以上说法都不对</span><br></pre></td></tr></table></figure></li>
<li><p>"双亲委托机制"是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. 实现运行时多态的机制</span><br><span class="line">B. 提高编译器性能的机制</span><br><span class="line">C. 用在类加载器上的机制 ✅</span><br><span class="line">D. 实现虚函数调用的机制</span><br></pre></td></tr></table></figure></li>
<li><p>下列关于<code>invokeVirtual</code>的内容，错误的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. invokeVirtual的实现中可以使用虚函数表（Vtable）进行优化</span><br><span class="line">B. invokeVirtual可以用来调用本地方法(native method)</span><br><span class="line">C. invokeVirtual可以用来调用构造方法(Constructor) ✅</span><br><span class="line">D. ABC里至少有一个是错的</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码正确地实现<code>ISUB</code>指令了吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ISUB extends NoOperandsInstruction &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute(StackFrame frame) &#123;</span><br><span class="line">        OperandStack stack &#x3D; frame.getOperandStack();</span><br><span class="line">        int val1 &#x3D; stack.popInt();</span><br><span class="line">        int val2 &#x3D; stack.popInt();</span><br><span class="line">        int res &#x3D; val1 - val2;</span><br><span class="line">        stack.pushInt(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. 正确实现了</span><br><span class="line">B. 没有正确实现 ✅</span><br><span class="line">C. 别选这一项，这是判断题</span><br><span class="line">D. 楼上说的对</span><br></pre></td></tr></table></figure></li>
<li><p>关于<code>StackFrame</code>的说法中，正确的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. 在运行过程中，每个method对应且仅对应一个StackFrame</span><br><span class="line">B. 有的StackFrame可能有多个method</span><br><span class="line">C. 有的method可能对应多个StackFrame ✅</span><br><span class="line">D. StackFrame可以多线程共享</span><br></pre></td></tr></table></figure></li>
<li><p><code>System.out.println("this is a string")</code>方法有几个参数？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. 1个，是内容为&quot;this is a string&quot;的String ✅</span><br><span class="line">B. 2个，分别是this和String</span><br><span class="line">C. 2个，分别是类名和String</span><br><span class="line">D. println是个宏(macro), 不是方法</span><br></pre></td></tr></table></figure></li>
<li><p>方法<code>foo</code>描述符为<code>(III)V</code>, 关于<code>foo</code>的说法正确的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. foo的返回值是Void类型的对象</span><br><span class="line">B. foo的maxLocal可能是2</span><br><span class="line">C. foo的maxLocal可能是6 ✅</span><br><span class="line">D. 调用foo的时候应该使用invokeVirtual指令</span><br></pre></td></tr></table></figure></li>
<li><p>实验和大作业过程中，用哪个指令来反汇编<code>.class</code>文件？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. javac</span><br><span class="line">B. javap ✅</span><br><span class="line">C. java -jar</span><br><span class="line">D. mvn decompile</span><br></pre></td></tr></table></figure></li>
<li><p>下列关于<code>classfile</code>中<code>attribute</code>的说法正确的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. Code属于一种Attribute，每个方法都有这个Attribute </span><br><span class="line">B. 在classfile中加入自定义的Attribute不会影响JVM正常解析classfile ✅</span><br><span class="line">C. 在classfile中，Attribute储存在constantpool里</span><br><span class="line">D. 以上说法都不对</span><br></pre></td></tr></table></figure></li>
<li><p>下列关于<code>classfile</code>中<code>IntergerInfo</code>这一常量池信息说法正确的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. 其中四字节的int是按小端顺序储存的</span><br><span class="line">B. 其中四字节的int是按大端顺序储存的 ✅</span><br><span class="line">C. 储存顺序和JVM的实现有关，选择一种即可</span><br><span class="line">D. classfile中储存的int是6字节，在加载到JVM后需要进行ValueSetConversion</span><br></pre></td></tr></table></figure></li>
<li><p>如果<code>FADD</code>执行时操作数栈顶的数据其实是int（例如是被ICONST指令加载进来的）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. JVM的行为是未定义的，可以随意处理 ✅</span><br><span class="line">B. JVM应该在执行到这条指令时抛出异常</span><br><span class="line">C. JVM应该把int的值转换成float</span><br><span class="line">D. Java5之后，JVM可以使用指令多态技术把FADD替换成IADD而不会引发异常</span><br></pre></td></tr></table></figure></li>
<li><p>下面哪个是JVM中加载引用的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. ALOAD ✅</span><br><span class="line">B. BLOAD</span><br><span class="line">C. ILOAD</span><br><span class="line">D. DLOAD</span><br></pre></td></tr></table></figure></li>
<li><p>在描述符中，如何表示<code>long</code>类型:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. L</span><br><span class="line">B. J ✅</span><br><span class="line">C. K</span><br><span class="line">D. Ljava&#x2F;lang&#x2F;Long;</span><br></pre></td></tr></table></figure></li>
<li><p>下面这段代码对<code>LUSHR</code>的实现正确吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void execute(StackFrame frame) &#123;</span><br><span class="line">        OperandStack stack &#x3D; frame.getOperandStack();</span><br><span class="line">        int val2 &#x3D; stack.popInt();</span><br><span class="line">        long val1 &#x3D; stack.popLong();</span><br><span class="line">        long res &#x3D; val1 &gt;&gt;&gt; (val2 &amp; 0x2f);</span><br><span class="line">        stack.pushLong(res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. 正确</span><br><span class="line">B. 不正确 ✅</span><br><span class="line">C. 这是道判断题，别选这一项</span><br><span class="line">D. 楼上说的对</span><br></pre></td></tr></table></figure></li>
<li><p><code>GOTO</code>指令的<code>offset</code>是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. 有符号数 ✅</span><br><span class="line">B. 无符号数</span><br><span class="line">C. 对常量池中一个IntegerInfo的引用，IntegerInfo储存了真正的offset值</span><br><span class="line">D. 跳转目标的绝对地址</span><br></pre></td></tr></table></figure></li>
</ol>
<!-- 1. 我们在测试用例中请大家自行在JVVM中实现的测试用方法类名是：

   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   A. TestUtil ✅</span><br><span class="line">   B. TestHack</span><br><span class="line">   C. TestCase</span><br><span class="line">   D. IOUtil</span><br><span class="line">   &#96;&#96;&#96; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 16. 需要正确配置的Java环境变量是：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>A. $JAVAHOME
B. $JAVA_HOME ✅
C. $JavaHome
D. $java_home
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 17. 大作业中，medium1测试用例一直是&#96;空指针异常&#96;说明：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
A. 有指令没有实现
B. 所有指令都实现了但是有指令实现错误
C. 框架代码写错了
D. 哈，你也发现其实啥也说明不了了吧？这是一道送分题，选这一项，并且记得下次不要再这样问问题了喔 ✅
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 9. 在实验手册中，要求大家使用的JDK是：</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<p>A. OpenJDK 8 B. 任何JDK 1.8 C. Oracle JDK 8 ✅ D. Maven 5 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 3. 指令&#96;invokeStatic&#96;是在哪次实验中要求实现的？</span><br><span class="line"></span><br></pre></td></tr></table></figure> A. Lab3 B. Lab4 C. Lab5 D. Lab6 ✅ ``` --&gt;</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>[课堂笔记] 操作系统</title>
    <url>/2020/07/05/lecture/os/os-lecture-notes/</url>
    <content><![CDATA[<h2 id="理论课">理论课</h2>
<h2 id="代码课">代码课</h2>
<h3 id="应用眼中的操作系统">应用眼中的操作系统</h3>
<ol type="1">
<li>_start是链接器真正的入口，而不是main，可以通过ld -e main file.o来指定程序入口。一个C程序的第一条指令位于系统内置的链接器中，链接器会先加载libc，然后再加载目标程序</li>
<li>objdump -S看到的源码里面的@plt代表这段代码是动态链接的</li>
</ol>
<h3 id="c4-系统中的进程">C4 系统中的进程</h3>
<h3 id="c5-链接与加载">C5 链接与加载</h3>
<h4 id="静态链接与符号重定位">静态链接与符号重定位</h4>
<p>ld链接器的本质就是把各种.o文件中的各种段复制到二进制文件中并且进行重定位</p>
<h4 id="动态链接">动态链接</h4>
<p>必须的几个条件： - 位置无关代码，全部通过pc相对寻址 - 引用数据或者代码的时候如果这是一个未知的符号，那么必须去查表来获得地址</p>
<p>查表这个行为就是一个call *libxxx.tab[target]。(在不实现延迟解析的时候) 如果是需要动态加载的程序，那么gdb strati停在的第一条指令其实是在libld中的。并且libld的代码会被映射到程序的地址空间中，由它来按照依赖的倒序依次加载其余的动态库。 在libld加载完target之后，libld会调用_dl_runtime_resolve来重填libxxx.tab[target]这一项</p>
<p>在ELF文件中实际上这个表就叫做GOT，global offset table，库函数和可执行文件都有GOT。 所以用file查看可执行文件和一个共享库的时候给出的结果都是一个shared object</p>
<p>GOT 中储存的数据 - GOT[0]: .dynamic 节的地址 - GOT[1]: link map , 用于遍历依赖的动态链接库 - GOT[2]: _dl_runtime_resolve 的地址 , call *GOT[2] 可以完成符号解析 - GOT[i]: 程序所需的动态符号地址 (printf, ...)</p>
<p><strong>lazy symbol resolve黑科技看视频回看</strong></p>
<h2 id="专题">专题</h2>
]]></content>
      <categories>
        <category>os</category>
        <category>os lecture</category>
      </categories>
      <tags>
        <tag>lecture notes</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>[Lecture Notes] Software Architecture</title>
    <url>/2020/12/17/lecture/software-architecture/SA-notes/</url>
    <content><![CDATA[<h2 id="introduction">Introduction</h2>
<p>科学和工程的本质区别：是否有人的参与。工程的本质上是改变这个世界</p>
<p>软件架构两个定义之间的区别与联系：SEI和IEEE的定义基本相同，IEEE更为宽泛，而多的定义是与外部环境的交互以及设计演进的指导原则。</p>
<p>为什么在设计当中需要抽象？</p>
<p>Use Case 会把四个视图结合起来</p>
<h2 id="chapter1">chapter1</h2>
<p>正确的设计顺序： constarins -&gt; quality attributes -&gt; functionalty attributes</p>
<h3 id="quality-attributes-and-tactics">Quality Attributes And Tactics</h3>
<h4 id="availability">Availability</h4>
<p>描述 availability -&gt; 使用时间</p>
<p>------------------------------------------------&gt; timeline ↑ ↑ ↑ ↑ failure detect correct restart Mean time between failures : restart - failure 高可用性：上面的三段时间都尽可能的小 -&gt; 缩短这些时间都可以提高可用性</p>
<h5 id="缩短检测时间">缩短检测时间：</h5>
<p>什么情况下使用ping/echo，什么情况下使用heartbeat? &gt; ping echo是双向的，heartbeat是单向的 &gt; 尽管heartbeat带宽更小，但是需要一直占用着资源，多用于长时间始终保持连接的，实时的监控 &gt; ping是只有需要的时候才去ping，不会始终占用着资源</p>
<p>volting:用三个detect技术来保持一致，这些detect可以用同样的实现也可以是不同的实现</p>
<h5 id="缩短恢复时间">缩短恢复时间</h5>
<p>假设有两台机器，一台是primary / secondary Active redundancy / passive redundancy / spare active : 两个都在运行，随时可以切换，两台都进行同样的工作，只是忽略备用的输出 passive : 备用机器定期同步，开着但是不会进行相同的工作 spare : 定期打primary的快照，down了之后在secondary上恢复 这三个时间会逐渐变长（本质是资源换时间） #### Reliability</p>
]]></content>
      <tags>
        <tag>lecture notes</tag>
      </tags>
  </entry>
  <entry>
    <title>[课堂笔记] 高级软件设计</title>
    <url>/2020/11/12/lecture/software-design/SD-notes/</url>
    <content><![CDATA[<h2 id="基本概念">基本概念</h2>
<ol type="1">
<li><p>设计模式的定义 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在软件工程中，设计模式是一种在特定上下文中应对反复出现的问题的可重用的通用的解决方案</span><br></pre></td></tr></table></figure></p></li>
<li><p>设计模式的分类 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209212805.png" /></p></li>
</ol>
<h2 id="模式类图">模式类图</h2>
<h3 id="策略模式">策略模式</h3>
<p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215200.png" /> ### 状态模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215132.png" /> ### 观察者模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215105.png" /> ### 装饰者模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215537.png" /> ### 工厂方法模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215328.png" /> ### 抽象工厂模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215302.png" /> ### 命令模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215002.png" /> ### 适配器模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215450.png" /> ### 外观模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215602.png" /> ### 模版模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215225.png" /> ### 迭代器模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215659.png" /> ### 组合模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215511.png" /> ### 单例模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215353.png" /> ### 代理模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215633.png" /></p>
<h2 id="题目">题目</h2>
<h3 id="模式体现什么设计原则">模式体现什么设计原则</h3>
<h3 id="意图汇总">意图汇总</h3>
<table>
<thead>
<tr class="header">
<th>模式</th>
<th>意图</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>策略</td>
<td>定义一系列算法，封装每个算法，并使它们可互换。策略允许算法独立于使用它的客户机而变化。</td>
</tr>
<tr class="even">
<td>状态</td>
<td>允许对象在内部状态发生改变时改变它的行为</td>
</tr>
<tr class="odd">
<td>观察者</td>
<td>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</td>
</tr>
<tr class="even">
<td>装饰者</td>
<td>允许向一个现有的对象添加新的功能，同时又不改变其结构</td>
</tr>
<tr class="odd">
<td>工厂</td>
<td>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</td>
</tr>
<tr class="even">
<td>抽象工厂</td>
<td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</td>
</tr>
<tr class="odd">
<td>命令</td>
<td>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化</td>
</tr>
<tr class="even">
<td>适配器</td>
<td>将一个类的接口转换成客户希望的另外一个接口</td>
</tr>
<tr class="odd">
<td>外观</td>
<td>为高层模块提供一个一致的接口访问多个复杂的子系统</td>
</tr>
<tr class="even">
<td>模版</td>
<td>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td>
</tr>
<tr class="odd">
<td>迭代器</td>
<td>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示</td>
</tr>
<tr class="even">
<td>组合</td>
<td>将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性</td>
</tr>
<tr class="odd">
<td>单例</td>
<td>保证一个类仅有一个实例，并提供一个访问它的全局访问点</td>
</tr>
<tr class="even">
<td>代理</td>
<td>为其他对象提供一种代理以控制对这个对象的访问</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="设计原则">设计原则</h3>
<h4 id="principles">Principles</h4>
<ol type="1">
<li>Encapsulate what varies.</li>
<li>Favor composition over inheritance.</li>
<li>Program to interfaces, not implementations.</li>
<li>Strive for loosely coupled designs between objects that interact.</li>
<li>The Open-Closed Principle ：Classes should be open for extension, but closed for modification</li>
<li>Dependency Inversion Principle ：Depend upon abstractions. Do not depend upon concrete classes.</li>
<li>The Hollywood Principle ：Don’t call me, we’ll call you</li>
<li>Single Responsibility ：A class should have only one reason to change</li>
<li>Principle of Least Knowledge ：talk only to your immediate friends</li>
</ol>
<p>⚠️以下分类不一定完全正确仅代表个人观点 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209232932.png" /></p>
<h4 id="思考题">思考题</h4>
<ol type="1">
<li>好莱坞原则与依赖倒置的关系 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">依赖倒置原则强调尽可能避免使用具体类，而多使用抽象。而好莱坞原则是让低层组件能够被 hook 进计算并且高层不依赖低层。两者的目的都是结偶，但是依赖倒置更加注重如何在设计中避免依赖</span><br></pre></td></tr></table></figure></li>
<li>好莱坞原则中低层组建不可以调用高层组建中的方法吗？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不完全是，低层会调用高层中继承来的方法。好莱坞原则要避免的是高层和低层之间的环形依赖</span><br></pre></td></tr></table></figure></li>
<li>透明的组合模式和安全的组合模式之间的tradeoff <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">透明的组合模式：客户不去了解具体实现，采用一致处理，牺牲安全性</span><br><span class="line">安全的组合模式：先判断再处理，牺牲透明性</span><br></pre></td></tr></table></figure></li>
</ol>
<hr />
<h3 id="不同模式之间的比较">不同模式之间的比较</h3>
<ol type="1">
<li>比较策略模式和状态模式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 策略模式是定义一个算法家族，把他们封装起来，使得他们之间可以相互替换</span><br><span class="line">- 状态模式是将一个个状态封装成一个个类，当内部状态发生改变时，改变他们的行为</span><br><span class="line">- 策略模式和状态模式的类图几乎一样，策略模式中，客户端知道具体的策略有哪些，客户端能够通过setStrategy方法来动态的设置具体使用哪个策略，状态模式中，客户端不知道内部状态是怎么变化的，状态模式通过状态转移来组合State对象，最后把行为呈现出来</span><br></pre></td></tr></table></figure></li>
<li>比较策略模式和模版方法模式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 策略模式和模版方法模式的共同点是都封装算法</span><br><span class="line">- 策略模式是定义算法家族，让他们之间可以相互替换，模版方法是针对一个算法流程，某个步骤的具体细节交给子类去实现。策略模式可以改变算法流程，使一个个步骤可以相互替换，模版方法模式算法流程是固定的</span><br><span class="line">- 策略模式使用组合来实现，模版方法模式使用继承来实现</span><br></pre></td></tr></table></figure></li>
<li>比较适配器模式、外观模式、装饰者模式的意图 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 适配器模式是把一个类的接口转换成客户期望的接口，让原本接口不兼容的类兼容，适配器模式一般用于想要复用某个类的场景；外观模式是封装子系统，提供简单的子系统的入口，同时简化层间调用</span><br><span class="line">- 装饰者模式是动态的给被装饰者添加职责，主要目的是扩展功能</span><br><span class="line">- 对于装饰者和适配器，他们都属于包装模式，装饰者需要满足is-a关系，不管如何包装，都有共同的父类，而适配器主要解决兼容问题，不一定要统一父类</span><br></pre></td></tr></table></figure></li>
<li>比较模版方法模式和工厂模式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工厂模式是模版方法的特殊实现，工厂里面的创建对象，就相当于只有一个步骤的模版方法模式，这个步骤交给子类去实现</span><br></pre></td></tr></table></figure></li>
<li>比较装饰者模式和静态代理模式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 装饰者模式是动态的给组件对象添加“职责”，更多的考虑功能的扩展，而代理模式控制对象</span><br><span class="line">的访问，也能做方法的增强</span><br><span class="line">- 装饰者模式中，客户端可以看到具体的装饰有哪些，而代理模式把对象的具体信息给隐藏了</span><br><span class="line">起来</span><br><span class="line">- 装饰者模式是把原始组件对象传入构造器中，代理模式是创建一个对象的实例</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Designing</category>
      </categories>
      <tags>
        <tag>lecture notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Multiple-Entry Testing of Android Applications by Constructing Activity Launching Contexts</title>
    <url>/2020/07/05/paper/mobile/icse20%20Multiple-Entry/</url>
    <content><![CDATA[<h2 id="总体评价">总体评价</h2>
<p>做的不怎么样，应该会被reject。因为soundness不够，并且覆盖率甚至不如APE（APE是sound的）</p>
<h3 id="单入口想要测试充分的固有缺陷">单入口想要测试充分的固有缺陷：</h3>
<ol type="1">
<li>有些activity因为复杂手势或者复杂的逻辑操作而无法达到，每个activity距离默认的入口的距离不同，测试的exploration对于不同的activity是不同的，这就导致了越难发现的activity越难被测充分</li>
<li>有的测试方法能够找到activity之间的数据依赖但是不知道什么因素能够对后面的activity造成影响，可能达到这个activity的时候并不是一个完整的能够引发bug的上下文环境。并且这个上下文环境甚至可能是来自于app外部的 (1.Furthermore, because of the infinite test space of GUI programs, it is difficult to launch activities under complete contexts using SET 2. ...XXX has different behaviors depending on its Activity Launching Contexts (ALCs), which is generated by previous event operations or received from outside (e.g., another app))</li>
<li>即使达到了某个activity，也无法知道到底是否覆盖完全了（当然，这个问题本身也是不可判定的）</li>
</ol>
<h3 id="多入口试图如何解决问题">多入口试图如何解决问题：</h3>
<ol type="1">
<li>找到什么才是最能够影响某个activity的启动结果的因素，然后尽可能测试这个因素 -&gt; ICC（inter-component communication）最为重要 &gt; 其余因素还有设备配置、activity栈以及全局数据。设备配置直接报告，activity栈能够在空栈的情况下使用Faxla策略，在非空情况下使用Faxex策略。而全局数据，如果能够探索到全局设置相关的activity，在多轮的测试中会修改它</li>
<li>试图直接启动某个activity，然后生成它需要的ICC并测试</li>
<li>动态的维护每个activity的explore weight使得能够触发更多transition的activity能够被更多的测试到，并且让一些意外crash掉的activity也能够被覆盖到（毕竟不能crash了发现了一个bug就丢掉，可能这个crash的节点是后面更多crash节点的entry）</li>
</ol>
<h3 id="整个工作的一些限制">整个工作的一些限制</h3>
<ul>
<li>focus在启动环节，是以activity来进行划分，对于某个activity中的一些例如button的点击应该是完全没有纳入测试范围的</li>
<li>在basic attribute基本只用到了string相关API而不能够使用其他JDK的库更不用说第三方库</li>
</ul>
<h3 id="how-to">how-to：</h3>
<ol type="1">
<li>如何产生多入口：把原本只能通过EA(exported activity 能够被外部app启动)达到的IA（internal activity）修改成为EA，只需要把andorid：exported设置为true或者修改manifest中的intent filter</li>
<li>如何动态修改权重：通过多轮测试，Faxex策略基于Faxla的结果，并结合了activity之间的transition &gt; 因为静态分析的一些技术限制，transition可能不够精准，因此Faxex中也会动态地发现更多可到达的状态</li>
<li>ALM如何建立：最主要依赖于“跳转都是与string相关操作”这一假设，例如if-else中使用一个对string的比较，根据比较结果决定是否跳转或do something，这个假设的局限性就在于当遇到与string不相关的操作时就不能work</li>
<li>dummy activity：运行时构造出来的虚拟的入口用来访问一些需要权限的无法通过adb直接启动的activity</li>
</ol>
<h3 id="evaluation">Evaluation</h3>
<ol type="1">
<li>RQ1: ALC构造的效果</li>
</ol>
<ul>
<li>自己构造了一些测试用例</li>
</ul>
<ol start="2" type="1">
<li>RQ2: activity启动的效果</li>
</ol>
<ul>
<li>baseline : Monkey Ape IntentFuzzer</li>
<li>最终整个Fax覆盖率达到96.4%，成功启动了60%的activity</li>
</ul>
<ol start="3" type="1">
<li>RQ3: 是否提高了代码覆盖度</li>
</ol>
<ul>
<li>略低于IntentFuzzer的覆盖率，但不知道这个是一个怎么样的baseline</li>
</ul>
<ol start="4" type="1">
<li>RQ4: Fax是否能找到了更多的bug</li>
</ol>
<ul>
<li>确实找到了bug，但是没有baseline</li>
</ul>
<p>整个evaluation都不行，并且它自己一个fuzz interface的work去和默认入口执行的比较这本身就不fair</p>
<h3 id="没找到答案的问题">没找到答案的问题：</h3>
<ol type="1">
<li>如何确认一个activity是“global setting related”</li>
</ol>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>mobile</tag>
        <tag>testing</tag>
        <tag>icse</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [EMSE] Learning from Mistakes — A Comprehensive Study on Real World Concurrency Bug Characteristics</title>
    <url>/2020/08/04/paper/ISER/Empirical%20Software%20Engineering/emse-1/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>The reality of multi-core hardware has made concurrent programs pervasive. Unfortunately, writing correct concurrent programs is difficult. Addressing this challenge requires advances in multiple directions, including concurrency bug detection, concurrent pro gram testing, concurrent programming model design, etc. Design ing effective techniques in all these directions will significantly benefit from a deep understanding of real world concurrency bug characteristics.</p>
</blockquote>
<blockquote>
<p>This paper provides the first (to the best of our knowledge) comprehensive real world concurrency bug characteristic study. Specifically, we have carefully examined concurrency bug patterns, manifestation, and fix strategies of 105 randomly selected real worldconcurrency bugs from 4 representative server and client opensource applications (MySQL, Apache, Mozilla and OpenOffice).Our study reveals several interesting findings and provides useful guidance for concurrency bug detection, testing, and concurrentprogramming language design.</p>
</blockquote>
<blockquote>
<p>Some of our findings are as follows: (1) Around one third ofthe examined non-deadlock concurrency bugs are caused by violation to programmers’ order intentions, which may not be easilyexpressed via synchronization primitives like locks and transactional memories; (2) Around 34% of the examined non-deadlockconcurrency bugs involve multiple variables, which are not welladdressed by existing bug detection tools; (3) About 92% of theexamined concurrency bugs can be reliably triggered by enforcingcertain orders among no more than 4 memory accesses. This indicates that testing concurrent programs can target at exploring possible orders among every small groups of memory accesses, insteadof among all memory accesses; (4) About 73% of the examinednon-deadlock concurrency bugs were not fixed by simply addingor changing locks, and many of the fixes were not correct at thefirst try, indicating the difficulty of reasoning concurrent executionby programmers.</p>
</blockquote>
<p>keywords: concurrent program, concurrency bug, bug characteristics</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<p>成熟且庞大的开源项目，具备不同的并发的需求 MySQL Apache Mozilla OpenOffice</p>
<p>从bug database中根据关键词选取至少包含一个关键词的bug并从中抽取约500个比较详尽的（包含了引起bug的原因、源码、如何解决bug）信息，并且这些bug都是由于开发人员引起的。</p>
<p>最终获取到了105个并发bug ### Details #### BUG pattern 研究 产生原因：(1)编码时违反原子性，多个线程访问了同一个变量 (2)对线程之间的执行先后顺序存在错误的假设</p>
<h4 id="bug-mainfestation-研究">BUG mainfestation 研究</h4>
<h4 id="可能影响可信度的因素">可能影响可信度的因素</h4>
<ul>
<li>随机选取的bug，不够全面</li>
<li>选择的应用不一定具备足够的代表性</li>
</ul>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Empirical Software Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [EMSE] Understanding integer overflow in C/C++</title>
    <url>/2020/08/19/paper/ISER/Empirical%20Software%20Engineering/emse-2/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>Integer overflow bugs in C and C++ programs are difficult to track down and may lead to fatal errors or exploitable vulner- abilities. Although a number of tools for finding these bugs exist, the situation is complicated because not all overflows are bugs. Better tools need to be constructed—but a thorough understanding of the issues behind these errors does not yet exist. We developed IOC, a dynamic checking tool for integer overflows, and used it to conduct the first detailed empirical study of the prevalence and patterns of occurrence of integer overflows in C and C++ code. Our results show that intentional uses of wraparound behaviors are more common than is widely believed; for example, there are over 200 distinct locations in the SPEC CINT2000 benchmarks where overflow occurs. Although many overflows are intentional, a large number of accidental overflows also occur. Orthogonal to programmers’ intent, overflows are found in both well-defined and undefined flavors. Applications executing undefined operations can be, and have been, broken by improvements in compiler optimizations. Looking beyond SPEC, we found and reported undefined integer overflows in SQLite, PostgreSQL, SafeInt, GNU MPC and GMP, Firefox, LLVM, Python, BIND, and OpenSSL; many of these have since been fixed.</p>
</blockquote>
<p>keywords: integer overflow, integer wraparound, undefined behavior</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<p>C / C++中并非所有的溢出都是bug，有一些是故意为之的，但是目前没有工具能够检测这一点，原因如下： - 本身对bit和byte级别的操作在C和C++中都是非常常见的，数学计算与位运算的界限模糊 - C和C++中对有符号数的规定中包含了UB - 开发者容易误用带符号数和无符号数</p>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Empirical Software Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [EMSE] Why we refactor? Confessions of GitHub contributors</title>
    <url>/2020/08/19/paper/ISER/Empirical%20Software%20Engineering/emse-5/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>

</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Empirical Software Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [EMSE] On the Naturalness of Software</title>
    <url>/2020/08/12/paper/ISER/Empirical%20Software%20Engineering/emse-3/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>Abstract—Natural languages like English are rich, complex, and powerful. The highly creative and graceful use of languages like English and Tamil, by masters like Shakespeare and Avvai yar, can certainly delight and inspire. But in practice, given cognitive constraints and the exigencies of daily life, most humanutterances are far simpler and much more repetitive and pre dictable. In fact, these utterances can be very usefully modeled using modern statistical methods. This fact has led to the phenomenal success of statistical approaches to speech recognition, natural language translation, question-answering, and text mining and comprehension.</p>
</blockquote>
<blockquote>
<p>We begin with the conjecture that most software is also natural, in the sense that it is created by humans at work, with all the attendant constraints and limitations—and thus, like natural language, it is also likely to be repetitive and predictable. Wethen proceed to ask whether a) code can be usefully modeled bystatistical language models and b) such models can be leveragedto support software engineers. Using the widely adoptedn-grammodel, we provide empirical evidence supportive of a positiveanswer to both these questions. We show that code is also veryrepetitive, and in fact even more so than natural languages. Asan example use of the model, we have developed a simple codecompletion engine for Java that, despite its simplicity, alreadyimproves Eclipse’s completion capability. We conclude the paper by laying out a vision for future research in this area.</p>
</blockquote>
<p>keywords:language models; n-gram; nature language processing; code completion; code suggestion</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Empirical Software Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [EMSE] Where Do Developers Log? An Empirical Study on Logging Practices in Industry</title>
    <url>/2020/08/15/paper/ISER/Empirical%20Software%20Engineering/emse-4/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>System logs are widely used in various tasks of software system management. It is crucial to avoid logging too little or toomuch. To achieve so, developers need to make informed decisions on where to log and what to log in their logging practices during development. However, there exists no work on studying such logging practices in industry or helping developers makeinformed decisions. To fill this significant gap, in this paper, wesystematically study the logging practices of developers in industry, with focus on where developers log. We obtain six valuable findings by conducting source code analysis on twolarge industrial systems (2.5M and 10.4M LOC, respectively) at Microsoft. We further validate these findings via aquestionnaire survey with 54 experienced developers in Microsoft. Inaddition, our study demonstrates the high accuracy of up to 90% F-Scorein predicting where to log.</p>
</blockquote>
<p>keywords: Logging practice, automatic logging, developer survey</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
<h4 id="研究主要关心的问题">研究主要关心的问题</h4>
<p>RQ1: 被log的代码片段主要有哪些分类 手动分类的结果：</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>类别</th>
<th>特征</th>
<th>开发者们认为的常见程度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Assertion-check logging</td>
<td>The logging statement is triggered by an Assert statement.</td>
<td>50%</td>
</tr>
<tr class="even">
<td>Return-value-check logging</td>
<td>The logging statement is contained in a clause following a branch statement (e.g., if, if-else, switch), while one or more function return values are checked in the branchcondition. In addition, the logging statement is not enclosed by any catch block within the cl</td>
<td>63%</td>
</tr>
<tr class="odd">
<td>Exception logging</td>
<td>The logging statement is contained either in a catch block or right before a throw statement.</td>
<td>80%</td>
</tr>
<tr class="even">
<td>Logic-branch logging</td>
<td>The logging statement is contained in a clause following a branch statement (e.g., if, if-else, switch), while the branch con- dition does not contain any check on a functionreturn value</td>
<td>67%</td>
</tr>
<tr class="odd">
<td>Observing-point logging</td>
<td>All the other situations that exclude the above categories</td>
<td>81%</td>
</tr>
</tbody>
</table>
<blockquote>
<p>总的来说可以归纳成两个分类，一种是用来记录意料之外的异常情况，一种是用来记录关键的执行点。而巧合的是在对开发者进行的调查中，Exception logging 和 Observing-point logging 也被认为是最常见的两种 log</p>
</blockquote>
<p>通过工具自动分类的结果：</p>
<p>RQ2: 代码会因为哪些原因被log</p>
<p>RQ3: 是否存在某种途径能够自动决定log的位置</p>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Empirical Software Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [FM] Model Checking for Programming Languages using VeriSoft</title>
    <url>/2020/07/19/paper/ISER/Formal%20Methods/fm-2/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>Verication by state-space exploration, also often referred to as checking", is an eective methodfor analyzing the correctness of concurrent reactive systems (e.g., communication protocols). Unfortunately,existing model-checking techniques are restricted to theverication of properties of models, i.e., abstractions, ofconcurrent systems.In this paper, we discuss how model checking can beextended to deal directly with " descriptions ofconcurrent systems, e.g., implementations of communication protocols written in programming languages suchas C or C++. We then introduce a new search technique that is suitable for exploring the state spaces ofsuch systems. This algorithm has been implemented inVeriSoft, a tool for systematically exploring the statespaces of systems composed of several concurrent processes executing arbitrary C code. As an example ofapplication, we describe how VeriSoft successfully dis-covered an error in a 2500-line C program controllingrobots operating in an unpredictable environment.</p>
</blockquote>
<p>keywords: model-checking</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<ol type="1">
<li>并发系统中非model-checking的方法找到难以检查或复现的error</li>
<li>过去的一些工具都是建立在“系统的每一个状态都能够很容易的被一个唯一的标示符表示”的这一假设上。然而实际上，一个进程的状态是由它可以访问的并且可能会改变它本身的状态的数据组成的（简单点说例如寄存器和内存），这是不可能由一个简单的string来表示的，因此在执行中会遇到各种各样的问题</li>
<li>原有方法的状态探索的策略会在面对状态空间膨胀时缺乏一个有效的机制能减少无效探索</li>
</ol>
<h3 id="evalution">Evalution</h3>
<p>设计了一个叫做测试verisoft的工具测试了一个2500行的C程序。 主要检查四类问题：deadlock assertion divergence（某个visible operation超时） livelock（某个时刻资源必须大于n） 结果：成功的在几分钟内找到了29个transition的组合会导致divergence问题</p>
<p>我认为Evaluation不是这篇文章最大的亮点，但是这个确实证明了文中提出的算法能够在一个复杂的由现代语言编写的中小型规模项目中work，并且时间是可以完全可以接受的（几分钟）</p>
<h3 id="details">Details</h3>
<h4 id="什么是model-checking">什么是model checking</h4>
<p>model checking是一种用于验证并发系统正确性的方法（后来分布式系统也可以认为是一种并发系统），而广义上讲，所有通过自动化状态空间探索来验证程序的方法都被成为model checking。它使用一种modeling language来描述程序的状态空间，并以此为基础来检查一些特定的属性，例如死锁、assertion。model checking主要用于寻找难以检测和复现的error</p>
<h4 id="缩减状态空间">缩减状态空间</h4>
<p>step1 定义一系列的形式化的语义（具体见liquidtext笔记） step2 使用所有可达的的全局状态以及这些状态之间的transition来描述整个系统的行为，在这里就缩减了大量的无关状态。在一个全局状态上，要么blocking，要么就能够通过有限的进程内的执行达到下一个全局状态 step3 通过优化的算法来减少无效的状态访问</p>
<p>理论依据（证明略） &gt; Consider a concurrent system as dened above, and let AG denote its state space. Then, all the dead locks that are reachable after the initialization of the system are global states, and are therefore in AG. Moreover, if there exists a state reachable after the initialization of the system where an assertion is violated, then there exists a global state in AG where the same assertion is violated.</p>
<blockquote>
<p>知乎上的一个解释 针对无死锁这个性质对程序做model checking。 那么它是怎么减少状态空间的大小的呢？ 无死锁这个性质显然针对的是多线程程序。 对于多线程程序，每个线程都有自己的局部状态(如local stack) 以及共享的全局状态(比如全局变量)。它们合并起来就是整个程序状态。 产生死锁就是指在某个程序状态上，每个线程的局部状态都不能再前进了。 设想一下，每个线程在执行指令的过程中要么改变的是自己的局部状态， 要么改变的是全局状态来和其它线程通信。我们把它们分别称作局部指令与全局指令。 两条全局指令之间的那些局部指令要么是有限的，要么会陷入某种等待。 所以当没有死锁的时候，即各个线程没有同时陷入等待的时候， 经过有限步局部指令，全局状态必然会因为全局指令的执行而不断改变。 反之，如果产生死锁，全局状态就不能再前进了。 因此，我们只要无视局部状态，仅观察全局状态能否前进就可以确定有没有死锁产生了。 程序的状态空间这样就被我们缩减到了全局状态空间</p>
</blockquote>
<h4 id="优化探索策略">优化探索策略</h4>
<p>原来的探索策略 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Initialize:Set is empty; H is empty;</span><br><span class="line">    add s0 to Set;</span><br><span class="line">Loop: <span class="keyword">while</span> Set != empty ; <span class="keyword">do</span> &#123;</span><br><span class="line">    take s out of Set;</span><br><span class="line">    <span class="keyword">if</span> s is NOT already in H then&#123;</span><br><span class="line">      enter s in H;</span><br><span class="line">      T = enabled(s);</span><br><span class="line">      <span class="keyword">for</span> all t in T <span class="keyword">do</span>&#123;</span><br><span class="line">        s<span class="number">&#x27;</span> = succ(s) after t;</span><br><span class="line">        add s<span class="number">&#x27;</span> to Set;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>问题1：状态表示过于简单；状态庞大且复杂难以存储 -&gt; 依然进行探索但是不存放状态，而是存放一个有上限的transion记录 问题2：会产生大量的重入 -&gt; 根据依赖关系选择transition，并且记录已经达到过的transition</p>
<p>优化后的算法 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Initialize: Stack is empty;</span><br><span class="line">Search() &#123;</span><br><span class="line">    DFS(∅);</span><br><span class="line">  &#125;</span><br><span class="line">DFS(<span class="built_in">set</span>: Sleep) &#123;</span><br><span class="line">    T = Persistent Set()\Sleep;</span><br><span class="line">    <span class="keyword">while</span> T <span class="number">6</span>= ; <span class="keyword">do</span> &#123;</span><br><span class="line">      take t out of T ;</span><br><span class="line">      push (t) onto Stack;</span><br><span class="line">      Execute(t);</span><br><span class="line">      DFS(&#123;t<span class="number">&#x27;</span> ∈ Sleep | t<span class="number">&#x27;</span> <span class="keyword">and</span> t are independent&#125;);</span><br><span class="line">      pop t from Stack;</span><br><span class="line">      Undo(t);</span><br><span class="line">      Sleep = Sleep ∪ &#123;t&#125;;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> 理论依据（证明略） &gt; Consider a concurrent system as dened in Section 2, and let AG denote its state space. Assume AG is nite and acyclic. Then, al l the dead locks in AG are visited by Algorithm 2（上面的这个算法）. Moreover, if there exists a global state in AG where an assertion is violated, then there exists a global state visited by Algorithm 2 where the same assertion is violated.</p>
<p>产生重入的两个原因 - From the initial state, the exploration of any interleaving of a single finite partial ordering of transitions of the system always leads to the same state.This state will thus be visited several times because of all these interleavings. - From the initial state, explorations of differentnite partial orderings of transitions may lead to the same state.</p>
<h4 id="todo">todo</h4>
<p>算法的直觉还是没能很好的get，再讨论一下</p>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Formal Methods</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [FM] Symbolic execution and program testing</title>
    <url>/2020/07/17/paper/ISER/Formal%20Methods/fm-1/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>This paper describes the symbolic execution of programs. Instead of supplying the normal inputs to a program (e.g. numbers) one supplies symbols representing arbitrary values. The execution proceeds as in a normal execution except that values may he symbolic formulas over the input symbols. The difficult, yet interesting issues arise during the symbolic execution of conditional branch type statements. A particular system called EFFIGY which provides symbolic execution for program testing and debugging is also described, it interpretively executes programs written in a simple PL/I style programming language. It includes many standard debugging features, the ability to manage and to prove things about symbolic expressions, a simple program testing manager, and a program verifier. A brief discussion of the relationship between symbolic execution and program proving is also included.</p>
</blockquote>
<p>Key Words and Phrases: symbolic execution, program testing, program debugging, program proving, program verification, symbolic interpretation</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<ol type="1">
<li>不是所有的程序都有一个formal specification（类似于输入、输出、约束条件的集合），但是仍希望能够很好的验证它</li>
<li>给定的输入测试正确不能说明其余未测试到的地方也正确</li>
<li>尽可能减少测试成本</li>
</ol>
<h3 id="evalution">Evalution</h3>
<p>无</p>
<h3 id="details">Details</h3>
<p>符号执行的天生缺陷 -&gt; 需要使用一个理想模型来进行符号执行 1. 无法考虑实际硬件的情况，例如寄存器个数，寄存器能够存放的数值范围 2. 一些程序的执行树是无穷多的 3. 即便是再简单合适的语言对于if语句的符号执行都需要理论证明，而这个理论证明理论上不可能</p>
<h4 id="符号执行是什么">符号执行是什么？</h4>
<p>符号执行是在保证了原有的语义都不被修改的基础上进行扩充，唯一可以引入符号执行的时机是将他们作为程序的输入</p>
<h4 id="如何定义符号执行">如何定义符号执行？</h4>
<p>input ：输入{a1,a2,a3...} pc ：path condition 关于输入集合{ai}的boolean表达式，并且绝对不会包含程序的变量。初始值为true q ：具体表达式</p>
<p>执行：对某一个if语句的一次执行情况进行归纳，而不针对这个if语句 nonforking ：所有的输入都能够要么满足pc，要么不满足pc，不会两者都不满足 forking ：pc和!pc都不满足，需要把当前的if语句的条件加到pc后面更新pc</p>
<h4 id="符号执行的性质">符号执行的性质</h4>
<p>可交换：在输入时将ai替换为某个具体的实例进行执行和执行到最后再替换成实例的效果是完全一致的 设执行为E，实例集合为K，符号集合为X，程序为K 则E（P（X））-&gt; 实例化K === P（X）实例化K -&gt; 执行P（K） === E（P（K））</p>
<h4 id="执行树">执行树</h4>
<p>对每个forking执行的IF语句划分出true和false两条路径</p>
<p>性质： - 每个叶节点都存在非符号的测试输入能够到达 - 每一个叶节点代表的pc都和其他pc是独立的，即任意两条之间一定存在一个唯一的节点，在那之后两者分开</p>
<h4 id="todo">todo</h4>
<ol type="1">
<li>剩下一个floyd prove没看</li>
</ol>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Formal Methods</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [FM] KLEE : Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs</title>
    <url>/2020/07/25/paper/ISER/Formal%20Methods/fm-3/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>We present a new symbolic execution tool, KLEE, capable of automatically generating tests that achievehigh coverage on a diverse set of complex andenvironmentally-intensive programs. We used KLEE tothoroughly check all 89 standalone programs in theGNU COREUTILS utility suite, which form the coreuser-level environment installed on millions of Unix systems, and arguably are the single most heavily tested setof open-source programs in existence. KLEE-generatedtests achieve high line coverage — on average over 90%per tool (median: over 94%) — and significantly beatthe coverage of the developers’ own hand-written testsuite. When we did the same for 75 equivalent tools inthe BUSYBOX embedded system suite, results were evenbetter, including 100% coverage on 31 of them.We also used KLEE as a bug finding tool, applying it to 452 applications (over 430K total lines of code), whereit found 56 serious bugs, including three in COREUTILSthat had been missed for over 15 years. Finally, we usedKLEE to crosscheck purportedly identical BUSYBOX andCOREUTILS utilities, finding functional correctness errors and a myriad of inconsistencies.</p>
</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h4 id="contribution">Contribution</h4>
<p>KLEE的优势： - 适用于大型项目 - 简洁的状态表示 - 启发式搜索算法获得高代码覆盖率 - 简洁直接的与环境交互的方法</p>
<h3 id="motivation">Motivation</h3>
<ul>
<li>以往工具在大型项目上表现不佳
<ul>
<li>路径爆炸</li>
<li>与环境交互处理方式不当 ### Evalution</li>
</ul></li>
</ul>
<h3 id="details">Details</h3>
<p>运行原理： KLEE的核心逻辑是一个解释器循环，它每次都选择一个state去执行并且把执行到的指令进行符号化，直到没有更多的state可以执行或者超过了规定的执行时间</p>
<p>KLEE的设计 symbolic process(state) : register file, stack, heap, pc,path condition</p>
<h3 id="todo">todo</h3>
<p>Evalution部分还没有看，这部分实验很厉害，好好看一下</p>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Formal Methods</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [FM] Scalable multiline program patch synthesis via symbolic analysis</title>
    <url>/2020/07/25/paper/ISER/Formal%20Methods/fm-4/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>We present MergePoint, a new binary-only symbolic execution system for large-scale testing of commodity off-the-shelf(COTS) software. MergePoint introduces veritesting, a newtechnique that employs static symbolic execution to amplifythe effect of dynamic symbolic execution. Veritesting allowsMergePoint to find twice as many bugs, explore orders of magnitude more paths, and achieve higher code coverage thanprevious dynamic symbolic execution systems. MergePointis currently running daily on a 100 node cluster analyzing33,248 Linux binaries; has generated more than 15 billionSMT queries, 200 million test cases, 2,347,420 crashes, andfound 11,687 bugs in 4,379 distinct applications.</p>
</blockquote>
<p>keywords: Veritesting, Symbolic Execution, Verification</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Formal Methods</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [SEP] Development and evaluation of a model of programming errors</title>
    <url>/2020/08/19/paper/ISER/Software%20Engineering%20Process/sep-1/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>Models of programming and debugging suggest many causes of errors, and many classifications of error types exist. Yet, there has been no attempt to link causes of errors to these classifications, nor is there a common vocabulary for reasoning about such causal links. This makes it difficult to compare the abilities of programming styles, languages, and environments to prevent errors. To address this issue, this paper presents a model of programming errors based on past studies of errors. The model was evaluated with two observational of Alice, an event-based programming system, revealing that most errors were due to attentional and strategic problems in implementing algorithms, language constructs, and uses of libraries. In general, the model can support theoretical, design, and educational programming research.</p>
</blockquote>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Engineering Process</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [SEP] code2vec: Learning distributed representations of code</title>
    <url>/2020/09/18/paper/ISER/Software%20Engineering%20Process/sep-4/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>

</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Engineering Process</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [SEP] Automating string processing in spreadsheets using input-output examples</title>
    <url>/2020/09/18/paper/ISER/Software%20Engineering%20Process/sep-5/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>

</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Engineering Process</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [SEP] A Three-Year Participant Observation of Software Startup Software Evolution</title>
    <url>/2020/08/27/paper/ISER/Software%20Engineering%20Process/sep-3/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>

</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Engineering Process</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [SEP] A study of developer work habits</title>
    <url>/2020/08/27/paper/ISER/Software%20Engineering%20Process/sep-2/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>

</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Engineering Process</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [SME] Visualization of test information to assist fault localization</title>
    <url>/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-1/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>One of the most expensive and time-consuming components of the debugging process is locating the errors or faults. To locate faults, developers must identify statements involved in failures and select suspicious statements that might contain faults. This paper presents a new technique that uses visualization to assist with these tasks. The technique uses color to visually map the participation of each program statement in the out ome of the execution of the program with a test suite, onsisting of both passed and failed test cases. Based on this visual mapping, a user can inspe t the statements in the program, identify statements involved in failures, and locate potentially faulty statements. The paper also describes a prototype tool that implements our technique along with a set of empirical studies that use the tool for evaluation of the technique. The empirical studies show that, for the subject we studied, the technique can be eeffective in helping a user locate faults in a program.</p>
</blockquote>
<p>keywords: software visualization,fault localization,debugging,testing</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<p>人工定位bug是想当费事的事情，因此希望使用自动执行测试的办法在执行过程中使用不同的颜色以及颜色的不同深度来映射代码的可信程度，帮助用户来定位bug</p>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Maintence and Evolution</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [SME] A technique for cheap recovery</title>
    <url>/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-3/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>

</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Maintence and Evolution</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [SME] Ten years of implementation and experience</title>
    <url>/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-4/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>

</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Maintence and Evolution</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [SME] Simplifying and isolating failure-inducing input</title>
    <url>/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-2/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>Given some test case, a program fails. Which circumstances of the test case are responsible for the particular failure? The Delta Debugging algorithm generalizes and simplifies some failing test case to a minimal test case that still produces the failure; it also isolates the difference between a passing and a failing test case.</p>
</blockquote>
<blockquote>
<p>In a case study, the Mozilla web browser crashed after 95 user actions. Our prototype implementation automatically simplified the input to 3 relevant user actions. Likewise, it simplified 896 lines of HTML to the single line that caused the failure. The case study required 139 automated test runs, or 35 minutes on a 500 MHz PC.</p>
</blockquote>
<p>keywords: Terms—automated debugging, debugging aids, testing tools, combinatorial testing, diagnostics, tracing.</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<p>对于开发者们来说bug report有一个固有的矛盾，他们既希望report能够special且详尽，又希望report能够集中在关键的几个语句上以便定位bug和将类似的问题聚集在一起。这篇文章希望模拟人的思考逻辑通过二分的方法来定位到bug的存在。这篇文章通过ddmin的方法来找到一个最小的能够正好触发bug的集合和一个与它几乎一致但是略微不同的且不能触发bug的集合。来帮助开发者减少debug所消耗的时间。</p>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Maintence and Evolution</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [STA] Dynamically discovering likely program invariants to support program evolution</title>
    <url>/2020/09/18/paper/ISER/Software%20Testing%20and%20Analysis/sta-1/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>Explicitly stated program invariants can help programmers by identifying program properties that must be preserved when modifying code. In practice, however, these invariants are usually implicit. An alternative to expecting programmers to fully annotate code with invariants is to automatically infer likely invariants from the program itself. This research focuses on dynamic techniques for discovering invariants from execution traces.</p>
</blockquote>
<blockquote>
<p>This article reports three results. First, it describes techniques for dynamically discovering invariants,along with an implementation, named Daikon, that embodies these techniques. Second, it reports on theapplication of Daikon to two sets of target programs. In programs from Gries's work on program derivation,the system rediscovered predened invariants. In a C program lacking explicit invariants, the system discovered invariants that assisted a software evolution task. These experiments demonstrate that, at least forsmall programs, invariant inference is both accurate and useful. Third, it analyzes scalability issues such asinvariant detection runtime and accuracy as functions of test suites and program points instrumented.</p>
</blockquote>
<p>keywords: Program invariants, formal specication, software evolution, dynamic analysis, execution traces, logical inference, pattern recognition</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<p>不变式在程序开发的过程中是十分重要的，它能够保证程序不会因为修改代码而破坏原有的代码正确性。但是大多数时候不变式都是非显式的，这篇文章就想通过追踪变量值的变化来动态的推导出不变式。</p>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Testing and Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [STA] Bugs as deviant behavior: A general approach to inferring errors in systems code</title>
    <url>/2021/04/12/paper/ISER/Software%20Testing%20and%20Analysis/sta-2/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>A major obstacle to finding program errors in a real system is knowing what correctness rules the system must obey. These rules are often undocumented or specified in an ad hoc manner. This paper demonstrates techniques that automatically extract such checking information from the source code itself, rather than the programmer, thereby avoiding the need for a priori knowledge of system rules.</p>
</blockquote>
<blockquote>
<p>The cornerstone of our approach is inferring programmer "beliefs" that we then crosscheck for contra dictions. Beliefs are facts implied by code: a dereference of a pointer, p, implies a belief that p is nonnull, a call to "tmlock(1)" implies that 1 was locked, etc. For be liefs we know the programmer must hold, such as the pointer dereference above, we immediately flag contra dictions as errors. For beliefs that the programmer may hold, we can assume these beliefs hold and use a statistical analysis to rank the resulting errors from most to least likely. For example, a call to "spin_lock" followed once by a call to "spin_tmlock" implies that the programmer may have paired these calls by coincidence.</p>
</blockquote>
<blockquote>
<p>If the pairing happens 999 out of 1000 times, though, then it is probably a valid belief and the sole deviation a probable error. The key feature of this approach is that it requires no a priori knowledge of truth: if two beliefs contradict, we know that one is an error without knowing what the correct belief is. Conceptually, our checkers extract beliefs by tailor ing rule "templates" to a system for example, finding all functions that fit the rule template "&lt;a&gt; must be paired with &lt; b&gt;." We have developed six checkers that follow this conceptual framework. They find hundreds of bugs in real systems such as Linux and OpenBSD. From our experience, they give a dramatic reduction in the manual effort needed to check a large system. Com pared to our previous work , these template checkers find ten to one hundred times more rule instances and derive properties we found impractical to specify manually.</p>
</blockquote>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<p>这篇文章基于的一个假设是人是很难寻找和归纳出对于一个程序什么是必须遵循的正确的法则，什么是应该遵循的法则。这并不是指人不能总结出一些法则，而是说在编码过程中很难强制机器去遵守。因此，希望能够自动提取出某段特定代码应该有什么样的约束，例如在使用指针的时候指针指向的对象必须非空，例如lock和unlock应该要成对出现。而在静态检查的过程中如果发现代码违背了这些最基本的一些应该遵守的法则，那么就认为是一个可能的错误。 ### Evalution</p>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Testing and Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [STA] A lightweight, general system for finding serious storage system errors</title>
    <url>/2020/09/18/paper/ISER/Software%20Testing%20and%20Analysis/sta-3/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>Storage systems such as file systems, databases, and RAID systems have a simple, basic contract: you give them data, they do not lose or corrupt it. Often they store the only copy, making its irrevocable loss almost arbitrarily bad. Unfortunately, their code is exceptionally hard to get right, since it must correctly recover from any crash at any program point, no matter how their state was smeared across volatile and persistent memory.</p>
</blockquote>
<blockquote>
<p>This paper describes EXPLODE, a system that makes it easy to systematically check real storage systems for errors. It takes user-written, potentially system-specific checkers and uses them to drive a storage system into tricky corner cases, including crash recovery errors. EXPLODE uses a novel adaptation of ideas from model checking, a comprehensive, heavyweight formal verification technique, that makes its checking more systematic (and hopefully more effective) than a pure testing approach while being just as lightweight.</p>
</blockquote>
<blockquote>
<p>EXPLODE is effective. It found serious bugs in a broad range of real storage systems (without requiring source code): three version control systems, Berkeley DB, an NFS implementation, ten file systems, a RAID system, and the popular VMware GSX virtual machine. We found bugs in every system we checked, 36 bugs in total, typically with little effort.</p>
</blockquote>
<p>keywords:</p>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<p>文件系统中会有各种各样的机制来预防崩溃，而如果这些机制中也出现了bug，那会是十分严重的。但是目前已有的工作检测文件系统中的bug的方法还是非常的原始和低效的，因此就开发了一个新的工具（严重缺乏操作系统关于文件系统的知识，很多地方没看懂） ### Evalution</p>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Testing and Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>[ISER] [STA] AddressSanitizer: A fast address sanity checker</title>
    <url>/2020/09/18/paper/ISER/Software%20Testing%20and%20Analysis/sta-4/</url>
    <content><![CDATA[<h3 id="abstract">Abstract</h3>
<blockquote>
<p>Memory access bugs, including buffer overflows and uses of freed heap memory, remain a serious problem for programming languages like C and C++. Many memory error detectors exist, but most of them are either slow or detect a limited set of bugs, or both.</p>
</blockquote>
<blockquote>
<p>This paper presents AddressSanitizer, a new memory error detector. Our tool finds out-of-bounds accesses to heap, stack, and global objects, as well as use-after-free bugs. It employs a specialized memory allocator and code instrumentation that is simple enough to be implemented in any compiler, binary translation system, or even in hardware.</p>
</blockquote>
<blockquote>
<p>AddressSanitizer achieves efficiency without sacrificing comprehensiveness. Its average slowdown is just 73% yet it accurately detects bugs at the point of occurrence. It has found over 300 previously unknown bugs in the Chromium browser and many bugs in other software.</p>
</blockquote>
<h3 id="总体评价">总体评价</h3>
<h3 id="motivation">Motivation</h3>
<p>目前检测边界溢出和访问已释放问题的工具要么不够快要么开销太大（好简单粗暴</p>
<h3 id="evalution">Evalution</h3>
<h3 id="details">Details</h3>
]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>Software Testing and Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>由pipeline和重定向引发的血案</title>
    <url>/2020/07/20/lecture/os/interesting-bug-1/</url>
    <content><![CDATA[<h3 id="问题重现">问题重现</h3>
<p>因为想要去除某一段文本里面的所有换行，因此编写了一个脚本 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cat <span class="variable">$1</span> | tr <span class="string">&quot;\n&quot;</span> <span class="string">&quot; &quot;</span> &gt; <span class="variable">$1</span></span><br></pre></td></tr></table></figure></p>
<p>然而这段脚本的执行并不如我预期中的那样能够把输出重定向回文件，而是反而清空了文件</p>
<p>StackOverflow上面的回答 https://stackoverflow.com/questions/3055005/is-it-ok-to-use-the-same-input-file-as-output-of-a-piped-command https://stackoverflow.com/questions/39426655/redirecting-the-cat-ouput-of-file-to-the-same-file</p>
<blockquote>
<p>All commands in a pipeline execute at the same time, and the shell prepares redirections before executing the commands. So, it is likely that the command will overwrite the file before cat reads it.</p>
</blockquote>
<p>这个回答里涉及到了几点： 1. pipeline中各个进程的执行时机 2. 重定向、pipeline与指令之间的执行顺序 3. overwrite文件</p>
<h4 id="执行时机">执行时机</h4>
<p>下面是两份strace log的执行结果，可以看到需要执行cat和tr的进程都是从sh的进程中clone出来的，的确是同时执行的，唯一的保证就是将前一个进程的输出成功的重定向到下一个进程的输入。这是由pipeline保证的。</p>
<p>man bash中提到 &gt; The standard output of command is connected via a pipe to the standard input of command2. This connection is performed before any redirections specified by the command.</p>
<blockquote>
<p>Before a command is executed, its input and output may be redirected using a special notation interpreted by the shell.</p>
</blockquote>
<p>由此可以看出三者的执行顺序是 pipeline连接两个指令之间的标准输入和标准输出 &gt; 重定向 &gt; 指令执行</p>
<h4 id="strace结果">strace结果</h4>
<h5 id="清空了文件的strace-log">清空了文件的strace log</h5>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">9855  execve(<span class="string">&quot;/bin/sh&quot;</span>, [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;cat 1-redirect | tr \&quot;\\n\&quot; \&quot; \&quot; &gt; 1&quot;</span>...], 0x7ffce75660f8 /* 61 vars */) = 0</span><br><span class="line">9855  access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">9855  fstat(3, &#123;st_mode=S_IFREG|0644, st_size=103311, ...&#125;) = 0</span><br><span class="line">9855  close(3)                          = 0</span><br><span class="line">9855  access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">9855  <span class="built_in">read</span>(3, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260\34\2\0\0\0\0\0&quot;</span>..., 832) = 832</span><br><span class="line">9855  fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2030544, ...&#125;) = 0</span><br><span class="line">9855  close(3)                          = 0</span><br><span class="line">9855  arch_prctl(ARCH_SET_FS, 0x7f32b9ad0540) = 0</span><br><span class="line">9855  getuid()                          = 1000</span><br><span class="line">9855  getgid()                          = 1000</span><br><span class="line">9855  getpid()                          = 9855</span><br><span class="line">9855  rt_sigaction(SIGCHLD, &#123;sa_handler=0x558b265a3200, sa_mask=~[RTMIN RT_1], sa_flags=SA_RESTORER, sa_restorer=0x7f32b9511fd0&#125;, NULL, 8) = 0</span><br><span class="line">9855  geteuid()                         = 1000</span><br><span class="line">9855  getppid()                         = 9853</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/home/wym0120/have-a-try&quot;</span>, &#123;st_mode=S_IFDIR|0755, st_size=4096, ...&#125;) = 0</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;.&quot;</span>, &#123;st_mode=S_IFDIR|0755, st_size=4096, ...&#125;) = 0</span><br><span class="line">9855  geteuid()                         = 1000</span><br><span class="line">9855  getegid()                         = 1000</span><br><span class="line">9855  rt_sigaction(SIGINT, NULL, &#123;sa_handler=SIG_DFL, sa_mask=[], sa_flags=0&#125;, 8) = 0</span><br><span class="line">9855  rt_sigaction(SIGINT, &#123;sa_handler=0x558b265a3200, sa_mask=~[RTMIN RT_1], sa_flags=SA_RESTORER, sa_restorer=0x7f32b9511fd0&#125;, NULL, 8) = 0</span><br><span class="line">9855  rt_sigaction(SIGQUIT, NULL, &#123;sa_handler=SIG_DFL, sa_mask=[], sa_flags=0&#125;, 8) = 0</span><br><span class="line">9855  rt_sigaction(SIGQUIT, &#123;sa_handler=SIG_DFL, sa_mask=~[RTMIN RT_1], sa_flags=SA_RESTORER, sa_restorer=0x7f32b9511fd0&#125;, NULL, 8) = 0</span><br><span class="line">9855  rt_sigaction(SIGTERM, NULL, &#123;sa_handler=SIG_DFL, sa_mask=[], sa_flags=0&#125;, 8) = 0</span><br><span class="line">9855  rt_sigaction(SIGTERM, &#123;sa_handler=SIG_DFL, sa_mask=~[RTMIN RT_1], sa_flags=SA_RESTORER, sa_restorer=0x7f32b9511fd0&#125;, NULL, 8) = 0</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/home/wym0120/.autojump/bin/cat&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/usr/local/sbin/cat&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/usr/local/bin/cat&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/usr/sbin/cat&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/usr/bin/cat&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/sbin/cat&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/bin/cat&quot;</span>, &#123;st_mode=S_IFREG|0755, st_size=35064, ...&#125;) = 0</span><br><span class="line">9855  pipe([3, 4])                      = 0</span><br><span class="line">9855  <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f32b9ad0810) = 9856</span><br><span class="line">9855  close(4)                          = 0</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/home/wym0120/.autojump/bin/tr&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/usr/local/sbin/tr&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/usr/local/bin/tr&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/usr/sbin/tr&quot;</span>, 0x7ffd51e78a30) = -1 ENOENT (No such file or directory)</span><br><span class="line">9855  <span class="built_in">stat</span>(<span class="string">&quot;/usr/bin/tr&quot;</span>, &#123;st_mode=S_IFREG|0755, st_size=47288, ...&#125;) = 0</span><br><span class="line">9855  <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f32b9ad0810) = 9857</span><br><span class="line">9855  close(3)                          = 0</span><br><span class="line">9855  close(-1)                         = -1 EBADF (Bad file descriptor)</span><br><span class="line">9855  wait4(-1,  &lt;unfinished ...&gt;</span><br><span class="line">9857  dup2(3, 0 &lt;unfinished ...&gt;</span><br><span class="line">9856  close(3 &lt;unfinished ...&gt;</span><br><span class="line">9857  &lt;... dup2 resumed&gt; )              = 0</span><br><span class="line">9856  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9857  close(3 &lt;unfinished ...&gt;</span><br><span class="line">9856  dup2(4, 1 &lt;unfinished ...&gt;</span><br><span class="line">9857  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9856  &lt;... dup2 resumed&gt; )              = 1</span><br><span class="line">9857  openat(AT_FDCWD, <span class="string">&quot;1-redirect&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC, 0666 &lt;unfinished ...&gt;</span><br><span class="line">9856  close(4)                          = 0</span><br><span class="line">9857  &lt;... openat resumed&gt; )            = 3</span><br><span class="line">9857  fcntl(1, F_DUPFD, 10 &lt;unfinished ...&gt;</span><br><span class="line">9856  execve(<span class="string">&quot;/bin/cat&quot;</span>, [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;1-redirect&quot;</span>], 0x558b274b7fe8 /* 61 vars */ &lt;unfinished ...&gt;</span><br><span class="line">9857  &lt;... fcntl resumed&gt; )             = 10</span><br><span class="line">9857  close(1)                          = 0</span><br><span class="line">9856  &lt;... execve resumed&gt; )            = 0</span><br><span class="line">9857  fcntl(10, F_SETFD, FD_CLOEXEC)    = 0</span><br><span class="line">9857  dup2(3, 1 &lt;unfinished ...&gt;</span><br><span class="line">9856  access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK &lt;unfinished ...&gt;</span><br><span class="line">9857  &lt;... dup2 resumed&gt; )              = 1</span><br><span class="line">9857  close(3 &lt;unfinished ...&gt;</span><br><span class="line">9856  &lt;... access resumed&gt; )            = -1 ENOENT (No such file or directory)</span><br><span class="line">9857  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9856  access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK &lt;unfinished ...&gt;</span><br><span class="line">9857  execve(<span class="string">&quot;/usr/bin/tr&quot;</span>, [<span class="string">&quot;tr&quot;</span>, <span class="string">&quot;\\n&quot;</span>, <span class="string">&quot; &quot;</span>], 0x558b274b8268 /* 61 vars */ &lt;unfinished ...&gt;</span><br><span class="line">9856  &lt;... access resumed&gt; )            = -1 ENOENT (No such file or directory)</span><br><span class="line">9856  openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC &lt;unfinished ...&gt;</span><br><span class="line">9857  &lt;... execve resumed&gt; )            = 0</span><br><span class="line">9856  &lt;... openat resumed&gt; )            = 3</span><br><span class="line">9856  fstat(3, &#123;st_mode=S_IFREG|0644, st_size=103311, ...&#125;) = 0</span><br><span class="line">9857  access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">9856  close(3 &lt;unfinished ...&gt;</span><br><span class="line">9857  access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK &lt;unfinished ...&gt;</span><br><span class="line">9856  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9857  &lt;... access resumed&gt; )            = -1 ENOENT (No such file or directory)</span><br><span class="line">9856  access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK &lt;unfinished ...&gt;</span><br><span class="line">9857  openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC &lt;unfinished ...&gt;</span><br><span class="line">9856  &lt;... access resumed&gt; )            = -1 ENOENT (No such file or directory)</span><br><span class="line">9857  &lt;... openat resumed&gt; )            = 3</span><br><span class="line">9856  openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC &lt;unfinished ...&gt;</span><br><span class="line">9857  fstat(3,  &lt;unfinished ...&gt;</span><br><span class="line">9856  &lt;... openat resumed&gt; )            = 3</span><br><span class="line">9857  &lt;... fstat resumed&gt; &#123;st_mode=S_IFREG|0644, st_size=103311, ...&#125;) = 0</span><br><span class="line">9856  <span class="built_in">read</span>(3, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260\34\2\0\0\0\0\0&quot;</span>..., 832) = 832</span><br><span class="line">9857  close(3 &lt;unfinished ...&gt;</span><br><span class="line">9856  fstat(3,  &lt;unfinished ...&gt;</span><br><span class="line">9857  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9856  &lt;... fstat resumed&gt; &#123;st_mode=S_IFREG|0755, st_size=2030544, ...&#125;) = 0</span><br><span class="line">9857  access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">9857  openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">9857  <span class="built_in">read</span>(3, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260\34\2\0\0\0\0\0&quot;</span>..., 832) = 832</span><br><span class="line">9857  fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2030544, ...&#125;) = 0</span><br><span class="line">9856  close(3)                          = 0</span><br><span class="line">9856  arch_prctl(ARCH_SET_FS, 0x7fc0f8b44540) = 0</span><br><span class="line">9857  close(3)                          = 0</span><br><span class="line">9857  arch_prctl(ARCH_SET_FS, 0x7f56e0751540) = 0</span><br><span class="line">9856  openat(AT_FDCWD, <span class="string">&quot;/usr/lib/locale/locale-archive&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">9856  fstat(3, &#123;st_mode=S_IFREG|0644, st_size=3004224, ...&#125;) = 0</span><br><span class="line">9856  close(3)                          = 0</span><br><span class="line">9857  openat(AT_FDCWD, <span class="string">&quot;/usr/lib/locale/locale-archive&quot;</span>, O_RDONLY|O_CLOEXEC &lt;unfinished ...&gt;</span><br><span class="line">9856  fstat(1,  &lt;unfinished ...&gt;</span><br><span class="line">9857  &lt;... openat resumed&gt; )            = 3</span><br><span class="line">9857  fstat(3,  &lt;unfinished ...&gt;</span><br><span class="line">9856  &lt;... fstat resumed&gt; &#123;st_mode=S_IFIFO|0600, st_size=0, ...&#125;) = 0</span><br><span class="line">9857  &lt;... fstat resumed&gt; &#123;st_mode=S_IFREG|0644, st_size=3004224, ...&#125;) = 0</span><br><span class="line">9856  openat(AT_FDCWD, <span class="string">&quot;1-redirect&quot;</span>, O_RDONLY) = 3</span><br><span class="line">9856  fstat(3,  &lt;unfinished ...&gt;</span><br><span class="line">9857  close(3 &lt;unfinished ...&gt;</span><br><span class="line">9856  &lt;... fstat resumed&gt; &#123;st_mode=S_IFREG|0644, st_size=0, ...&#125;) = 0</span><br><span class="line">9857  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9856  fadvise64(3, 0, 0, POSIX_FADV_SEQUENTIAL &lt;unfinished ...&gt;</span><br><span class="line">9857  fadvise64(0, 0, 0, POSIX_FADV_SEQUENTIAL &lt;unfinished ...&gt;</span><br><span class="line">9856  &lt;... fadvise64 resumed&gt; )         = 0</span><br><span class="line">9857  &lt;... fadvise64 resumed&gt; )         = -1 ESPIPE (Illegal seek)</span><br><span class="line">9857  <span class="built_in">read</span>(0,  &lt;unfinished ...&gt;</span><br><span class="line">9856  <span class="built_in">read</span>(3, <span class="string">&quot;&quot;</span>, 131072)               = 0</span><br><span class="line">9856  close(3)                          = 0</span><br><span class="line">9856  close(1 &lt;unfinished ...&gt;</span><br><span class="line">9857  &lt;... <span class="built_in">read</span> resumed&gt; <span class="string">&quot;&quot;</span>, 8192)      = 0</span><br><span class="line">9856  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9857  close(0 &lt;unfinished ...&gt;</span><br><span class="line">9856  close(2 &lt;unfinished ...&gt;</span><br><span class="line">9857  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9856  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9857  close(1)                          = 0</span><br><span class="line">9856  exit_group(0 &lt;unfinished ...&gt;</span><br><span class="line">9857  close(2 &lt;unfinished ...&gt;</span><br><span class="line">9856  &lt;... exit_group resumed&gt;)         = ?</span><br><span class="line">9857  &lt;... close resumed&gt; )             = 0</span><br><span class="line">9857  exit_group(0 &lt;unfinished ...&gt;</span><br><span class="line">9856  +++ exited with 0 +++</span><br><span class="line">9855  &lt;... wait4 resumed&gt; [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0&#125;], 0, NULL) = 9856</span><br><span class="line">9857  &lt;... exit_group resumed&gt;)         = ?</span><br><span class="line">9855  --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=9856, si_uid=1000, si_status=0, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">9855  rt_sigreturn(&#123;mask=[]&#125;)           = 9856</span><br><span class="line">9855  wait4(-1,  &lt;unfinished ...&gt;</span><br><span class="line">9857  +++ exited with 0 +++</span><br><span class="line">9855  &lt;... wait4 resumed&gt; [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0&#125;], 0, NULL) = 9857</span><br><span class="line">9855  --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=9857, si_uid=1000, si_status=0, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">9855  rt_sigreturn(&#123;mask=[]&#125;)           = 9857</span><br><span class="line">9855  exit_group(0)                     = ?</span><br><span class="line">9855  +++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<h5 id="能够顺利输出的strace-log">能够顺利输出的strace log</h5>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">10498 execve(<span class="string">&quot;/bin/sh&quot;</span>, [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;cat 1-redirect | tr \&quot;\\n\&quot; \&quot; \&quot; &gt; 1&quot;</span>...], 0x7ffebaf3b058 /* 61 vars */) = 0</span><br><span class="line">10498 access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">10498 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=103311, ...&#125;) = 0</span><br><span class="line">10498 close(3)                          = 0</span><br><span class="line">10498 access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">10498 <span class="built_in">read</span>(3, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260\34\2\0\0\0\0\0&quot;</span>..., 832) = 832</span><br><span class="line">10498 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2030544, ...&#125;) = 0</span><br><span class="line">10498 close(3)                          = 0</span><br><span class="line">10498 arch_prctl(ARCH_SET_FS, 0x7f27de8b8540) = 0</span><br><span class="line">10498 getuid()                          = 1000</span><br><span class="line">10498 getgid()                          = 1000</span><br><span class="line">10498 getpid()                          = 10498</span><br><span class="line">10498 rt_sigaction(SIGCHLD, &#123;sa_handler=0x561b04ce9200, sa_mask=~[RTMIN RT_1], sa_flags=SA_RESTORER, sa_restorer=0x7f27de2f9fd0&#125;, NULL, 8) = 0</span><br><span class="line">10498 geteuid()                         = 1000</span><br><span class="line">10498 getppid()                         = 10496</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/home/wym0120/have-a-try&quot;</span>, &#123;st_mode=S_IFDIR|0755, st_size=4096, ...&#125;) = 0</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;.&quot;</span>, &#123;st_mode=S_IFDIR|0755, st_size=4096, ...&#125;) = 0</span><br><span class="line">10498 geteuid()                         = 1000</span><br><span class="line">10498 getegid()                         = 1000</span><br><span class="line">10498 rt_sigaction(SIGINT, NULL, &#123;sa_handler=SIG_DFL, sa_mask=[], sa_flags=0&#125;, 8) = 0</span><br><span class="line">10498 rt_sigaction(SIGINT, &#123;sa_handler=0x561b04ce9200, sa_mask=~[RTMIN RT_1], sa_flags=SA_RESTORER, sa_restorer=0x7f27de2f9fd0&#125;, NULL, 8) = 0</span><br><span class="line">10498 rt_sigaction(SIGQUIT, NULL, &#123;sa_handler=SIG_DFL, sa_mask=[], sa_flags=0&#125;, 8) = 0</span><br><span class="line">10498 rt_sigaction(SIGQUIT, &#123;sa_handler=SIG_DFL, sa_mask=~[RTMIN RT_1], sa_flags=SA_RESTORER, sa_restorer=0x7f27de2f9fd0&#125;, NULL, 8) = 0</span><br><span class="line">10498 rt_sigaction(SIGTERM, NULL, &#123;sa_handler=SIG_DFL, sa_mask=[], sa_flags=0&#125;, 8) = 0</span><br><span class="line">10498 rt_sigaction(SIGTERM, &#123;sa_handler=SIG_DFL, sa_mask=~[RTMIN RT_1], sa_flags=SA_RESTORER, sa_restorer=0x7f27de2f9fd0&#125;, NULL, 8) = 0</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/home/wym0120/.autojump/bin/cat&quot;</span>, 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/usr/local/sbin/cat&quot;</span>, 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/usr/local/bin/cat&quot;</span>, 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/usr/sbin/cat&quot;</span>, 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/usr/bin/cat&quot;</span>, 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/sbin/cat&quot;</span>, 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/bin/cat&quot;</span>, &#123;st_mode=S_IFREG|0755, st_size=35064, ...&#125;) = 0</span><br><span class="line">10498 pipe([3, 4])                      = 0</span><br><span class="line">10498 <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f27de8b8810) = 10499</span><br><span class="line">10498 close(4)                          = 0</span><br><span class="line">10499 close(3 &lt;unfinished ...&gt;</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/home/wym0120/.autojump/bin/tr&quot;</span>,  &lt;unfinished ...&gt;</span><br><span class="line">10499 &lt;... close resumed&gt; )             = 0</span><br><span class="line">10498 &lt;... <span class="built_in">stat</span> resumed&gt; 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10499 dup2(4, 1 &lt;unfinished ...&gt;</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/usr/local/sbin/tr&quot;</span>,  &lt;unfinished ...&gt;</span><br><span class="line">10499 &lt;... dup2 resumed&gt; )              = 1</span><br><span class="line">10498 &lt;... <span class="built_in">stat</span> resumed&gt; 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10499 close(4 &lt;unfinished ...&gt;</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/usr/local/bin/tr&quot;</span>,  &lt;unfinished ...&gt;</span><br><span class="line">10499 &lt;... close resumed&gt; )             = 0</span><br><span class="line">10499 execve(<span class="string">&quot;/bin/cat&quot;</span>, [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;1-redirect&quot;</span>], 0x561b05f9afe8 /* 61 vars */ &lt;unfinished ...&gt;</span><br><span class="line">10498 &lt;... <span class="built_in">stat</span> resumed&gt; 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/usr/sbin/tr&quot;</span>,  &lt;unfinished ...&gt;</span><br><span class="line">10499 &lt;... execve resumed&gt; )            = 0</span><br><span class="line">10498 &lt;... <span class="built_in">stat</span> resumed&gt; 0x7ffd8439c6d0) = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 <span class="built_in">stat</span>(<span class="string">&quot;/usr/bin/tr&quot;</span>, &#123;st_mode=S_IFREG|0755, st_size=47288, ...&#125;) = 0</span><br><span class="line">10499 access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK &lt;unfinished ...&gt;</span><br><span class="line">10498 <span class="built_in">clone</span>( &lt;unfinished ...&gt;</span><br><span class="line">10499 &lt;... access resumed&gt; )            = -1 ENOENT (No such file or directory)</span><br><span class="line">10499 access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK &lt;unfinished ...&gt;</span><br><span class="line">10498 &lt;... <span class="built_in">clone</span> resumed&gt; child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f27de8b8810) = 10500</span><br><span class="line">10499 &lt;... access resumed&gt; )            = -1 ENOENT (No such file or directory)</span><br><span class="line">10498 close(3 &lt;unfinished ...&gt;</span><br><span class="line">10499 openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC &lt;unfinished ...&gt;</span><br><span class="line">10498 &lt;... close resumed&gt; )             = 0</span><br><span class="line">10499 &lt;... openat resumed&gt; )            = 3</span><br><span class="line">10498 close(-1 &lt;unfinished ...&gt;</span><br><span class="line">10499 fstat(3,  &lt;unfinished ...&gt;</span><br><span class="line">10498 &lt;... close resumed&gt; )             = -1 EBADF (Bad file descriptor)</span><br><span class="line">10499 &lt;... fstat resumed&gt; &#123;st_mode=S_IFREG|0644, st_size=103311, ...&#125;) = 0</span><br><span class="line">10498 wait4(-1,  &lt;unfinished ...&gt;</span><br><span class="line">10499 close(3)                          = 0</span><br><span class="line">10499 access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">10499 openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">10499 <span class="built_in">read</span>(3, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260\34\2\0\0\0\0\0&quot;</span>..., 832) = 832</span><br><span class="line">10499 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2030544, ...&#125;) = 0</span><br><span class="line">10499 close(3)                          = 0</span><br><span class="line">10499 arch_prctl(ARCH_SET_FS, 0x7fd66ec12540) = 0</span><br><span class="line">10499 openat(AT_FDCWD, <span class="string">&quot;/usr/lib/locale/locale-archive&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">10499 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=3004224, ...&#125;) = 0</span><br><span class="line">10499 close(3)                          = 0</span><br><span class="line">10499 fstat(1, &#123;st_mode=S_IFIFO|0600, st_size=0, ...&#125;) = 0</span><br><span class="line">10499 openat(AT_FDCWD, <span class="string">&quot;1-redirect&quot;</span>, O_RDONLY) = 3</span><br><span class="line">10499 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=11, ...&#125;) = 0</span><br><span class="line">10499 fadvise64(3, 0, 0, POSIX_FADV_SEQUENTIAL) = 0</span><br><span class="line">10499 <span class="built_in">read</span>(3, <span class="string">&quot;havenantry\n&quot;</span>, 131072)   = 11</span><br><span class="line">10499 write(1, <span class="string">&quot;havenantry\n&quot;</span>, 11)      = 11</span><br><span class="line">10499 <span class="built_in">read</span>(3, <span class="string">&quot;&quot;</span>, 131072)               = 0</span><br><span class="line">10499 close(3)                          = 0</span><br><span class="line">10499 close(1)                          = 0</span><br><span class="line">10499 close(2)                          = 0</span><br><span class="line">10499 exit_group(0)                     = ?</span><br><span class="line">10499 +++ exited with 0 +++</span><br><span class="line">10498 &lt;... wait4 resumed&gt; [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0&#125;], 0, NULL) = 10499</span><br><span class="line">10498 --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=10499, si_uid=1000, si_status=0, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">10498 rt_sigreturn(&#123;mask=[]&#125;)           = 10499</span><br><span class="line">10498 wait4(-1,  &lt;unfinished ...&gt;</span><br><span class="line">10500 dup2(3, 0)                        = 0</span><br><span class="line">10500 close(3)                          = 0</span><br><span class="line">10500 openat(AT_FDCWD, <span class="string">&quot;1-redirect&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3</span><br><span class="line">10500 fcntl(1, F_DUPFD, 10)             = 10</span><br><span class="line">10500 close(1)                          = 0</span><br><span class="line">10500 fcntl(10, F_SETFD, FD_CLOEXEC)    = 0</span><br><span class="line">10500 dup2(3, 1)                        = 1</span><br><span class="line">10500 close(3)                          = 0</span><br><span class="line">10500 execve(<span class="string">&quot;/usr/bin/tr&quot;</span>, [<span class="string">&quot;tr&quot;</span>, <span class="string">&quot;\\n&quot;</span>, <span class="string">&quot; &quot;</span>], 0x561b05f9b268 /* 61 vars */) = 0</span><br><span class="line">10500 access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">10500 access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">10500 openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">10500 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=103311, ...&#125;) = 0</span><br><span class="line">10500 close(3)                          = 0</span><br><span class="line">10500 access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK) = -1 ENOENT (No such file or directory)</span><br><span class="line">10500 openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">10500 <span class="built_in">read</span>(3, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260\34\2\0\0\0\0\0&quot;</span>..., 832) = 832</span><br><span class="line">10500 fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2030544, ...&#125;) = 0</span><br><span class="line">10500 close(3)                          = 0</span><br><span class="line">10500 arch_prctl(ARCH_SET_FS, 0x7f112f724540) = 0</span><br><span class="line">10500 openat(AT_FDCWD, <span class="string">&quot;/usr/lib/locale/locale-archive&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">10500 fstat(3, &#123;st_mode=S_IFREG|0644, st_size=3004224, ...&#125;) = 0</span><br><span class="line">10500 close(3)                          = 0</span><br><span class="line">10500 fadvise64(0, 0, 0, POSIX_FADV_SEQUENTIAL) = -1 ESPIPE (Illegal seek)</span><br><span class="line">10500 <span class="built_in">read</span>(0, <span class="string">&quot;havenantry\n&quot;</span>, 8192)     = 11</span><br><span class="line">10500 fstat(1, &#123;st_mode=S_IFREG|0644, st_size=0, ...&#125;) = 0</span><br><span class="line">10500 <span class="built_in">read</span>(0, <span class="string">&quot;&quot;</span>, 8192)                 = 0</span><br><span class="line">10500 close(0)                          = 0</span><br><span class="line">10500 write(1, <span class="string">&quot;havenantry &quot;</span>, 11)       = 11</span><br><span class="line">10500 close(1)                          = 0</span><br><span class="line">10500 close(2)                          = 0</span><br><span class="line">10500 exit_group(0)                     = ?</span><br><span class="line">10500 +++ exited with 0 +++</span><br><span class="line">10498 &lt;... wait4 resumed&gt; [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0&#125;], 0, NULL) = 10500</span><br><span class="line">10498 --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=10500, si_uid=1000, si_status=0, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">10498 rt_sigreturn(&#123;mask=[]&#125;)           = 10500</span><br><span class="line">10498 exit_group(0)                     = ?</span><br><span class="line">10498 +++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<h3 id="问题的本质">问题的本质</h3>
<ol type="1">
<li>为什么数据会被清空？ <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openat(AT_FDCWD, <span class="string">&quot;1-redirect&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3</span><br></pre></td></tr></table></figure></li>
</ol>
<p>man 2 open中提到 &gt; If O_TRUNC is specified and the file exists, the file is truncated to zero length.</p>
<p>tr进程中试图重定向输出到一个已经打开的文件$1中，因此$1的文件就会被清空。</p>
<ol start="2" type="1">
<li>为什么会出现有时能够成功输出的情况 这是一个进程间数据竞争的问题，如果cat在tr进程把文件清空之前读出来了数据 那么数据就会被写入cat的标准输出，然后通过pipeline被tr进程读取 完成了这一步之后tr进程因为重定向会将文件清空，但是能够从标准输入中读取到原来的数据 然后执行tr，最后使用了一个write进行写入</li>
</ol>
<h3 id="另一个有趣的现象">另一个有趣的现象</h3>
<p>如果把&gt;修改为&gt;&gt;，例如cat tmp&gt;&gt;tmp 在Linux中会无法执行，提示input file is output file，而在macos zsh下则会无限循环 猜测：cat的标准输出和标准输入被重定向到了同一个文件，因此cat检查文件是否结束时会检查到刚被写入文件的一行，就始终无法结束</p>
]]></content>
      <categories>
        <category>os</category>
        <category>os lecture</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>transwarp-QA</title>
    <url>/2020/12/08/transwarp/</url>
    <content><![CDATA[<h3 id="练习题库一">练习题库(一)</h3>
<ol type="1">
<li><p>在 HDFS 服务中，为了保证 Name Node 高可用性的角色不包括 A. Data Node☑️ B. Journal Node C. ZKFC D. Zookeeper</p></li>
<li><p>Namenode 在启动时自动进入安全模式，在安全模式阶段，说法错误的是 A. 安全模式目的是在系统启动时对数据有效性进行检查 B. 根据策略对数据块进行必要的复制或删除 C. 当数据块的上报数达到阈值时，会自动退出安全模式 D. 允许用户对文件系统进行读写操作☑️</p></li>
<li><p>在集群中配置 HDFS 的副本数为 3，设置数据块大小为 128M，此时我们上传一份 64M 的数据文件，该数据文件占用 HDFS 空间大小为 A. 64M B. 128M C. 384M☑️ D. 192M</p></li>
<li><p>下列对 YARN 角色在集群中的作用描述正确的是 A. 集群资源管理☑️ B. 集群任务调度与管理☑️ C. 存储部分 HDFS 上的数据块 D. 以上都正确</p></li>
<li><p>在 Yarn 服务中，不包含以下哪种角色 A. ResourceManager B. NodeManager C. ApplicationMaster D. Contianer☑️</p></li>
<li><p>下列计算框架中不属于分布式计算框架的是 A. MapReduce B. MATLAB☑️ C. SPARK D. Tez</p></li>
<li><p>以下关于外表和托管表描述正确的是 A. 外表的数据存储在本地，托管表的数据存储在 hdfs 上 B. 删除托管表只会删除 Inceptor 上的元数据不会删除数据文件，删除外表两者都会 被删除 C. 删除外表只会删除 Inceptor 上的元数据不会删除数据文件，删除托管表两者都会 被删除☑️ D. 删除托管表或外表，incepotr 上的元数据和数据文件都会被删除</p></li>
<li><p>以下对分桶表的描述正确的是 A. 分桶表通过改变数据的存储分布，对查询起到一定的优化作用☑️ B. 分桶键不能是表中的列 C. 分桶数应为素数 D. 事物表必须制定分桶，分桶字段可以被更新</p></li>
<li><p>以下关于 inceptor excutor 资源配置的说法正确的有 A. Excutor 资源配置 fixed 和 ratio 两种模式☑️ B. Excutor 内核数配置的是每个 excutor 所使用的逻辑 core 数量☑️ C. Excutor 内核数和内存配置比例一般为 1 core:2G memory☑️ D. Excutor 分布可以指定每个节点运行的 excutor 数量或 executor 在集群上运行的 总数量，但是不能指定运行的节点</p></li>
<li><p>假设使用场景中有如下查询语句 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sex, Region, <span class="keyword">COUNT</span>(<span class="keyword">ID</span>), <span class="keyword">AVG</span> (Salary)</span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Department = <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sex, Region</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sex, Region;</span><br></pre></td></tr></table></figure> 通过 holodesk 的 cube 和 index 手段对这种过滤率和聚合率高的业务进行优化，以下建表 正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A.☑️ <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span></span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Department&#x27;</span> )</span><br><span class="line"></span><br><span class="line">C. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;&#x27;</span>Department<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex&#x27;</span> )</span><br></pre></td></tr></table></figure></p></li>
<li><p>关于 Hyperbase 全局索引的描述，哪些是正确的？ A. 核心是倒排表☑️ B. 全局索引概念是对应 Rowkey 这个“一级”索引☑️ C. 全局索引使用平衡二叉树 D. 全局索引使用 B+树检索数据☑️</p></li>
<li><p>以下为 Hyperbase 分布式存储的最小单元的是 A. Region server B. Region☑️ C. StoreFile D. Store</p></li>
<li><p>以下有关 Hyperbase 说法正确的是 A. 数据类型丰富，支持 String. Int. Char 等类型 B. Key/value 系统，key 由 Row,Column Family,Column Qualifier 组成 C. Hyperbase 表中 rowkey 有序，按字典序降序排列 D. 以上说法都不正确☑️</p></li>
<li><p>以下关于 StreamSQL 的概念描述正确的是 A. Stream 是数据流☑️ B. Streamjob 是对一个或多个 stream 进行计算并将结果写进一个流的任务 C. Application 是一个或多个 streamjob 的集合☑️ D. 以上说法都不正确</p></li>
<li><p>某交通部门通过使用流监控全市过往 24 小时各个卡口数据，要求每分钟更新一次， 原始流为 org_stream，以下实现正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. <span class="keyword">CREATE</span> STREAMWINDOW traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAM w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line">B. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line">C.☑️ <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br><span class="line">D. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span></span><br><span class="line"><span class="keyword">second</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>以下不是 Zookeeper 的功能是 A. 配置管理 B. 集群管理 C. 分布式锁 D. 存储大量数据☑️</p></li>
<li><p>以下服务需要与 zookeeper 进行通信的是 A. HMaster B. Active NameNode C. InceptorSQL D. Active ResourceManager☑️</p></li>
<li><p>下列是关于 flume 和 sqoop 对比的描述，不正确的是 A. flume 主要用来采集日志而 sqoop 主要用来做数据迁移 B. flume 主要采集流式数据而 sqoop 主要用来迁移规范化数据☑️ C. flume 和 sqoop 都是分布式处理任务☑️ D. flume 主要用于采集多数据源小数据而 sqoop 用来迁移单数据源数据</p></li>
<li><p>有关使用 sqoop 抽取数据的原理的描述不正确的是 A. sqoop 在抽取数据的时候可以指定 map 的个数，map 的个数决定在 hdfs 生成的 数据文件的个数 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能越好☑️ C. sqoop 任务的切分是根据 split 字段的（最大值-最小值）/map 数 D. sqoop 抽取数据的时候需要保证执行当前用户有权限执行相应的操作</p></li>
<li><p>sqoop 抽取数据时需要做一些数据转换的工作，下面说法不正确的是 A. --fields-terminated-by '\01' 用来设置在 hdfs 生成的文件的分割符 B. --hive-drop-import-delims 用来设置在 hdfs 生成的文件的存储形式为列存储☑️ C. --null-string '\N' 用来把所有的 String 类型的空值 转换成 hive 的 NULL 值 D. --null-non-string '\N' 用来把非 String 类型的空值 转换成 hive 的 NULL 值</p></li>
<li><p>下列有关 flume 的描述不正确的是 A. flume 是 Apache 的一个子项目 B. flume 主要是一个日志采集，传输系统 C. flume 和 sqoop 功能相似，因此可以相互替代☑️ D. flume 可以同时采集集群内部和集群外部的日志数据</p></li>
<li><p>下列 sink 中哪些是 flume 不支持的 sink A. HDFS sink B. kafka sink C. memory sink☑️ D. file roll sink</p></li>
<li><p>以下对 ElasticSearch 描述不正确的是 A. ElasticSearch 是分布式全文搜索引擎 B. ElasticSearch 集群中分 master 和 data 节点 C. ElasticSearch 数据存储在 HDFS 上☑️ D. ElasticSearch 数据可以按 Shard 分布在不同的节点上</p></li>
<li><p>下列不属于 kafka 应用场景的是 A. 常规的消息收集 B. 网站活动性跟踪 C. 日志收集 D. 关系型数据库和大数据平台之间的数据迁移☑️</p></li>
<li><p>TDH 提供哪几种认证模式？ A. 所有服务使用简单认证模式——所有服务都无需认证即可互相访问☑️ B. 所有服务都启用 Kerberos 认证，用户要提供 Kerberos principal 和密码（或者keytab）来访问各个服务☑️ C. 所有服务都启用 Kerberos 同时 Inceptor 启用 LDAP 认证☑️ D. 所有服务都启用 LDAP 认证</p></li>
<li><p>以下对各组件的运维页面描述不正确的是 A. 通过 Name Node 的 50070 页面对 HDFS 进行监控 B. 通过 Resource Manager 的 8180 对 YARN 上运行的任务进行监控☑️ C. 通过 HMaster 的 60010 对 HBase 进行监控☑ D. 通过 Hue Server 的 8888 页面登入 Hue</p></li>
<li><p>Inceptor server 服务无法启动时，该如何查看日志是 A. 查看 TDH manager 所在节点/var/log/inceptorsql<em>/目录下的 hive-server2.log 日志 B. 查看 Inceptor server 所在节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志☑️ C. 查 看 Resource Manager 所 在 节 点 /var/log/Yarn<em>/ 目 录 下 的 yarn-yarn-resourcemanager-poc-node1.log 日志 D. 查看任意节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志</p></li>
<li><p>以下对 Hadoop 组件的应用场景描述正确的是 A. Hive 主要用于构建大数据数仓，主要做批处理. 统计分析型业务☑️ B. Hbase 主要用于检索查询的 OLTP 业务☑️ C. ElasticSearch 主要用于全文检索的关键字查询业务☑️ D. Spark Streaming 主要用于实时数据的业务场景☑️</p></li>
<li><p>以下不属于管理角色的是 A. Name Node B. HMaster C. Resource Manager D. Node Manager☑️</p></li>
<li><p>下面哪些工作不属于集群预安装工作 A. 为集群中每个节点的安装操作系统 B. 选一个节点作为管理节点，修改其 /etc/hosts 文件 C. 安装 Transwarp Manager 管理界面 D. 配置集群安全模式☑️</p></li>
</ol>
<h3 id="练习题库二">练习题库(二)</h3>
<ol type="1">
<li><p>下列与 HDFS 有关的说法正确的是 A. HDFS DataNode 节点上的磁盘需要做 RAID1，用来保证数据的可靠性 B. HDFS 可以在磁盘之间通过 balance 操作，平衡磁盘之间的负载情况 C. HDFS 建议 DataNode 之间的数据盘个数. 容量大小不一致，以体现 HDFS 的负均 衡能力 D. 规划 HDFS 集群时，建议 Active NameNode 和 Standby NameNode 分配在不同机 架上☑️</p></li>
<li><p>在 HDFS 服务中，为了保证 Name Node 高可用性的角色不包括 A. Data Node☑️ B. Journal Node C. ZKFC D. Zookeeper</p></li>
<li><p>在集群中配置 HDFS 的副本数为 3，设置数据块大小为 128M，此时我们上传一份 64M 的数据文件，该数据文件占用 HDFS 空间大小为 A. 64M B. 128M C. 384M☑️ D. 192M</p></li>
<li><p>在 Yarn 服务中，不包含以下哪种角色 A. ResourceManager B. NodeManager C. ApplicationMaster☑️ D. Contianer</p></li>
<li><p>下列有关 YRAN 中角色的描述不正确的是 A. ResourceManager 控制整个集群并管理基础计算资源的分配 B. NodeManager 管理每个节点的资源，管理抽象容器 C. NodeManager 负责调度当前节点的所有 ApplicationMaster☑️ D. ApplicationMaster 管理一个 YARN 内运行的应用程序的实例</p></li>
<li><p>Spark 与 MapReduce 对比，突出的优势不包括 A. 基于内存的计算，效率更高 B. Spark 能支持比 MapReduce 更多的应用场景 C. Spark 支持多种编程语言接口，框架开销更低 D. Spark 可以运行在 YARN 之上而 MapReduce 不能☑️</p></li>
<li><p>以下关于外表和托管表描述正确的是 A. 外表的数据存储在本地，托管表的数据存储在 hdfs 上 B. 删除托管表只会删除 Inceptor 上的元数据不会删除数据文件，删除外表两者都会 被删除 C. 删除外表只会删除 Inceptor 上的元数据不会删除数据文件，删除托管表两者都会 被删除☑️ D. 删除托管表或外表，incepotr 上的元数据和数据文件都会被删除</p></li>
<li><p>导入数据经常会用到 LOAD 命令，以下关于 LOAD 的描述错误的是 A. 源数据文件存放于 hdfs 上，通过 load 命令加载数据文件，数据文件将被复制到 表目录下☑️ B. 目标表为分桶表时不能通过 load 命令加载数据 C. 目标表为分区表时不能通过 load 命令加载数据 D. 当元数据存放于本地时，需要通过指定 LOCAL 关键字</p></li>
<li><p>tableA 有 10G 的数据，tableB 有 100G 的数据，两个表通过共有的 id 列做关联查询 name 列，以下方式可以优化计算效率的是 A. select /<em>+MAPJOIN(a)</em>/ a.name,b.name from tableA a join tableB b on a.id=b.id B. select /<em>+MAPJOIN(b)</em>/ a.name,b.name from tableA a join tableB b on a.id=b.id C. 建表时将 tableA 和 tableB 根据 id 字段分相同数量的桶☑️ D. 建表时将 tableA 和 tableB 根据 name 字段分相同数量的桶</p></li>
<li><p>假设使用场景中有如下查询语句 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sex, Region, <span class="keyword">COUNT</span>(<span class="keyword">ID</span>), <span class="keyword">AVG</span> (Salary)</span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Department = <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sex, Region</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sex, Region;</span><br></pre></td></tr></table></figure> 通过 holodesk 的 cube 和 index 手段对这种过滤率和聚合率高的业务进行优化，以下建表 正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. ☑️<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span></span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Department&#x27;</span> )</span><br><span class="line"></span><br><span class="line">C. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;&#x27;</span>Department<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex&#x27;</span> )</span><br></pre></td></tr></table></figure></p></li>
<li><p>关于 Hyperbase 全局索引的描述，哪些是正确的？ A. 核心是倒排表☑️ B. 全局索引概念是对应 Rowkey 这个“一级”索引☑️ C. 全局索引使用平衡二叉树 D. 全局索引使用 B+树检索数据☑️</p></li>
<li><p>以下不属于 Hyperbase 存储模型单位的是 A. table B. region☑️ C. StoreFile D. block</p></li>
<li><p>有关 Minor Compact 的描述正确的是 A. 一个 store 下的所有文件合并 B. 删除过期版本数据 C. 删除 delete marker 数据 D. 把多个 HFile 合成一个☑️</p></li>
<li><p>以下的 stream 的描述不正确的是 A. Input 定义了如何从数据源读取数据 B. Derived stream 是对 stream 转换而来的，可分为单 batch 变形和多 batch 变形 C. 定义 Derived stream 后 stream 当即根据转换规则进行变形☑️ D. 窗口变形的长度必须是当前流的整数倍</p></li>
<li><p>某公司有部门 A. 部门 B…，各部门的源数据都取自于企业总线，要求部门内部共享 数据源，部门间做到资源隔离，以下设计合理的有 A. 部门里每个流任务起一个 application 管理 streamjob B. 每个部门起一个 application 管理本部门的 streamjob☑️ C. 公司起一个 application 管理所有的 streamjob D. 每个部门起一个 streamjob 管理本部门的 application</p></li>
<li><p>Zookeeper 服务描述正确的是 A. Zookeeper 可以存储文件，所以它是用于存储大量数据信息的文件系统。 B. 它是集群的管理服务，总控节点间所有通信。 C. 它是分布式应用程序协调服务。☑️ D. 它是保存所有集群服务的元数据库。</p></li>
<li><p>我们可以通过 hue 图形化的操作 HDFS，hue 可以实现 hdfs 的 A. 创建目录☑️ B. 上传文件☑️ C. 直接查看文件☑️ D. 更改权限☑️</p></li>
<li><p>通过 oozie workflow 调度 sqoop 任务，以下说法正确的是 A. 必须使用 sudo 用户 B. 确保对应的 jdbc 驱动正确上传到 hdfs 上☑️ C. Sqoop 导入的 hdfs 目录必须前提不存在☑️ D. 以上说法都对</p></li>
<li><p>有关使用 sqoop 抽取数据的原理的描述不正确的是 A. sqoop 在抽取数据的时候可以指定 map 的个数，map 的个数决定在 hdfs 生成的 数据文件的个数 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能 越好☑️ C. sqoop 任务的切分是根据 split 字段的（最大值-最小值）/map 数 D. sqoop 抽取数据的时候需要保证执行当前用户有权限执行相应的操作</p></li>
<li><p>有关 sqoop 的参数说法不正确的是 A. --username 是必需参数 B. --m 大于 1 时，--split-by 参数是必需参数 C. --query 是执行 sqoop 操作的必需参数☑️ D. --field-terminated-by 用来指定在 hdfs 生成数据文件时的列分隔符</p></li>
<li><p>下列是关于 flume 和 sqoop 对比的描述，不正确的是 A. flume 主要用来采集日志而 sqoop 主要用来做数据迁移 B. flume 主要采集流式数据而 sqoop 主要用来迁移规范化数据 C. flume 和 sqoop 都是分布式处理任务☑️ D. flume 主要用于采集多数据源小数据而 sqoop 用来迁移单数据源数据</p></li>
<li><p>以下不属于 Flume 的 Source 类型的是 A. exec source B. file source☑️ C. spooling directory source D. kafka source</p></li>
<li><p>有关 Elasticsearch 特性描述有误的一项是 A. 分布式实时文件存储，可将每一个字段存入索引 B. 实时分析的分布式搜索引擎。 C. 支持插件机制，分词插件. 同步插件 D. 以上都不正确☑️</p></li>
<li><p>下列不属于 kafka 应用场景的是 A. 常规的消息收集 B. 网站活动性跟踪 C. 日志收集 D. 关系型数据库和大数据平台之间的数据迁移☑️</p></li>
<li><p>TDH 提供哪几种认证模式？ A. 所有服务使用简单认证模式——所有服务都无需认证即可互相访问☑️ B. 所有服务都启用 Kerberos 认证，用户要提供 Kerberos principal 和密码（或者 keytab）来访问各个服务☑️ C. 所有服务都启用 Kerberos 同时 Inceptor 启用 LDAP 认证☑️ D. 所有服务都启用 LDAP 认证</p></li>
<li><p>在安装有 kerberos 服务的集群中如何切换用户 A. 不需要切换，所有用户都为服务公用用户，可以直接使用。 B. 直接使用 kinit 用户名称方式进行切换☑️ C. 必须先 destroy ，才能再使用 kinit 用户名称 方式登录 D. 以上都不正确</p></li>
<li><p>以下对 Transwarp Manager 描述不正确的是 A. Transwarp Manger 是 TDH 的管理运维平台 B. 通过 Transwarp Manager 的 8180 界面登入 C. 在 Transwarp Manager 上能启动和停止 Transwarp Agent 角色☑️ D. 在 Transwarp Manager 上能对 Inceptor 表进行赋权操作</p></li>
<li><p>以下对 Hadoop 组件的应用场景描述正确的是 A. Hive 主要用于构建大数据数仓，主要做批处理. 统计分析型业务☑️ B. Hbase 主要用于检索查询的 OLTP 业务☑️ C. ElasticSearch 主要用于全文检索的关键字查询业务☑️ D. Spark Streaming 主要用于实时数据的业务场景☑️</p></li>
<li><p>某电信部门有 100 亿条用户过往使用通讯记录，现需要提供客户终端根据电话号精 确查询历史通讯，满足用户同时并发访问，则该表应该设计为 A. Hyperbase 表+全局索引☑️ B. Hyperbase 表+es 索引 C. Es 表+es 索引 D. 以上方式都可以</p></li>
<li><p>可以安装 TDH 的操作系统有？ A. SUSE SP2-SP3。☑️ B. Win7/Win10。 C. CentOS 6.3-6.5。☑️ D. REHL 6.3-6.5。☑️</p></li>
</ol>
<h3 id="练习题库三">练习题库(三)</h3>
<ol type="1">
<li><p>下列与 HDFS 有关的说法正确的是 A. HDFS DataNode 节点上的磁盘需要做 RAID1，用来保证数据的可靠性 B. HDFS 可以在磁盘之间通过 balance 操作，平衡磁盘之间的负载情况 C. HDFS 建议 DataNode 之间的数据盘个数. 容量大小不一致，以体现 HDFS 的负载 均衡能力 D. 规划 HDFS 集群时，建议 Active NameNode 和 Standby NameNode 分配在不同的 机架上☑️</p></li>
<li><p>NameNode 用于存储 HDFS 上数据块的元数据信息，它保存的数据形式是 A. block B. fsimage☑️ C. editlog☑️ D. blockid</p></li>
<li><p>在集群中配置 HDFS 的副本数为 3，设置数据块大小为 128M，此时我们上传一份 64M 的数据文件，该数据文件占用 HDFS 空间大小为 A. 64M B. 128M C. 384M☑️ D. 192M</p></li>
<li><p>下列对 YARN 角色在集群中的作用描述正确的是 A. 集群资源管理☑️ B. 集群任务调度与管理☑️ C. 存储部分 HDFS 上的数据块 D. 以上都正确</p></li>
<li><p>YARN 框架中，负责集群资源管理的组件是 A. ResourceManager☑️ B. NodeManager C. Container D. JobTracker</p></li>
<li><p>MapReduce 计算框架的特点包括 A. 自动化并行和分布式计算 B. 出错容忍度高 C. 优先数据本地化计算 D. 以上都是☑️</p></li>
<li><p>以下关于外表和托管表描述正确的是 A. 外表的数据存储在本地，托管表的数据存储在 hdfs 上 B. 删除托管表只会删除 Inceptor 上的元数据不会删除数据文件，删除外表两者都会 被删除 C. 删除外表只会删除 Inceptor 上的元数据不会删除数据文件，删除托管表两者都会 被删除☑️ D. 删除托管表或外表，incepotr 上的元数据和数据文件都会被删除</p></li>
<li><p>以下关于 Inceptor 数据倾斜场景正确的处理方式有 A. 对于数据倾斜的 SQL 重新跑一次即可解决 B. 剔除引起数据倾斜的数据，再重新执行 SQL C. 导入数据期间格式转换出现错误引起 null 过多，可以通过重新清理数据解决☑️ D. 将一起数据倾斜的数据和剩下的数据单独运行，再通过 union 合并的方式解决☑️</p></li>
<li><p>以下关于 inceptor 日志信息描述正确的有 A. Inceptor server 日志存放于各节点的/var/log/inceptorsql[x]/hive-server.log☑️ B. 可以通过 inceptor server 4040 查看 SQL 错误日志☑️ C. Excutor 日志存放于 excutor 节点的/var/log/inceptorsql[x]/spark-excutor.log☑️ D. ExcutorGC 日志存放于 excutor 节点的/var/log/inceptorsql[x]/spark-excutor.gc.log☑️</p></li>
<li><p>假设使用场景中有如下查询语句 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sex, Region, <span class="keyword">COUNT</span>(<span class="keyword">ID</span>), <span class="keyword">AVG</span> (Salary)</span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Department = <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sex, Region</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sex, Region;</span><br></pre></td></tr></table></figure> 通过 holodesk 的 cube 和 index 手段对这种过滤率和聚合率高的业务进行优化，以下建表 正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. ☑️<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span></span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Department&#x27;</span> )</span><br><span class="line"></span><br><span class="line">C. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex&#x27;</span> )</span><br></pre></td></tr></table></figure></p></li>
<li><p>以下属于 HMaster 功能的是 A. 为 Region Server 分配 region☑️ B. 存储数据元信息 C. 对 region 进行 compact 操作 D. 管理用户对 table 的增删改查操作☑️</p></li>
<li><p>有关 Minor Compact 的描述正确的是 A. 一个 store 下的所有文件合并 B. 删除过期版本数据 C. 删除 delete marker 数据 D. 把多个 HFile 合成一个☑️</p></li>
<li><p>下列创建全局索引的语句，正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. add_index &#x27;t1&#x27;, &#x27;index_name&#x27;,&#x27;COMBINE_INDEX|INDEXED=f1:q1:9|rowKey:rowKey:10,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">B. add_global_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;☑️</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">C. add_fulltext_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">D. create_global_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>以下对流处理计算框架描述不正确的是 A. Spark Streaming 是基于微批（batch）对数据进行处理的 B. Apache Storm 是基于时间（event）对数据进行处理的 C. Transwarp StreamSQL 可基于微批或事件对数据进行处理 D. 以上说法都不对☑️</p></li>
<li><p>某交通部门通过使用流监控全市过往 24 小时各个卡口数据，要求每分钟更新一次， 原始流为 org_stream，以下实现正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. <span class="keyword">CREATE</span> STREAMWINDOW traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAM w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line"></span><br><span class="line">C. ☑️<span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span></span><br><span class="line"><span class="keyword">second</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>以下不是 Zookeeper 的功能是 A. 配置管理 B. 集群管理 C. 分布式锁 D. 存储大量数据☑️</p></li>
<li><p>关于 Hue 对 hive server 的支持度描述正确的是 A. 只支持 hive server1 B. 只支持 hive server2☑️ C. 同时支持 hive server1 和 hive server2 D. 只支持开启 LDAP 的 hive server2</p></li>
<li><p>以下关于 oozie 三个编辑器说法正确的是 A. bundle 构建在 workflow 工作方式之上，提供定时运行和触发运行任务的功能。 B. bundle 将多个 workflow 管理起来，这样我们只需提供一个 bundle 提交即可 C. workflow 是最简单的一种工作方式☑️ D. coordinator 可以包含一到多个 workflow☑️</p></li>
<li><p>有关使用 sqoop 抽取数据的原理的描述不正确的是 A. sqoop 在抽取数据的时候可以指定 map 的个数，map 的个数决定在 hdfs 生成的 数据文件的个数 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能 越好☑️ C. sqoop 任务的切分是根据 split 字段的（最大值-最小值）/map 数 D. sqoop 抽取数据的时候需要保证执行当前用户有权限执行相应的操作</p></li>
<li><p>下面与 sqoop 做数据迁移有关的描述不正确的是 A. sqoop 做数据迁移的主要瓶颈在网络带宽和 RDB 的 IO 限制 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能越 好☑️ C. sqoop 抽取数据分为全量抽取和增量抽取两种 D. 当-m 大于 1 时，就必须要设置--split-by 字段</p></li>
<li><p>下列有关 flume 的描述不正确的是 A. flume 是 Apache 的一个子项目 B. flume 主要是一个日志采集，传输系统 C. flume 和 sqoop 功能相似，因此可以相互替代☑️ D. flume 可以同时采集集群内部和集群外部的日志数据</p></li>
<li><p>下列是关于 flume 和 sqoop 对比的描述，不正确的是 A. flume 主要用来采集日志而 sqoop 主要用来做数据迁移 B. flume 主要采集流式数据而 sqoop 主要用来迁移规范化数据 C. flume 和 sqoop 都是分布式处理任务☑️ D. flume 主要用于采集多数据源小数据而 sqoop 用来迁移单数据源数据</p></li>
<li><p>以下对 ElasticSearch 描述不正确的是 A. ElasticSearch 是分布式全文搜索引擎 B. ElasticSearch 集群中分 master 和 data 节点 C. ElasticSearch 数据存储在 HDFS 上☑️ D. ElasticSearch 数据可以按 Shard 分布在不同的节点上</p></li>
<li><p>下列不属于 kafka 应用场景的是 A. 常规的消息收集 B. 网站活动性跟踪 C. 日志收集 D. 关系型数据库和大数据平台之间的数据迁移☑️</p></li>
<li><p>TDH 提供哪几种认证模式？ A. 所有服务使用简单认证模式——所有服务都无需认证即可互相访问☑️ B. 所有服务都启用 Kerberos 认证，用户要提供 Kerberos principal 和密码（或者 keytab）来访问各个服务☑️ C. 所有服务都启用 Kerberos 同时 Inceptor 启用 LDAP 认证☑️ D. 所有服务都启用 LDAP 认证</p></li>
<li><p>以下属于 Guardian 的功能是 A. 用户管理☑️ B. 用户认证☑️ C. 审计☑️ D. 权限管理☑️</p></li>
<li><p>Inceptor server 服务无法启动时，该如何查看日志是 A. 查看 TDH manager 所在节点/var/log/inceptorsql<em>/目录下的 hive-server2.log 日志 B. 查看 Inceptor server 所在节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志☑️ C. 查 看 Resource Manager 所 在 节 点 /var/log/Yarn<em>/ 目 录 下 的 yarn-yarn-resourcemanager-poc-node1.log 日志 D. 查看任意节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志</p></li>
<li><p>以下对 Hadoop 组件的应用场景描述正确的是 A. Hive 主要用于构建大数据数仓，主要做批处理. 统计分析型业务☑️ B. Hbase 主要用于检索查询的 OLTP 业务☑️ C. ElasticSearch 主要用于全文检索的关键字查询业务☑️ D. Spark Streaming 主要用于实时数据的业务场景☑️</p></li>
<li><p>现有一个表数据要存储在 hyperbase 上，并创建全文索引，原表数据 10GB，HDFS 配置为 3 副本，hyperbase 压缩比例按 1:3 计算，索引数据量为 20GB，ES 副本数为 1， ES 压缩比按 1:3 计算，则该表需要多大的存储空间存储 A. 16.67GB B. 23.33GB☑️ C. 30GB D. 70GB</p></li>
<li><p>下面哪些工作不属于集群预安装工作 A. 为集群中每个节点的安装操作系统 B. 选一个节点作为管理节点，修改其/etc/hosts 文件 C. 安装 Transwarp Manager 管理界面 D. 配置集群安全模式☑️</p></li>
</ol>
<h3 id="练习题库四">练习题库(四)</h3>
<ol type="1">
<li><p>下列与 HDFS 有关的说法正确的是 A. HDFS DataNode 节点上的磁盘需要做 RAID1，用来保证数据的可靠性 B. HDFS 可以在磁盘之间通过 balance 操作，平衡磁盘之间的负载情况 C. HDFS 建议 DataNode 之间的数据盘个数. 容量大小不一致，以体现 HDFS 的负载 均衡能力 D. 规划 HDFS 集群时，建议 Active NameNode 和 Standby NameNode 分配在不同的 机架上☑️</p></li>
<li><p>以下哪个服务作为 HDFS 高可靠协调服务的共享存储？ A. ZooKeeper B. JournalNodes☑️ C. NameNode D. ZKFailoverController</p></li>
<li><p>在集群中配置 HDFS 的副本数为 3，设置数据块大小为 128M，此时我们上传一份 64M 的数据文件，该数据文件占用 HDFS 空间大小为 A. 64M B. 128M C. 384M☑️ D. 192M</p></li>
<li><p>在 Yarn 服务中，不包含以下哪种角色 A. ResourceManager B. NodeManager C. ApplicationMaster D. Contianer☑️</p></li>
<li><p>ResourceManager 是 YARN 的主要组成部分，有关其功能描述不正确的是 A. 它直接将集群所拥有的资源按需分配给运行在 YARN 上的应用程序☑️ B. 它负责将集群中的所有资源进行统一管理和分配 C. 它接受各个节点的资源汇报信息 D. 它把资源按照策略分配给各应用</p></li>
<li><p>当前用户提交了一个 wordcount 词频统计的任务，最后任务执行失败，可能的原因有 哪些 A. 当前集群中没有足够的资源，不足以满足当前 wordcount 任务的需求 B. 执行该任务的用户没有权限访问 HDFS 上的数据文件 C. 用户在执行任务之前在 HDFS 相应的目录下创建了提交任务时指定的输出目录 D. 以上原因都有可能☑️</p></li>
<li><p>以下关于外表和托管表描述正确的是 A. 外表的数据存储在本地，托管表的数据存储在 hdfs 上 B. 删除托管表只会删除 Inceptor 上的元数据不会删除数据文件，删除外表两者都会 被删除 C. 删除外表只会删除 Inceptor 上的元数据不会删除数据文件，删除托管表两者都会 被删除☑️ D. 删除托管表或外表，incepotr 上的元数据和数据文件都会被删除</p></li>
<li><p>SQL 运行中如果出现 maptask 数据特别多，执行时间又很短时可以通过小文件合并来 进行优化，以下是合并参数有 A. SET ngmr.partition.automerge = TRUE;☑️ B. SET ngmr.partition.mergesize = n;☑️ C. SET ngmr.partition.mergesize.mb = m;☑️ D. SET mapred.reduce.tasks = N;</p></li>
<li><p>以下关于 inceptor 日志信息描述正确的有 A. Inceptor server 日志存放于各节点的/var/log/inceptorsql[x]/hive-server.log☑️ B. 可以通过 inceptor server 4040 查看 SQL 错误日志☑️ C. Excutor 日志存放于 excutor 节点的/var/log/inceptorsql[x]/spark-excutor.log☑️ D. ExcutorGC 日志存放于 excutor 节点的/var/log/inceptorsql[x]/spark-excutor.gc.log☑️</p></li>
<li><p>tableA 有 10G 的数据，tableB 有 100G 的数据，两个表通过共有的 id 列做关联查询 name 列，以下方式可以优化计算效率的是 A. select /<em>+MAPJOIN(a)</em>/ a.name,b.name from tableA a join tableB b on a.id=b.id B. select /<em>+MAPJOIN(b)</em>/ a.name,b.name from tableA a join tableB b on a.id=b.id C. 建表时将 tableA 和 tableB 根据 id 字段分相同数量的桶☑️ D. 建表时将 tableA 和 tableB 根据 name 字段分相同数量的桶</p></li>
<li><p>以下属于 HMaster 功能的是 A. 为 Region Server 分配 region☑️ B. 存储数据元信息☑️ C. 对 region 进行 compact 操作 D. 管理用户对 table 的增删改查操作</p></li>
<li><p>Hyperbase 与 Inceptor 的关系，描述正确的是 A. 两者不可或缺，Inceptor 保证 Hyperbase 的服务的正常运行 B. 两者没有任何关系 C. Inceptor 可以访问 Hyperbase☑️ D. 两者相辅相成☑️</p></li>
<li><p>下列创建全局索引的语句，正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. add_index &#x27;t1&#x27;, &#x27;index_name&#x27;,</span><br><span class="line">&#x27;COMBINE_INDEX|INDEXED=f1:q1:9|rowKey:rowKey:10,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">B. ☑️add_global_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">C. add_fulltext_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">D. create_global_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>以下对流处理计算框架描述不正确的是 A. Spark Streaming 是基于微批（batch）对数据进行处理的 B. Apache Storm 是基于时间（event）对数据进行处理的 C. Transwarp StreamSQL 可基于微批或事件对数据进行处理 D. 以上说法都不对☑️</p></li>
<li><p>某交通部门通过使用流监控全市过往 24 小时各个卡口数据，要求每分钟更新一次， 原始流为 org_stream，以下实现正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. <span class="keyword">CREATE</span> STREAMWINDOW traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAM w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line"></span><br><span class="line">C. ☑️<span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span></span><br><span class="line"><span class="keyword">second</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br></pre></td></tr></table></figure></p></li>
<li><p>Zookeeper 服务描述正确的为 A. Zookeeper 中每一个 server 互为 leader。 B. Zookeeper 中只有一个 leader，并通过备份机制产生。 C. Zookeeper 中不存在 leader,所有 server 共同提供服务。 D. Zookeeper 通过选举机制确定 leader，有且仅有一个。☑️</p></li>
<li><p>通过 Hue 修改 HDFS 目录或文件的权限可以通过以下哪些方式实现 A. Hdfs 相应的权限☑️ B. 通过 Hue 超级用户 hue 登录 C. 以 hdfs 用户登录☑️ D. 以上都可以</p></li>
<li><p>通过 Oozie 使用 ssh，必须满足以下条件 A. 以 root 用户登录各个节点 B. Oozie 用户可以免密钥登录☑️ C. Oozie 用户必须要有 bash 权限☑️ D. 所访问必须是集群的节点</p></li>
<li><p>有关使用 sqoop 抽取数据的原理的描述不正确的是 A. sqoop 在抽取数据的时候可以指定 map 的个数，map 的个数决定在 hdfs 生成的 数据文件的个数 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能 越好☑️ C. sqoop 任务的切分是根据 split 字段的（最大值-最小值）/map 数 D. sqoop 抽取数据的时候需要保证执行当前用户有权限执行相应的操作</p></li>
<li><p>在使用 sqoop 连接关系型数据时，下面哪个命令可以查看关系型数据库中有哪些表？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. sqoop list-databases</span><br><span class="line">--username root</span><br><span class="line">--password 111111</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;192.168.164.25:3306&#x2F;</span><br><span class="line"></span><br><span class="line">B. sqoop list-databases</span><br><span class="line">--username root</span><br><span class="line">-P</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;192.168.164.25:3306&#x2F;</span><br><span class="line"></span><br><span class="line">C. sqoop list-databases</span><br><span class="line">--username root</span><br><span class="line">--password-file file:&#x2F;root&#x2F;.pwd</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;192.168.164.25:3306&#x2F;</span><br><span class="line"></span><br><span class="line">D. ☑️sqoop list-tables</span><br><span class="line">--username root</span><br><span class="line">--password 111111</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;192.168.164.25:3306&#x2F;test</span><br></pre></td></tr></table></figure></p></li>
<li><p>要将采集的日志数据作为 kafka 的数据源，则 flume sink 需要设置为下列哪项参数 A. hdfs B. kafka C. org.apache.flume.sink.kafka.KafkaSink☑️ D. {topicname}</p></li>
<li><p>下列是关于 flume 和 sqoop 对比的描述，不正确的是 A. flume 主要用来采集日志而 sqoop 主要用来做数据迁移 B. flume 主要采集流式数据而 sqoop 主要用来迁移规范化数据 C. flume 和 sqoop 都是分布式处理任务☑️ D. flume 主要用于采集多数据源小数据而 sqoop 用来迁移单数据源数据</p></li>
<li><p>有关 Elasticsearch 描述有误的一项是 A. 它会利用多播形式发现节点。 B. 主节点(master node) 通过选举方式产生。 C. 主节点(master node)进行集群的管理，只负责集群节点添加和删除。☑️ D. 主节点会去读集群状态信息，必要的时候进行恢复工作。</p></li>
<li><p>下面措施中，不能保证 kafka 数据可靠性的是 A. kafka 会将所有消息持久化到硬盘中保证其数据可靠性 B. kafka 通过 Topic Partition 设置 Replication 来保证其数据可靠性 C. kafka 通过设置消息重发机制保证其数据可靠性 D. kafka 无法保证数据可靠性☑️</p></li>
<li><p>TDH 提供哪几种认证模式？ A. 所有服务使用简单认证模式——所有服务都无需认证即可互相访问☑️ B. 所有服务都启用 Kerberos 认证，用户要提供 Kerberos principal 和密码（或者keytab）来访问各个服务☑️ C. 所有服务都启用 Kerberos 同时 Inceptor 启用 LDAP 认证☑️ D. 所有服务都启用 LDAP 认证</p></li>
<li><p>开启 LDAP 后，应该使用哪个命令连接 Inceptor A. transwarp -t -h <span class="math inline">\(ip。 B. beeline -u jdbc:hive2://\)</span>ip:10000 -n $username -p <span class="math inline">\(password。☑️ C. beeline -u &quot;jdbc:hive2://\)</span>ip:10000/default;principal=hive/node1@TDH"。 D. beeline -u "jdbc:hive2://$ip:10000/default;principal=user1@TDH"。</p></li>
<li><p>Inceptor server 服务无法启动时，该如何查看日志是 A. 查看 TDH manager 所在节点/var/log/inceptorsql<em>/目录下的 hive-server2.log 日志 B. 查看 Inceptor server 所在节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志☑️ C. 查 看 Resource Manager 所 在 节 点 /var/log/Yarn<em>/ 目 录 下 的yarn-yarn-resourcemanager-poc-node1.log 日志 D. 查看任意节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志</p></li>
<li><p>现有一批数据需要进行清洗，要求对其中 null 通过 update 转换为 0，删除重复的记 录，添加部分新的记录，则该表应该设计为 A. Tex 表 B. Orc 表 C. Orc 事务表☑️ D. Holodesk 表</p></li>
<li><p>现有一个表数据要存储在 hyperbase 上，并创建全文索引，原表数据 10GB，HDFS 配置为 3 副本，hyperbase 压缩比例按 1:3 计算，索引数据量为 20GB，ES 副本数为 1， ES 压缩比按 1:3 计算，则该表需要多大的存储空间存储 A. 16.67GB B. 23.33GB☑️ C. 30GB D. 70GB</p></li>
<li><p>下面哪些工作不属于集群预安装工作 A. 为集群中每个节点的安装操作系统 B. 选一个节点作为管理节点，修改其 /etc/hosts 文件 C. 安装 Transwarp Manager 管理界面 D. 配置集群安全模式☑️</p></li>
</ol>
<h3 id="问答题">问答题</h3>
<ol type="1">
<li>集群有 8 个节点，每个节点有 8 块硬盘（默认 3 副本）。如果某个节点有 3 块盘损坏，是否可能存在数据块丢失情况；如果有 3 个节点发生故障，是否可能存在数据块丢失情况；并简述原因。</li>
<li>请描述 TDH 平台中在 Yarn 上可以使用哪几种调度策略，并分别阐述各调度策略的特点。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FIFO Scheduler（先进先出调度器）：(策略)将所有任务放入一个队列，先进队列的先获得资源，排在后面的任务只有等待。(缺点)－资源利用率低，无法交叉运行任务。－灵活性差。</span><br><span class="line"></span><br><span class="line">Capacity Scheduler（容量调度器）：(思想)提前做预算，在预算指导下分享集群资源。(策略)集群资源由多个队列分享。每个队列都要预设资源分配的比例（提前做预算）。空闲资源优先分配给“实际资源&#x2F;预算资源”比值最低的队列。队列内部采用FIFO调度策略。(特点)层次化的队列设计。容量保证：每个队列都要预设资源占比，防止资源独占。弹性分配：空闲资源可以分配给任何队列，当多个队列争用时，会按比例进行平衡。支持动态管理。访问控制。多租户：多用户共享集群资源。</span><br><span class="line"></span><br><span class="line">Fair Scheduler（公平调度器）：（调度策略)多队列公平共享集群资源。通过平分的方式，动态分配资源，无需预先设定资源分配比例。队列内部可配置调度策略：FIFO、Fair（默认）。</span><br></pre></td></tr></table></figure></li>
<li>请描述一个 100GB 文件写入 HDFS 的整个过程（使用 bulkload 方式实现） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">抽取：从数据源中抽取数据</span><br><span class="line">对于MySQL，运行mysqldump命令导出数据</span><br><span class="line"></span><br><span class="line">转换：利用MapReduce，将数据转换为HFile文件</span><br><span class="line">对于TSV或CSV文件，使用HBase ImportTsv工具将其转换成HFile文件 －每个输出文件夹中的每个区域都会创建一个HFile文件</span><br><span class="line"></span><br><span class="line">加载：将HFile文件加载到HBase</span><br><span class="line">利用HBase CompleteBulkLoad工具，将HFile文件移动到HBase表的相应目录中，完成加载</span><br><span class="line"></span><br><span class="line">具体来说：</span><br><span class="line">1)客户端发送创建文件指令给分布式文件系统</span><br><span class="line">2)文件系统告知namenode (检查权限，查看文件是否存在。EditLog增加记录。返回输出流对象)</span><br><span class="line">3)客户端往输出流中写入数据,分成一个个数据包</span><br><span class="line">4)根据namenode分配,输出流往datanode写数据(多个datanode构成一个管道pipeline,输出流写第一个,后面的转发)</span><br><span class="line">4)每个datanode写完一个块后，返回确认信息</span><br><span class="line">5)写完数据，关闭输出流</span><br><span class="line">6)发送完成信号给namenode</span><br></pre></td></tr></table></figure></li>
<li>请以 WordCount 为例描述 MapReduce 的运行过程，并列出 Spark 相较 MapReduce 的 优势 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">过程：todo</span><br><span class="line"></span><br><span class="line">优势：基于内存计算RDD;基于DAG优化任务流程(延迟计算);易于部署,更低的框架开销;丰富的API支持。</span><br></pre></td></tr></table></figure></li>
<li>写出以下场景下的优化思路</li>
</ol>
<ol type="a">
<li>假设在 Inceptor 上执行任务，发现 Map Task 数量多、执行时间短，应采取哪种措施来提升性能？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对数据块进行合并：Automerge（碎片自动合并）</span><br></pre></td></tr></table></figure></li>
<li>请简述在 Inceptor 中大表与大表做 join、大表与小表做 join 时分别有哪些优化手段 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大表与大表的普通JOIN：实现普通JOIN的过程是这样的：扫描过滤两张表的数据（Map Stages），然后通过Shuffle将Key哈希值相同的数据分发到各个节点，在各节点内部执行JOIN（Reduce Stages）</span><br><span class="line"></span><br><span class="line">MapJoin是一种针对大表与小表JOIN的特殊实现方式，在大小表数据量悬殊的情况下能有效的提升JOIN执行效率，一般受优化开关或者Hint控制启动。</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="6" type="1">
<li>请列出 TDH 下的 4 大组件（Inceptor、Hyperbase、StreamSQL、Discover）的特性以及适用场景。</li>
<li>假设集群的每个节点初始有 6 块硬盘，运行一段时间后，每个节点又加了 4 块新硬盘， 为了使数据在所有硬盘上分布均匀，能否通过 hdfs balancer 达到效果，为什么？并列出能达到效果的两种措施。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不能，旧版本的hdfs仅支持节点间的数据平衡，新版本可通过balancer实现</span><br><span class="line">1.手动重写所有数据  2.将数据全部移到几个节点上，再在节点间数据平衡</span><br></pre></td></tr></table></figure></li>
<li>请描述高并发检索和综合搜索的场景特点，这两种场景应使用哪种技术来做支撑， 并指出数据和索引各自的存储位置。</li>
<li>请描述 HDFS 的高可用性实现机制</li>
<li>请列举出平台支持的 5 种存储格式/引擎的表，并详细描述各自的存储特点、使用场景、支持的操作以及是否支持分区分桶 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Text 表：</span><br><span class="line">ORC 表：</span><br><span class="line">事务表：</span><br><span class="line">HoloDesk 表：</span><br><span class="line">Hyperbase 表：</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
</search>
