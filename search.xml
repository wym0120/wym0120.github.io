<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GUI-report</title>
    <url>/2020/07/02/GUI-report/</url>
    <content><![CDATA[<h2 id="看清gui-widgets-人工智能如何解决这些问题"><a href="#看清gui-widgets-人工智能如何解决这些问题" class="headerlink" title="看清gui widgets 人工智能如何解决这些问题"></a>看清gui widgets 人工智能如何解决这些问题</h2><p>gui widget detection</p>
<ul>
<li>重点之一是判断bounding box </li>
<li>另一个重点是region分类</li>
</ul>
<p>gui widget detection目前的困难：</p>
<ul>
<li>数据方面<ul>
<li>nature scene <ul>
<li>图文并茂</li>
<li>全景检测</li>
</ul>
</li>
<li>physical object<ul>
<li>各种各样的组件同种之间差距比较大，没有固定的feature很难区别</li>
</ul>
</li>
</ul>
</li>
<li>策略问题<ul>
<li>目前大多数的策略都是bottom-up，会造成很大噪音 </li>
<li>cnn神经网络更适合学习architecture而不是shape</li>
<li>gui detection需要更高的识别准确度，而目前一般的识别准度只是要求超过0.5</li>
</ul>
</li>
<li>模型选择问题</li>
</ul>
<h2 id="overall-performance"><a href="#overall-performance" class="headerlink" title="overall performance"></a>overall performance</h2><p>faster Rcnn &gt; deep learning &gt; 传统方法</p>
]]></content>
      <categories>
        <category>report</category>
      </categories>
      <tags>
        <tag>gui</tag>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title>asplos-sample</title>
    <url>/2020/06/30/asplos-sample/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>mobile</tag>
        <tag>system</tag>
        <tag>asplos</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-test-xxz</title>
    <url>/2020/07/03/jvm-test-xxz/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-test-wym</title>
    <url>/2020/07/03/jvm-test-wym/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>mobileperf</title>
    <url>/2020/06/30/mobileperf/</url>
    <content><![CDATA[<h1 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h1><h2 id="硬件配置差"><a href="#硬件配置差" class="headerlink" title="硬件配置差"></a>硬件配置差</h2><ol>
<li>压测时间长 72小时左右</li>
<li>需要同时测的app比较多</li>
</ol>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li>adb方式兼容性强、侵入性小，不需要考虑保活问题</li>
<li>pc端占用资源极少，移动端主要是系统调用</li>
</ol>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>原作者在博客里已经把几乎所有的关键点都讲了，实际代码中也并没有更多的技术性的细节，和操作系统的交互基本都是对adb shell的封装和对top等指令的调用，以及生成xlsx、csv文件和绘图<br>博客地址(<a href="https://testerhome.com/topics/23449" target="_blank" rel="noopener">https://testerhome.com/topics/23449</a>)</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>和操作系统交互</th>
</tr>
</thead>
<tbody><tr>
<td>连接</td>
<td>adb usb &gt; adb wifi</td>
</tr>
<tr>
<td>CPU</td>
<td>top指令</td>
</tr>
<tr>
<td>内存</td>
<td>dumpsys meminfo</td>
</tr>
<tr>
<td>FPS</td>
<td>dumpsys SurfaceFlinger/gfxinfo(after 8)</td>
</tr>
<tr>
<td>网络流</td>
<td>/proc/net/xt_qtaguid/stats （TrafficStats的底层实现）</td>
</tr>
<tr>
<td>电量</td>
<td>dumpsys batteryproperties/dumpsys battery（after）</td>
</tr>
<tr>
<td>进程数统计</td>
<td>ls -lt /proc/pid/task</td>
</tr>
<tr>
<td>其他</td>
<td>monkey logcat</td>
</tr>
</tbody></table>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>mobileperf只是做了统计，并且不能知道某个时刻到底做了什么事情，这样的一个工具是如何和其他工具结合起来来定位某个时刻的操作？</p>
<blockquote>
<p>讨论前的想法： 用录制好的测试序列作为测试，同时记录进行的操作与时间点，在监测结束后通过人工/按某个阈值筛选出可疑的范围，复现当时的操作找出性能问题<br>这样的做法有两个延伸问题：首先，假设在很久之前的某个操作带来了副作用导致在很后面的一个操作发生了性能问题要如何检查出来？其次，阈值的设置在业界实际中是怎么确定出来的？(作者提到的是用的是线上指标)</p>
</blockquote>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb Cheatsheet</title>
    <url>/2020/06/30/gdb-cheatsheet/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>tools</category>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>tools</tag>
        <tag>C language</tag>
      </tags>
  </entry>
</search>
