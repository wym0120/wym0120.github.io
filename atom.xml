<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Academic Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wym0120.github.io/"/>
  <updated>2021-04-20T05:53:43.891Z</updated>
  <id>https://wym0120.github.io/</id>
  
  <author>
    <name>MinguW</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[课堂笔记] 软件过程改进</title>
    <link href="https://wym0120.github.io/2021/04/12/cmmi/"/>
    <id>https://wym0120.github.io/2021/04/12/cmmi/</id>
    <published>2021-04-12T15:24:08.000Z</published>
    <updated>2021-04-20T05:53:43.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cmmi-复习总结">CMMI 复习总结</h1><ul><li><a href="#cmmi-复习总结">CMMI 复习总结</a><ul><li><a href="#过程改进">过程改进</a></li><li><a href="#连续式表示法与阶段式表示法">连续式表示法与阶段式表示法</a></li><li><a href="#等价阶段式定级">等价阶段式定级</a></li><li><a href="#关于-cmmi-模型的一系列理解">关于 CMMI 模型的一系列理解</a><ul><li><a href="#为什么要有标准过程">为什么要有标准过程</a></li><li><a href="#如何使用过程模型">如何使用过程模型</a></li><li><a href="#为什么过程模型很重要">为什么过程模型很重要</a></li><li><a href="#对-cmmi-模型的一些误解">对 CMMI 模型的一些误解</a></li></ul></li><li><a href="#关于-cmmi-模型的一系列知识点">关于 CMMI 模型的一系列知识点</a></li></ul></li><li><a href="#通用目标与通用实践">通用目标与通用实践</a><ul><li><a href="#对制度化的理解">对制度化的理解</a></li><li><a href="#对通用实践的理解">对通用实践的理解</a></li><li><a href="#通用实践和过程域的关系">通用实践和过程域的关系</a></li><li><a href="#已执行已管理已定义之间的区别">已执行、已管理、已定义之间的区别</a></li><li><a href="#过程之间的关系">过程之间的关系</a></li><li><a href="#通用目标与通用实践-1">通用目标与通用实践</a><ul><li><a href="#gg1-达成特定目标">GG1 达成特定目标</a></li><li><a href="#gg2-制度化为已管理的过程">GG2 制度化为已管理的过程</a></li><li><a href="#gg3-制度化为已定义的过程">GG3 制度化为已定义的过程</a></li><li><a href="#说人话版本">说人话版本</a></li><li><a href="#相关问题">相关问题</a></li></ul></li></ul></li><li><a href="#过程域">过程域</a><ul><li><a href="#过程域的定义">过程域的定义</a></li><li><a href="#过程管理类">过程管理类</a><ul><li><a href="#lv3组织级过程定义opd">Lv3组织级过程定义(OPD)</a></li><li><a href="#lv3组织级过程关注opf">Lv3组织级过程关注(OPF)</a></li><li><a href="#lv3组织级培训ot">Lv3组织级培训(OT)</a></li><li><a href="#lv4组织级过程性能opp">Lv4组织级过程性能(OPP)</a></li><li><a href="#lv5组织级绩效管理opm">Lv5组织级绩效管理(OPM)</a></li></ul></li><li><a href="#项目管理类">项目管理类</a><ul><li><a href="#lv2项目监督与控制pmc">Lv2项目监督与控制(PMC)</a></li><li><a href="#lv2项目计划pp">Lv2项目计划(PP)</a></li><li><a href="#lv2需求管理reqm">Lv2需求管理(REQM)</a></li><li><a href="#lv2供方协议管理sam">Lv2供方协议管理(SAM)</a></li><li><a href="#lv3风险管理rskm">Lv3风险管理(RSKM)</a></li><li><a href="#lv3集成项目管理ipm">Lv3集成项目管理(IPM)</a></li><li><a href="#lv4量化项目管理qpm">Lv4量化项目管理(QPM)</a></li></ul></li><li><a href="#工程类">工程类</a><ul><li><a href="#lv3需求开发-rd">Lv3需求开发 (RD)</a></li><li><a href="#lv3技术解决方案ts">Lv3技术解决方案(TS)</a></li><li><a href="#lv3产品集成pi">Lv3产品集成(PI)</a></li><li><a href="#lv3确认val">Lv3确认(VAL)</a></li><li><a href="#lv3验证-ver">Lv3验证 (VER)</a></li></ul></li><li><a href="#支持类">支持类</a><ul><li><a href="#lv2度量与分析ma">Lv2度量与分析(MA)</a></li><li><a href="#lv2配置管理cm">Lv2配置管理(CM)</a></li><li><a href="#lv2过程与产品质量保证ppqa">Lv2过程与产品质量保证(PPQA)</a></li><li><a href="#lv3决策分析与解决dar">Lv3决策分析与解决(DAR)</a></li><li><a href="#lv5原因分析与解决car">Lv5原因分析与解决(CAR)</a></li></ul></li></ul></li><li><a href="#ppt-中问题整理">PPT 中问题整理</a></li><li><a href="#说人话版本的过程域描述">说人话版本的过程域描述</a><ul><li><a href="#opd">OPD</a></li><li><a href="#opf">OPF</a></li><li><a href="#opp">OPP</a></li><li><a href="#ipm">IPM</a></li><li><a href="#ma">MA</a></li><li><a href="#cm">CM</a></li></ul></li></ul><h2 id="过程改进">过程改进</h2><ol type="1"><li>过程的定义</li></ol><blockquote><ul><li><strong>IEEE: Sequence of steps performed for a given purpose</strong></li><li><strong>PALL: Logical organization of people, materials, energy, equipment, and procedures into work activities designed to produce a SP ecified end result</strong></li><li><strong>CMMI GLOSSARY: A set of interrelated activities, which transform inputs into outputs, to achieve a given purpose (These activities can be mapped to one or more practices in CMMI process areas to allow a model to be useful for process improvement and process appraisal.)</strong></li></ul></blockquote><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413091924.png" /></p><p><strong>如上图所示，将这三个重要方面结合到一起的是组织中所使用的过程。</strong></p><ol start="2" type="1"><li><strong>过程改进的好处</strong></li></ol><ul><li>过程使您能够了解正在发生的事情。</li><li>通过定义，测量和控制过程，改进将更加成功和持久。</li><li>成功引入适当的技术，技巧和工具的可能性增加。</li><li>人们可以更加充分地发挥潜力，更加有效。</li></ul><ol start="3" type="1"><li><strong>软件过程和生命周期模型的区别</strong></li></ol><blockquote><p>软件过程和生命周期模型的区别</p><p>生命周期模型：一个软件产品或者系统要经历孕育、诞生、成熟、衰亡等阶段，一般称为软件生命周期（软件生存周期）。软件生命周期模型是指人们为开发更好的软件而归纳总结的软件生命周期的典型实践参考。</p><p>软件过程：为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合。这组实践之间往往有一定的先后顺序，作为一个整体来实现事先定义的一个或者多个目标。一个软件过程既可以覆盖从需 求到交付的完整生命周期, 也可以仅仅包括某些特定开发阶段。</p><p>区别：1、生命周期模型是 对一个软件开发过程的人为划分.同样的软件开发过程, 因为目的不一样, 可能会被划分和 命名成不同的生命周期模型。反过来，同样的生命周期模型，可能软件过程完全不同 2、生命周期模型是软件开发过程的主框架, 是对软件开发过程的一种粗粒度划分。3、生命周期模型中往往只定义管理实践，不包括技术实践</p></blockquote><ol start="4" type="1"><li><strong>软件项目管理和软件过程管理在管理对象、实现目标和参考模型三个角度的区别</strong></li></ol><blockquote><p>软件项目管理是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程，其管理的对象是各类软件项目。实现目标：成本、质量、工期（管理三大要素：目标、状态、纠偏）。</p><p>参考模型：软件项目管理需要借鉴一些本领域或者其他领域的经验教训, 由此产生了一些用来描述这些经验和教训的概念, 例如软件过程、生命周期模型等。管理视角：成功是否可以复制。</p><p>软件过程管理：管理对象是软件过程，管理的目的是为了让软件过程在开发 效率、质量等方面有着更好性能绩效.</p><p>参考模型：流水线设计管理。软件项目管理通常关注于一个项目，软件过程管理通常关注不止一个项目。软件项目管理（SCRUM,XP）类似于产品生产管理，软件过程管理（CMMI,SPICE）对应流水线的升级、建设、优化、维护、升级改造。软件过程管理参考模型 CMM/CMMI, SPICE 等软件过程改进参考模型 PDCA，IDEAL，软件过程管理与软件过程改进意思相近。</p></blockquote><ol start="5" type="1"><li>过程改进的底线</li></ol><ul><li>过程改进必须要服务于商业目标，不能为了改进而改进。<ul><li>比如为了一张证书而改进就是为了改进而改进。</li><li>评估应该是改进的起点而不是终点。</li></ul></li><li>过程改进对不同的企业或行业来说，含义是不一样的。<ul><li>比如 Google 和 Microsoft 什么级别都没有，但是没有人会之一它们的研发能力。</li><li>在招标这种场景下，可以认为企业的能力是能够比较的。</li></ul></li></ul><hr /><h2 id="连续式表示法与阶段式表示法">连续式表示法与阶段式表示法</h2><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413092723.png" /></p><blockquote><p>CMMI 支持两种使用级别的改进路径。一条路径使组织能够逐步改进其选定的单个过程域(或一组过程域)所对应的过程。另一条路径使组织能够以增量方式应对层次相继的过程域集合来改进相关的过程集。连续式表示法的关注点在于由能力等级度量的过程域能力，而阶段式表示法的关注点在于由成熟度级别度量的总体成熟度。</p><p>随着组织达成某一成熟度级别中一系列过程域的通用目标和特定目标，组织在提升组织级成熟度的同时也收获了过程改进带来的收益。 由于每一成熟度级别都为下一级别打下必要的基础，因此，<strong>在成熟度级别上的跳级尝试往往会导致反效果。</strong></p><p><strong>同时</strong>，需要认识到的是，过程改进活动应该关注于以组织的业务环境为背景的组织需要上，并认识到更高的成熟度级别中的过程域可以应对组织或项目的当前的与未来的需要。<strong>例如虽然过程组并非成熟度级别 2 级组织的必要特征，但是它可以成为组织达成成熟度级别 2 级途径中的有用部分。</strong></p><p>大多数组织对其所选的过程域，至少会选择能力等级 1 级作为目标，这要求达成所有选定过程域的特定目标。然而，将目标定于高于能力等级 1 级的组织会通过实施通用目标与通用实践，来专注于组织内所选过程的制度化。适用于每个过程域的通用目标也已预设完成。通用目标 2 适用于成熟度级别 2 级，通用目标 3 适用于成熟度级别 3 级到 5 级。</p><p><strong>成熟度越高，返工的风险就越低，而不是业务的风险降低</strong>（所以“收益越大，风险越大”对此并不成立，这句话的对象是做什么事情，而不是做事的方式）。</p></blockquote><hr /><h2 id="等价阶段式定级">等价阶段式定级</h2><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413165108.png" /></p><blockquote><p>这张图的作用：一方面快速的知道每一个过程域的具体名称和缩写的对应。另一方面也能够帮助理解能力等级和成熟度等级的区别。</p></blockquote><h2 id="关于-cmmi-模型的一系列理解">关于 CMMI 模型的一系列理解</h2><blockquote><p>能力成熟度模型(Capability Maturity Model，CMM)，包括 CMMI，都是对现实世界的简化表述，它涵盖了开发产品与服务的活动。CMMI 开发模型是一个参考模型，是实践的结构化集合，描述了有效过程的特征。CMMI 开发模型并不规定项目或组织必须遵循特定的过程顺序，或每天必须开发出一定数量的产品，或必须达成特定的绩效指标。模型所规定的是项目或组织应该具备应对开发相关实践的过程。项目或组织可将其过程映射至本模型中的过程域，以确定这些过程是否具备。</p></blockquote><h3 id="为什么要有标准过程">为什么要有标准过程</h3><blockquote><p>标准过程并不是教条主义，而是为了让项目小组更好地识别其他团队的优秀做法，促进共享。</p></blockquote><h3 id="如何使用过程模型">如何使用过程模型</h3><blockquote><p>帮助设定过程改进目标和优先级; 帮助确保稳定，有能力且成熟的过程;作为改善项目和组织过程的指南;通过评估方法来诊断组织当前的实践状态</p></blockquote><h3 id="为什么过程模型很重要">为什么过程模型很重要</h3><blockquote><p>过程模型提供一个开始改进的地方;社区先前经验的好处;共同的语言和共同的愿景;优先行动的框架</p></blockquote><h3 id="对-cmmi-模型的一些误解">对 CMMI 模型的一些误解</h3><blockquote><p>CMMI 模型的有关误解:所谓 CMMI 模型，是指 CMMI 刻画了软件团队/组织从不成熟到成熟的每个阶段的特征——即所谓的路线图。与实际的开发模型没关系。这个路线图其实也是 CMMI 模型最为精华的部分，甚至都可以在很多其他的领域借鉴。</p></blockquote><blockquote><p>推论一: CMMI 模型需要适当裁剪以适应公司的实际情况</p><p>CMMI 模型不需要裁剪，模型本身仅仅刻画成熟度路线图上不同阶段的特征。大部分公司都不具备能力来裁剪这个模型，真要裁剪，也是应该由 CMMI 的模型的提出方和维护方 SEI 干。真正需要裁剪的是公司内部定义的组织级开发流程和开发规范，这个需要裁剪以适应具体的项目场景，与 CMMI 模型的裁剪是完全不同的概念。</p></blockquote><blockquote><p>推论二:CMMI 模型太重了，不适合互联网时代的轻量级开发</p><p>这个说法的错误之处在于，不一定是 CMMI 重或者轻，而是，CMMI 根本就不是开发模型</p></blockquote><blockquote><p>推论三:CMMI 模型只适合大公司,大项目，不适合小项目</p><p>首先没人检验过;其次，项目的大小衡量本身也缺乏值得信赖的参考依据;最后，接受这种说法的人还是把 CMMI 当成是一种特殊的开发模型</p></blockquote><blockquote><p>推论四:CMMI 模型只适合需求不变或者很少变化的场合，不适合需求不确定，变化很多的场合</p><p>CMMI 不是开发模型，与需求变化与否无关，谈不上适应或者不适应。</p></blockquote><blockquote><p>推论五:CMMI 是官僚、重文档的</p><p>CMMI评估方法获取证据有两种方法： 验证式：提前准备好所有材料，评估团队根据材料看是否能支持实现目标；就评估团队而言，验证式更省时间（更多公司采用这种方式，导致了误解） 发现式：事先不需要准备好证据，由评估团队在开发现场访谈、自己发现证据</p></blockquote><blockquote><p>推论六:CMMI 与敏捷是对立的</p><p>这种说法是错的。最根本的原因是 CMMI 不是开发过程，而大部分敏捷则是具体的开发过程。两者根本就是风马牛不相及的事物，不具备冲突的基础。所以不存在两者之间的权衡和借鉴。</p><p>那么 CMMI 和敏捷到底有没有差异呢？首先，前者不是开发过程，而后者是开发过程，这是最直接最根本的差异。其次，CMMI 存在所谓的标准化，不管是评估方法还是实施办法都有标准化的趋势。而敏捷往往拒绝标准(追求灵活)。再次，作用，即让不熟悉的第三方认可上有差异。尽管 CMMI 目前的现状不乐观，但是，毕竟这种方式提供了一些有 价值的线索来了解某个软件组织的能力和成熟度的可能。 而这一点敏捷过程还无法提供。有一种说法，CMMI 是主要是组织级过程，而敏捷是项目小 组的过程。应该说这种说法有一定的问题，敏捷也可以是组织过程， CMMI 也可以只是关注在小组级别(2 级)。</p></blockquote><blockquote><p>推论七: CMMI 其不足是过于抽象</p><p>所有的模型都是抽象的，抽象恰恰是模型的本质特征之一。模型通过抽象来强化特征与目标之间的关系，这才能帮助我们理解其内在机理，指导具体实践。</p></blockquote><h2 id="关于-cmmi-模型的一系列知识点">关于 CMMI 模型的一系列知识点</h2><ol type="1"><li>CMMIv1.2分为哪三个集群</li></ol><blockquote><ul><li>面向开发的CMMI(CMMI-DEV)</li><li>面向采购的CMMI(CMMI-ACQ)</li><li>面向服务的CMMI(CMMI-SVC)</li></ul></blockquote><ol start="2" type="1"><li>CMMI来源于那三个模型 ，研究机构</li></ol><blockquote><ul><li>软件工程 sw-cmm</li><li>系统工程 EIA/IS</li><li>集成化产品和过程开发 IPD-CMM</li></ul></blockquote><ol start="3" type="1"><li>评估方法简述，评估三种类型、评估的主要依据、评估的结果</li></ol><blockquote><ul><li>SCAMPI评估方法是用于过程改进的标准CMMI评估方法</li><li>SCAMPI评估方法有三种类型:<ul><li>Class A:凡是按体系要求的项目都需要按体系要求做，评估的时候采取抽样评估；</li><li>Class B:评估试点项目与体系文档、CMMI模型的符合度；</li><li>Class C:评估完成的过程体系与CMMI模型的差距；</li></ul></li><li>目标下的全部实践被全部实施或者被大部分实施，所有缺点不会影响目标的达成。</li></ul></blockquote><hr /><h1 id="通用目标与通用实践">通用目标与通用实践</h1><h2 id="对制度化的理解">对制度化的理解</h2><blockquote><p>制度化是过程改进中的一个重要概念。当制度化在通用目标与通用实践的描述中被提及时，就意味着该过程已根植于工作的执行方式中，并且具有过程履行(即执行)的承诺与一致性。已制度化的过程在有压力的情况下更可能得到保持。</p><p><strong>说人话就是“主动的、习惯成自然”。接下来引出通用目标和通用实践，这两个东西就是帮助制度化的工具。</strong></p></blockquote><h2 id="对通用实践的理解">对通用实践的理解</h2><blockquote><p>通用实践之所以被称为“通用”，是因为相同的实践适用于多个过程域。 与通用目标相关联的通用实践描述了一些活动，这些活动被认为对通用目标的达成具有重要意义，并且有助于过程域所关联过程的制度化。通用实践是可以应用于所有过程域的组件。<strong>要将通用实践视为提醒。其目的在于提醒你正确地做事，属于期望的模型组件。</strong></p></blockquote><h2 id="通用实践和过程域的关系">通用实践和过程域的关系</h2><blockquote><p>如果说通用目标与通用实践是直接应对过程在组织范围内制度化的模型组件，那么很多过程域则通过支持通用实践的实施来应对制度化。此类过程域含有一个或多个特定实践，当其被实施时，某一通用实践也能得到完全的实施，或产生工作产品用于某一通用实践的实施。</p></blockquote><h2 id="已执行已管理已定义之间的区别">已执行、已管理、已定义之间的区别</h2><blockquote><p>已执行的过程是指完成了所需工作而满足过程域的特定目标的过程。</p><p>已执行与已管理之间的关键区别在于过程得到管理的程度。已管理的过程得到了计划(该计划可以是一份更全面的计划的一部分)，并且过程的执行依据计划得到了管理。当实际结果与执行情况显著偏离计划时，会采取纠正措施。已管理的过程能达成该计划的目标，并得到了制度化以实现执行上的一致。</p><p>已管理与已定义之间的关键区别在于过程描述、标准与规程的适用范围。对于已管理的过程，其过程描述、标准与规程适用于特定的 项目、组或组织级功能。因此，同一组织内的两个项目，其已管理的过程可能并不相同。</p><p>另一项关键区别在于，相比已管理的过程，已定义的过程描述更为详细， 执行更为严格。这一区别意味着改进信息更容易被理解、分析并使用。最后，已定义过程的管理建立在更为深入的理解之上，包括在过程活动的相互关系方面的理解，以及在过程、过程工作产品与过程服务的详细度量项方面的理解。</p><p><strong>说人话就是已执行就是把工作做完了; 已管理在这个基础之上关注了管理的三大要素:时间、质量、成本; 而已定义则是各方面都更加熟练的管理，翻车几率更小</strong></p></blockquote><h2 id="过程之间的关系">过程之间的关系</h2><blockquote><p>GG1 就相当于所有的 SG 的总和。</p><p>达成过程域的 GG1，就等于说你达成了该过程域的特定目标。</p><p>达成过程域的 GG2，就等于说你管理了与该过程域相关联的过程的执行。过程就如同任何项目或 支持活动那样得到了计划与监督。</p><p>达成过程域的 GG3，就等于说存在组织级标准过程，能够对其进行裁剪(按标准原样执行也是一种裁剪)得到你将要使用的过程。</p></blockquote><h2 id="通用目标与通用实践-1">通用目标与通用实践</h2><h3 id="gg1-达成特定目标">GG1 达成特定目标</h3><blockquote><p>过程域的特定目标得到过程的支持，过程的支持通过将可识别的输入工作产品转换为可识别的输出工作产品来实现。</p></blockquote><table><thead><tr class="header"><th>通用实践</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>GP 1.1 执行特定实践</td><td><strong>执行过程域的特定实践，以开发工作产品并提供服务来达成过程域的特定目标。</strong></td></tr></tbody></table><h3 id="gg2-制度化为已管理的过程">GG2 制度化为已管理的过程</h3><blockquote><p>过程得到制度化为已管理的过程。</p></blockquote><table><thead><tr class="header"><th>通用实践</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>GP 2.1 建立组织级方针</td><td><strong>建立并维护组织级方针，以计划并执行过程。</strong></td></tr><tr class="even"><td>GP 2.2 计划过程</td><td><strong>建立并维护计划，以执行过程。</strong></td></tr><tr class="odd"><td>GP 2.3 提供资源</td><td><strong>提供充分的资源，以执行过程、开发工作产品并提供过程的服务。</strong></td></tr><tr class="even"><td>GP 2.4 分派职责</td><td><strong>分派职责与职权，以执行过程、开发工作产品并提供过程的服务。</strong></td></tr><tr class="odd"><td>GP 2.5 培训人员</td><td><strong>必要时，培训过程的执行或支持人员。</strong></td></tr><tr class="even"><td>GP 2.6 控制工作产品</td><td><strong>将所选择的过程工作产品置于适当的控制级别。</strong></td></tr><tr class="odd"><td>GP 2.7 识别相关干系人，并使之参与</td><td><strong>识别过程的相关干系人，并使之按计划参与。</strong></td></tr><tr class="even"><td>GP 2.8 监督并控制过程</td><td><strong>对照执行过程的计划，监督并控制过程，并采取适当的纠正措施。</strong></td></tr><tr class="odd"><td>GP 2.9 客观评价遵守程度</td><td><strong>对照过程描述、标准与规程，对过程与所选工作产品的遵守程度进行客观评价，并处理不符合的情况。</strong></td></tr><tr class="even"><td>GP 2.10 与上级管理层一起进行状态评审</td><td><strong>与上级管理层一起对过程的活动、状态与结果进行评审，并解决问题。</strong></td></tr></tbody></table><h3 id="gg3-制度化为已定义的过程">GG3 制度化为已定义的过程</h3><blockquote><p>过程得到制度化为已定义的过程</p></blockquote><table><thead><tr class="header"><th>通用实践</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>GP 3.1 建立已定义的过程</td><td><strong>建立并维护已定义过程的描述。</strong></td></tr><tr class="even"><td>GP 3.2 收集与过程相关的经验</td><td><strong>收集源于过程的计划与执行的、与过程相关的经验，以支持组织过程与过程资产未来的使用与改进。</strong></td></tr></tbody></table><h3 id="说人话版本">说人话版本</h3><ul><li>GG 2<ul><li>GP 2.1 Establish an Organizational Policy<ul><li>比如一个项目是质量优先还是工期优先。</li><li>比如组织级培训（Organizational Training）的 Policy 就可以是内部的讲师优先（内部的人员变成讲师）或者外部的讲师优先。</li><li>定义了我们优先期望的是什么，在做一件事情的时候，按照一个指导思想去开展。</li></ul></li><li>GP 2.2 Plan the Process<ul><li>建立和维护一个实施过程的计划。</li><li>有一个过程域是 Project Planning（这里的 Planning 是一个动词），那么这时 GP 2.2 应该怎么理解？<ul><li>简单来说就是“计划的计划”，直接解释就是为了策划整个项目而做一个计划。</li><li>有必要吗？制定一个项目计划的大致步骤有：沟通需求、消化需求、估算、人员分配、开会讨论、计划评审等步骤，而这些步骤是无法短时间内一个人就能完成的，涉及到的人员有多个，所以是<strong>有必要制定一个计划</strong>来制定项目计划。</li></ul></li></ul></li><li>GP 2.3 Provide Resources</li><li>GP 2.4 Assign Responsibility<ul><li>角色或职责的分配。</li><li>可以结合 GP 2.7 理解。在一个过程实施的过程中，一定是有不同的角色和不同的职责。</li></ul></li><li>GP 2.5 Train People<ul><li>对人员进行培训，让他们具有足够的技能来完成这样工作。</li><li>对于组织级培训（OT）应该怎么理解？<ul><li>对培训人员进行培训是否有必要？有必要的，比如对讲师的培训可以包括怎样准备素材，怎样去把握节奏等内容。</li></ul></li></ul></li><li>GP 2.6 Control Work Products<ul><li>什么是工作产物：比如开了一个周会，产生了一个报告，那么这个报告就是一个 Work Product。</li><li>会议记录和需求文档的变更控制力度是不一样的。</li><li>很像是进行配置管理，但是配置管理本身是一个过程域，那么对于配置管理，这个目标应该怎么理解？<ul><li>配置管理的工作产品有：配置计划、基线发布计划（不能随意更改）、变更请求、配置审计报告（保存即可）。这些工作产品也应该用不同的管控水平去进行管控。</li></ul></li></ul></li><li>GP 2.8 Monitor and Control the Process<ul><li>呼应 GP 2.2。就是看一份计划的实施情况。</li><li>但并不是所有的计划都是按照日程进行的，比如需求管理变更，我们没有办法知道需求变更会在什么时候提出。</li><li>对于 PMC （项目监控）这个过程应该怎么理解？<ul><li>一个项目组往往会开周例会，例会往往会对进度进行一些监控等工作，但是开会这件事本身是需要监控的，防止开着开着就不开了。</li><li>纠正偏差的措施不能只是停留在周会上，需要让他产生作用，也是需要进行监控的。</li></ul></li></ul></li><li>GP 2.9 Objectively Evaluate Adherence<ul><li>确保大家按照流程和规范做事。</li><li>QA 相当于过程的警察。不制定规范，但是要执行规范。QA 的 QA 则是执法过程本身也是需要确保合法的。</li></ul></li><li>GP 2.10 Review Status with Higher Level Management</li></ul></li><li>GG 3 已定义的过程<ul><li>GP 3.1 过程定义本身需要遵循一定的流程。</li><li>GP 3.2 收集资料这个过程本身也有资料需要进行收集，需要明确定义。</li></ul></li><li>如何应用 GP？<ul><li>GP/GG 对应的是“好坏”问题，即 Capability Level，而 SP/SG 对应的是“有无”的问题，即 Maturity Level。</li><li>GP 和 GG 确保了 SP 和 SG 的可持续性。</li></ul></li></ul><h3 id="相关问题">相关问题</h3><ol type="1"><li><p>GP2.5的培训，组织过程相关的过程域培训如何进行 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)内部:除了过程改进的相关过程域可以由EPG(过程改造专员)进行培训</span><br><span class="line">(2)外部:过程改进以”O”字打头的这些比较特殊的过程域请培训机构进行培训</span><br></pre></td></tr></table></figure></p></li><li><p>GP2.7 识别和使卷入的英文、两个词语的动作过程解释 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">识别:把干系人识别出来，认识出来，写到计划文档里头去</span><br><span class="line">使卷入:让干系人参与我们的评审过程。比如开评审会议时，需要提意见</span><br></pre></td></tr></table></figure></p></li><li><p>比较 GP2.10 中关于领导的描述在CMM和CMMi中的差别，CMMI的改进有何具体意义 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMM: high management(高层领导)</span><br><span class="line">CMMI: higher level management(高级别领导)</span><br><span class="line">高层领导是提供一些授权，赋予你一定的权利。在资源方面提供大方向的把握</span><br><span class="line">高级别领导能够在问题解决的实际意义上和资源的调剂上面起到实质性的作用</span><br></pre></td></tr></table></figure></p></li></ol><hr /><h1 id="过程域">过程域</h1><h2 id="过程域的定义">过程域的定义</h2><blockquote><p>某个领域中的一系列相关实践，如果共同实施，则可以满足一系列目标，这些目标对于该领域的改进至关重要</p></blockquote><h2 id="过程管理类">过程管理类</h2><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094344.png" /></p><blockquote><p>理解上面这张图可以从 OPD 开始，首先 OPD的目的和作用是帮助我们正确理解 CMMI。它不是开发方法，而是建立组织级开发流程，用来指导每个项目组开发。简单来说就是在进行了一段时间的软件开发之后，发现了实践过程中可以改进的地方，OPD 可以根据这些建议为自己这个组织定义了新的过程。</p><p>而这些建议也会被 OPF 所获得，而 OPF 的执行过程中比较直观地（不够客观度量）总计了当下过程的优缺点，并且计划、实施并部署了这些改进。给了 OPD 更多的信息。同时 OPD 还综合考虑了业务目标进行新的定义。 在有了新的过程之后，必须通过 OT，也就是培训来让相关技术人员掌握新的过程。 所有这上面的过程域都是针对过程本身的，最重要的目的就是希望整个组织在一次次项目过程中不断改进自己的过程实践。而因为这些过程域都只是3级的，相对而言比较粗糙、不够客观。</p></blockquote><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094416.png" /></p><blockquote><p>理解上面这张图首先从搞清楚名词开始。 OPP 组织级过程性能: 结合术语表和过程域自身的描述，过程性能实际上是<strong>完成了这个过程之后，某些组织、客户所关心的属性达成了什么样的指标</strong>，例如工作量、周期、缺陷排除有效性，OPP关心的是一个结果。而它的一系列的子实践就是在选定我关心什么、怎么度量我所关心的东西、我需要其他过程域至少给我提供哪些东西（基线）、使用什么模型来计算。值得注意的是 OPP 中所用的方法都是量化的方法，这是它和之前低级的过程域的一个显著区别。</p><p>显然，如果只有一个目标是无法实现的，因此，OPP 需要和 OPM 配合。</p><p>OPM 组织级绩效管理: 绩效的含义是<strong>项目在项目计划执行方面的达成情况，包括工作量、成本、进度以及技术性能。</strong>简单来说，OPM 的作用就是来主动监管 OPP 以及其他过程域中的目标是否被完成，没有完成就试图找到办法去弥补。OPM是一个5级的过程域，其实和 OPF 是一回事，所以我们通常说OPM是一个增强版本的 OPF，体现在管理从定性到定量。</p></blockquote><h3 id="lv3组织级过程定义opd">Lv3组织级过程定义(OPD)</h3><blockquote><p><strong>目的</strong>: 建立并维护一套可用的组织级过程资产、工作环境标准以及团队规则与指南。</p><p><strong>概要</strong></p><ul><li>SG 1 建立组织级过程资产<ul><li>SP 1.1 建立标准过程</li><li>SP 1.2 建立生命周期模型描述</li><li>SP 1.3 建立裁剪准则与指南</li><li>SP 1.4 建立组织的度量库</li><li>SP 1.5 建立组织的过程资产库</li><li>SP 1.6 建立工作环境标准</li><li>SP 1.7 建立团队的规则与指南</li></ul></li></ul></blockquote><h3 id="lv3组织级过程关注opf">Lv3组织级过程关注(OPF)</h3><blockquote><p><strong>目的</strong>: 基于对组织过程与过程资产当前的强项与弱项的透彻理解，计划、实施并部署组织级过程改进。</p><p><strong>概要</strong></p><ul><li>SG 1 确定过程改进机会<ul><li>SP 1.1 建立组织级过程需要</li><li>SP 1.2 评估组织的过程</li><li>SP 1.3 识别组织的过程改进</li></ul></li><li>SG 2 计划并实施过程行动<ul><li>SP 2.1 建立过程行动计划</li><li>SP 2.2 实施过程行动计划</li></ul></li><li>SG 3 部署组织级过程资产并纳入经验<ul><li>SP 3.1 部署组织级过程资产</li><li>SP 3.2 部署标准过程</li><li>SP 3.3 监督实施</li><li>SP 3.4 将经验纳入到组织级过程资产中</li></ul></li></ul></blockquote><h3 id="lv3组织级培训ot">Lv3组织级培训(OT)</h3><blockquote><p><strong>目的</strong>: 发展人员的技能与知识，使其能够有效且高效地执行他们的角色。</p><p><strong>概要</strong></p><ul><li>SG 1 建立组织级培训能力<ul><li>SP 1.1 建立战略培训需要 (组织未来二至五年内有什么大的计划，因此需要什么人才)</li><li>SP 1.2 确定哪些培训需要属于组织的职责</li><li>SP 1.3 建立组织级培训的战术计划 (做计划)</li><li>SP 1.4 建立培训能力 (找老师，找资料)</li></ul></li><li>SG 2 提供培训<ul><li>SP 2.1 交付培训</li><li>SP 2.2 建立培训记录</li><li>SP 2.3 评估培训的有效性</li></ul></li></ul></blockquote><h3 id="lv4组织级过程性能opp">Lv4组织级过程性能(OPP)</h3><blockquote><p><strong>目的</strong>: 建立并维护对组织标准过程集中所选定过程性能的量化理解， 以支持达成质量与过程性能目标， 并提供过程性能数据、基线与模型， 以量化管理组织的项目。</p><p><strong>概要</strong></p><ul><li>SG 1 建立性能基线与模型<ul><li>SP 1.1 建立质量与过程性能目标</li><li>SP 1.2 选择过程</li><li>SP 1.3 建立过程性能度量项</li><li>SP 1.4 分析过程性能并建立过程性能基线</li><li>SP 1.5 建立过程性能模型</li></ul></li></ul></blockquote><ol type="1"><li><p>x.y.z代表着什么 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先 x.y.z 这样的目标表示主要出现在4-5级的过程域中，因为只有到这个级别的过程域才会量化的考虑目标。</span><br><span class="line"></span><br><span class="line">z通常用来表示整个项目的目标，比如最终上线的时候每一千行缺陷不超过一个</span><br><span class="line">要做到z这个目标那么就需要把之前的上游的一些东西管控起来比如单元测试的质量，这就是y</span><br><span class="line">但是单元测试是没办法管控的，所以依赖于更底层的x，例如对人员的技能有要求</span><br></pre></td></tr></table></figure></p></li><li><p>理解 OPP 的目的 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以下为原文</span><br><span class="line">基于项目与组织的需要，可以适当在组织的不同级别，包括个别项目或相关项目的组合，进行数据的收集和分析并进行过程性能基线和模型的创建。</span><br><span class="line">期望的过程性能可用于建立项目的质量与过程性能目标，并且可用于实际项目绩效的比较基线，这个信息可以用来量化的管理项目。</span><br><span class="line">过程性能模型用来表示过去和当前的过程性能，并且用来预测过程将来的结果。</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li></ol><h3 id="lv5组织级绩效管理opm">Lv5组织级绩效管理(OPM)</h3><blockquote><p><strong>目的</strong>: 主动地管理组织的绩效以满足其业务目标。</p><p><strong>概要</strong></p><ul><li>SG 1 管理业务绩效<ul><li>SP 1.1 维护业务目标 (看看实际效果和目标是否一致，不一致可能需要改变目标)</li><li>SP 1.2 分析过程性能数据</li><li>SP 1.3 识别潜在改进领域</li></ul></li><li>SG 2 选择改进<ul><li>SP 2.1 挖掘所建议的改进</li><li>SP 2.2 分析所建议的改进</li><li>SP 2.3 确认改进</li><li>SP 2.4 选择并实施将要部署的改进</li></ul></li><li>SG 3 部署改进<ul><li>SP 3.1 计划部署</li><li>SP 3.2 管理部署</li><li>SP 3.3 评价改进效果</li></ul></li></ul></blockquote><hr /><h2 id="项目管理类">项目管理类</h2><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094441.png" /></p><blockquote><p>要理解这部分最好先看工程类和支持类过程域都有哪些东西。 从 PP 讲起， PP 主要是和工程类的进行交互，例如 RD ，首先知道需要客户想要什么，然后 PP 会告诉工程类的过程域让他们做什么，告诉支持类的需要什么样的度量，告诉 PMC 需要监督什么。</p><p>接着是 PMC，PMC 从 MA 和 PPQA 那里拿到了真实的过程执行状态和评价，它会根据这个结果来进行纠偏。这个纠偏包括了项目内部的(反馈给工程类过程域)，也包括了对供方的纠偏。</p><p>这里的供方举例比较好理解，例如项目开发需要 IDE，需要购买服务器测试，而这些服务、产品的提供者就是供方，SAM 可能在大项目大组织中比较重要，在小规模的时候作用似乎不明显。</p><p>REQM 的存在是为了保护程序员的身心健康，虽然说敏捷中是拥抱变化的，但其实没有人真的愿意一直面对不停变更的需求。</p></blockquote><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094504.png" /></p><blockquote><p>从前面低等级的过程域里可以看到一个项目已经基本被管理起来了，内部是比较协调的。但是除了内部的不稳定因素，项目外也伴随巨大的风险，比如客户的需求变更。因此 RSKM 提出了进一步的需求（3级建立在2级基础之上，前面过程域2级居多）。RSKM 是比较有预见性的，结合敏捷里学过的知识，很多实践其实也和敏捷有关，例如让客户陪你一起受苦，尽早把原型做出来给他们看。</p><p>但是风险管理这件事情也不能随便就制定下来，它还需要其他的过程域的一些支持，例如 IPM。</p><p>IPM 应用的范围是一个项目，它其实使用了 OPD 的产出。OPD 的产出是一个组织级的标准过程的集合，也是从CMMI标准中筛选出适合自身组织的内容的。而 IPM 就是在这个基础之上把这些过程具体在某个项目上进行运用。这样做的好处是同一个组织内项目之间的差异性会被降低。各项目可以比较容易的分享经验和教训，以及发现的风险和一些好的数据。IPM 是 RSKM 的一个输入。IPM 这个过程域的执行也会同时反馈出一些经验、产出一些数据给其他的过程域，处于一个比较中心的位置。</p><p>而随着成熟度的进一步提高，QPM 能够通过量化的方式优化 IPM 所做的事情，例如图中可以看到的“风险暴露值”。QPM 的实现也能让 IPM 的输入来源更多，这意味着得到的结果可以更加精准。</p></blockquote><h3 id="lv2项目监督与控制pmc">Lv2项目监督与控制(PMC)</h3><blockquote><p><strong>目的</strong>: 提供对项目进展的了解，以便在项目绩效显著偏离计划时可采取适当的纠正措施。</p><p><strong>概要</strong></p><ul><li>SG 1 对照计划监督项目<ul><li>SP 1.1 监督项目计划参数</li><li>SP 1.2 监督承诺</li><li>SP 1.3 监督项目风险</li><li>SP 1.4 监督数据管理</li><li>SP 1.5 监督干系人的参与</li><li>SP 1.6 进行进展评审</li><li>SP 1.7 进行里程碑评审</li></ul></li><li>SG 2 管理纠正措施直至关闭<ul><li>SP 2.1 分析问题</li><li>SP 2.2 采取纠正措施</li><li>SP 2.3 管理纠正措施</li></ul></li></ul></blockquote><ol type="1"><li><p>项目监控点选择的原则？原因 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.重要的里程碑       </span><br><span class="line">原因:项目阶段重要的完成标志，通过才能证明这一阶段任务完成，才能满足干系人的期望</span><br><span class="line">B. 时间间隔比较合理  </span><br><span class="line">原因:假如时间太长不能在合适的时期对偏差进行纠偏行动，会延误项目进展，时间太短不起作用，没法监控到项目的具体指标</span><br></pre></td></tr></table></figure></p></li><li><p>SG2中的相关实践约定，需要采取纠偏措施的问题来源 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来自于项目监控过程域，PPQA收集问题:项目监控、验证、确认；项目监控过程域中的问题列表管理</span><br></pre></td></tr></table></figure></p></li><li><p>纠偏行动的先决条件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有偏离问题列表，在偏差界限达到15%或20%时，进行纠正</span><br></pre></td></tr></table></figure></p></li><li><p>管理的三要素 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目标、状态、纠偏</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="lv2项目计划pp">Lv2项目计划(PP)</h3><blockquote><p><strong>目的</strong>: 建立并维护定义项目活动的计划。</p><p><strong>概要</strong></p><ul><li>SG 1 建立估算<ul><li>SP 1.1 估算项目范围</li><li>SP 1.2 建立对工作产品与任务属性的估算</li><li>SP 1.3 定义项目生命周期阶段</li><li>SP 1.4 估算工作量与成本</li></ul></li><li>SG 2 制订项目计划<ul><li>SP 2.1 建立预算与进度</li><li>SP 2.2 识别项目风险</li><li>SP 2.3 计划数据管理</li><li>SP 2.4 计划项目资源</li><li>SP 2.5 计划所需的知识与技能</li><li>SP 2.6 计划干系人的参与</li><li>SP 2.7 建立项目计划</li></ul></li><li>SG 3 获得对计划的承诺<ul><li>SP 3.1 评审影响项目的各项计划</li><li>SP 3.2 协调工作与资源水平</li><li>SP 3.3 获得对计划的承诺</li></ul></li></ul></blockquote><ol type="1"><li><p>PP过程域在项目中的作用域<br /><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">项目启动阶段后开始，一直到验收阶段开始一段时间到管理收尾</span><br></pre></td></tr></table></figure></p></li><li><p>计划制定的原则？<br /><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">产品计划的制订是由上往下制订，由下往上修改的过程</span><br></pre></td></tr></table></figure></p></li><li><p>一般的估算方法有哪几个？区别 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1)Delphi(德尔菲)估计，PERT Sizing 估算</span><br><span class="line">2)区别:Delphi适用于项目资金多的时候，项目前期做估计(大项目)</span><br><span class="line">PERT Sizing适用于时间短，资金少的时候，适用于后期比较明朗，紧迫的项目或项目中后期的重估计的时候(小项目)</span><br><span class="line">两种方法比较:PERT Sizing估算花的时间短，资金用的少，精确度不高。Delphi成本高，时间长，精确度高。</span><br></pre></td></tr></table></figure></p></li><li><p>什么是承诺管理？承诺的分类 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">承诺管理是对干系人承诺进行管理、保证，并兑现干系人的承诺。分为3类:结盟和协议、促进合作、允许变更</span><br></pre></td></tr></table></figure></p></li><li><p>PP中“建立”和“维护”两个活动的解释？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">建立:把项目文档写好并发布出去</span><br><span class="line">维护:项目实施过程中，发现项目的进展和计划发生偏差的时候进行调整</span><br></pre></td></tr></table></figure></p></li><li><p>估算目标: 不是尽可能客观描述代码行/工作量（永远不可能实现估算），而是得到一个数字<strong>数字对不对不重要，重要的是大家认可</strong></p></li></ol><h3 id="lv2需求管理reqm">Lv2需求管理(REQM)</h3><blockquote><p><strong>目的</strong>: 管理项目的产品与产品组件需求，并确保那些需求与项目计划和工作产品间的协调一致。</p><p><strong>概要</strong></p><ul><li>SG 1 管理需求<ul><li>SP 1.1 理解需求</li><li>SP 1.2 获得对需求的承诺</li><li>SP 1.3 管理需求变更</li><li>SP 1.4 维护需求的双向可追溯性</li><li>SP 1.5 确保项目工作与需求间的协调一致</li></ul></li></ul></blockquote><ol type="1"><li><p>(需求跟踪的方法) 需求跟踪矩阵的使用 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是需求跟踪矩阵的一个规程。在改写相关的产品的时候，相关的工作产品也要跟着去改。(比如:现在我在写代码，要去改设计文件，相关的产品设计文档和代码都需要修改。)</span><br></pre></td></tr></table></figure></p></li><li><p>(获得需求承诺) 应该获得那些人的承诺 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需求相关干系人:项目组内部:项目经理，需求分析师，设计人员，企业高层; 外部:供应商，客户</span><br></pre></td></tr></table></figure></p></li><li><p>识别需求不一致性的最有效方法 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需求评审</span><br></pre></td></tr></table></figure></p></li><li><p>敏捷对于需求的态度是拥抱变更，但这是不正确的，大部分开发人员还是希望能够close开发</p></li><li><p>Scrum对于需求的态度是不响应一个SP rint中的需求变更(目标不变)，只是记录到backlog，可能会在下一个迭代响应变更</p></li><li><p>理解双向可跟踪 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双向可追踪关注的是需求之间的关系。术语表上的定义是“两个或更多逻辑实体间可从任一方向（即至某一实体或自某一实体）认识的关联”，这里的两个实体指的是高层次的需求和低层次的需求。</span><br><span class="line">这两种需求往往是多对多的关系，但是在有频繁变更的时候，管理的代价比较高昂。例如一个需求变化了，会导致其他和他相关的需求、设计、代码等等都会发生变化。</span><br><span class="line"></span><br><span class="line">一个比较极端的做法是以文档作为最小的颗粒度，一对一的去联系这两个实体，这么做虽然管理代价变低，但是每个需求变更的影响评估也就没有办法实施了。</span><br><span class="line"></span><br><span class="line">因此在实际中的做法是在一个比较小粒度的层次上（例如功能点）找到一个平衡，在这个层次上去做双向可跟踪。</span><br></pre></td></tr></table></figure></p></li><li><p>先做计划还是先做需求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">应该先做计划，再做需求。可以先大致的讨论需求的范围得到一个初步的需求，当大家认为到了可以进行估算的程度时，就开始进行计划。</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="lv2供方协议管理sam">Lv2供方协议管理(SAM)</h3><blockquote><p><strong>目的</strong>: 管理从供方采购产品与服务的活动。</p><p><strong>概要</strong></p><ul><li>SG 1 建立供方协议<ul><li>SP 1.1 确定采购类型</li><li>SP 1.2 选择供方</li><li>SP 1.3 建立供方协议</li></ul></li><li>SG 2 履行供方协议<ul><li>SP 2.1 执行供方协议</li><li>SP 2.2 接受采购的产品</li><li>SP 2.3 确保产品移交</li></ul></li></ul></blockquote><h3 id="lv3风险管理rskm">Lv3风险管理(RSKM)</h3><blockquote><p><strong>目的</strong>: 在项目潜在的问题发生前对其进行识别，以便在整个产品或项目生命期中，计划并在需要时启动风险的处理行动，从而降低这些潜在问题对达成目标产生的不利影响。</p><p><strong>概要</strong></p><ul><li>SG 1 准备风险管理<ul><li>SP 1.1 确定风险来源与类别</li><li>SP 1.2 定义风险参数</li><li>SP 1.3 建立风险管理策略</li></ul></li><li>SG 2 识别并分析风险<ul><li>SP 2.1 识别风险</li><li>SP 2.2 评价、分类风险并划分风险优先级</li></ul></li><li>SG 3 缓解风险<ul><li>SP 3.1 制订风险缓解计划</li><li>SP 3.2 实施风险缓解计划</li></ul></li></ul></blockquote><ol type="1"><li>风险参数包括</li></ol><ul><li>风险的可能性</li><li>风险发生时的影响和其严重性</li><li>触发管理活动的阈值</li></ul><h3 id="lv3集成项目管理ipm">Lv3集成项目管理(IPM)</h3><blockquote><p><strong>目的</strong>: 从组织的<strong>标准过程</strong>集中<strong>裁剪</strong>得到集成的已定义过程，并以此为依据建立并管理项目以及相关干系人的参与。</p><p><strong>概要</strong></p><ul><li>SG 1 使用项目已定义的过程<ul><li>SP 1.1 建立项目已定义的过程</li><li>SP 1.2 使用组织级过程资产计划项目活动</li><li>SP 1.3 建立项目工作环境</li><li>SP 1.4 集成各类计划</li><li>SP 1.5 使用集成的计划管理项目</li><li>SP 1.6 建立团队</li><li>SP 1.7 为组织级过程资产做出贡献</li></ul></li><li>SG 2 与相关干系人协调并协作<ul><li>SP 2.1 管理干系人的参与</li><li>SP 2.2 管理依赖</li><li>SP 2.3 解决协调问题</li></ul></li></ul></blockquote><h3 id="lv4量化项目管理qpm">Lv4量化项目管理(QPM)</h3><blockquote><p><strong>目的</strong>: 量化地管理项目，以达成项目已建立的质量与过程性能目标。</p><p><strong>概要</strong></p><ul><li>SG 1 准备量化管理<ul><li>SP 1.1 建立项目的目标</li><li>SP 1.2 组成已定义的过程</li><li>SP 1.3 选择子过程与属性</li><li>SP 1.4 选择度量项与分析技术</li></ul></li><li>SG 2 量化地管理项目<ul><li>SP 2.1 监督所选定子过程的性能</li><li>SP 2.2 管理项目绩效</li><li>SP 2.3 执行根本原因分析</li></ul></li></ul></blockquote><ol type="1"><li><p>OPP 和 QPM 的关联 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QPM 确保了 OPP 建立的基线能够被完成（OPP是一个组织的要求，QPM面对的是一个项目）</span><br><span class="line">QPM 通过使用 OPP 建立用于实现高成熟度的组织级过程资产，包括质量与过程性能目标、所选过程、度量项、基线和模型。</span><br><span class="line">并且使用这些东西来量化的管理（一个项目内的）过程。</span><br><span class="line">QPM 可以根据项目的特点来对这些目标进行调整。</span><br></pre></td></tr></table></figure></p></li><li><p>QPM SP1.2 和之前过程定义的区别 （和 IPM 的区别） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lv2 Lv3的过程域主要定义的是步骤，而 QPM 中需要用到一些统计的量化的手段来定义这个过程。</span><br><span class="line">这些手段用来告诉执行者需要做到什么程度。</span><br><span class="line">QPM 通过为项目评价备选过程或子过程， 并选择那些最可能达成质量与性能目标的过程或子过程</span><br></pre></td></tr></table></figure></p></li><li><p>QPM 和 OPM 的关系 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单的从成熟度级别上看，QPM 是4级，而 OPM 是5级，说明至少 OPM 一定程度上依赖 QPM。QPM 关注的是项目，而 OPM 关注的是组织，显然后者的范围更大。</span><br><span class="line">文档中的描述“本过程域适用于管理项目。应用这些概念来管理其他组与职能有助于将组织绩效的不同方面关联起来，从而提供一个基础，来平衡并协调存在竞争的优先级关系，以应对更广泛的业务目标集合。” </span><br><span class="line"></span><br><span class="line">说人话就是把组织的每个项目都量化管理好了，那么也就有可能在组织的层面把量化管理能力提高上去，达成 OPM 的目标。</span><br></pre></td></tr></table></figure></p></li><li><p>理解QPM <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">量化管理的一个基本要素是对预测有信心，即能够准确的预测项目在多大程度上满足质量和过程性能目标的能力。</span><br><span class="line">另一个基本要素是理解在过程性能中遇到的偏差本质和程度，并且察觉项目的实际绩效何时可能不足以达成项目的质量与过程性能目标。</span><br></pre></td></tr></table></figure></p></li></ol><hr /><h2 id="工程类">工程类</h2><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094525.png" /></p><blockquote><p>工程类的非常好理解，就是日常开发所经历的流程，这里不赘述了。</p></blockquote><h3 id="lv3需求开发-rd">Lv3需求开发 (RD)</h3><blockquote><p><strong>目的</strong>: 挖掘、分析并 建立客户需求、产品需求与产品组件需求。</p><p><strong>概要</strong></p><ul><li>SG 1 开发客户需求<ul><li>SP 1.1 挖掘需要</li><li>SP 1.2 将干系人的需要转换为客户需求</li></ul></li><li>SG 2 开发产品需求<ul><li>SP 2.1 建立产品与产品组件需求</li><li>SP 2.2 分配产品组件需求</li><li>SP 2.3 识别接口需求</li></ul></li><li>SG 3 分析并确认需求<ul><li>SP 3.1 建立操作概念与场景</li><li>SP 3.2 建立必需的功能与质量属性的定义</li><li>SP 3.3 分析需求</li><li>SP 3.4 分析需求以达到平衡</li><li>SP 3.5 确认需求</li></ul></li></ul></blockquote><h3 id="lv3技术解决方案ts">Lv3技术解决方案(TS)</h3><blockquote><p><strong>目的</strong>: 选择、设计并实现对需求的解决方案。解决方案、设计与实现包括单独的或以适当形式组合的产品、产品组件以及与产品相关的生命周期过程。</p><p><strong>概要</strong></p><ul><li>SG 1 选择产品组件解决方案<ul><li>SP 1.1 开发备选解决方案与选择准则</li><li>SP 1.2 选择产品组件解决方案</li></ul></li><li>SG 2 开发设计<ul><li>SP 2.1 设计产品或产品组件</li><li>SP 2.2 建立技术数据包</li><li>SP 2.3 使用准则设计接口</li><li>SP 2.4 执行自制、购买或复用分析</li></ul></li><li>SG 3 实现产品设计<ul><li>SP 3.1 实现设计</li><li>SP 3.2 开发产品支持文档</li></ul></li></ul></blockquote><ol type="1"><li><p>DAR 和 TS 的关联和区别 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TS 与 DAR 的区别：TS 要求进行技术方案的选择，其实际就是一个 DAR 的过程，从这点上来看两者是一致的，但是 DAR 的范围更加广阔，不仅仅局限于技术方面，比如说版本发布，过程推行等都可以考虑使用 DAR。</span><br></pre></td></tr></table></figure></p></li><li><p>DAR 的适用场景 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DAR 建立一个 Guildline 来指明什么场景下需要 DAR，什么场景下不需要。不是所有的活动都要走 DAR 的过程。</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="lv3产品集成pi">Lv3产品集成(PI)</h3><blockquote><p><strong>目的</strong>: 将产品组件装配成产品，确保产品作为一个整体正确地运行，即具有所要求的功能与质量属性，并<strong>交付</strong>产品。(不只是集成测试，PI 也包括了交付的步骤)</p><p><strong>概要</strong></p><ul><li>SG 1 准备产品集成<ul><li>SP 1.1 建立集成策略 (怎么集成、怎么评价集成结果)</li><li>SP 1.2 建立产品集成环境</li><li>SP 1.3 建立产品集成规程与准则 (SP1.1 的细节内容，例如单元测试)</li></ul></li><li>SG 2 确保接口兼容性<ul><li>SP 2.1 评审接口描述的完整性</li><li>SP 2.2 管理接口</li></ul></li><li>SG 3 装配产品组件并交付产品<ul><li>SP 3.1 确定需集成的产品组件准备就绪</li><li>SP 3.2 装配产品组件</li><li>SP 3.3 评价装配后的产品组件</li><li>SP 3.4 打包并交付产品或产品组件</li></ul></li></ul></blockquote><ol type="1"><li>假设你是产品集成的负责人，拒绝那些不合格的产品组件。定义哪些验收标准 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 确保产品组件已经进入配置库里面</span><br><span class="line">2. 待集成的产品组件必须经过单元测试（部分集成测试），提供测试报告</span><br><span class="line">3. 完整的接口描述文档</span><br><span class="line">4. 和生命周期有关的过程证据（质量角度考虑）例如评审报告、QA检查报告</span><br></pre></td></tr></table></figure></li></ol><h3 id="lv3确认val">Lv3确认(VAL)</h3><blockquote><p><strong>目的</strong>: 证明产品或产品组件被置于预期环境中时满足其预期用途。</p><p><strong>概要</strong></p><ul><li>SG 1 准备确认<ul><li>SP 1.1 选择需要确认的产品</li><li>SP 1.2 建立确认环境</li><li>SP 1.3 建立确认规程与准则</li></ul></li><li>SG 2 确认产品或产品组件<ul><li>SP 2.1 执行确认</li><li>SP 2.2 分析确认结果</li></ul></li></ul></blockquote><h3 id="lv3验证-ver">Lv3验证 (VER)</h3><blockquote><p><strong>目的</strong>: 确保选定的工作产品满足其规定的需求。</p><p><strong>概要</strong></p><ul><li>SG 1 准备验证<ul><li>SP 1.1 选择需要验证的工作产品</li><li>SP 1.2 建立验证环境</li><li>SP 1.3 建立验证规程与准则</li></ul></li><li>SG 2 执行同级评审<ul><li>SP 2.1 准备同级评审</li><li>SP 2.2 进行同级评审</li><li>SP 2.3 分析同级评审数据</li></ul></li><li>SG 3 验证选定的工作产品<ul><li>SP 3.1 执行验证</li><li>SP 3.2 分析验证结果</li></ul></li></ul></blockquote><ol type="1"><li>VAL 和 VER的关键区别 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VER 选择的是工作产品，即过程中自然的产物，VER 确定工作产品适当地反映了其规定的需求。而 VAL 选择的是产品。VAL 确定提供的（或将要提供的）产品或服务将满足其预期的用途解决方案，关注是否真的帮客户解决问题。</span><br><span class="line"></span><br><span class="line">另外：产品一定是工作产品，工作产品不一定是产品；交付给用户的才是产品；在不同场景中，交付给用户的产品可能不同</span><br></pre></td></tr></table></figure></li></ol><hr /><h2 id="支持类">支持类</h2><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094548.png" /></p><blockquote><p>支持类的普遍比较好理解，MA 为所有的东西规定了度量和分析的准则，是高成熟度过程域量化的前提。PPQA 则是提供了对过程执行的客观评价和度量，提供了改进的建议和基础。是后续OPD OPF 等过程域的基础。而 CM 管理了配置项的变动，让复杂的过程执行得到控制，不会因为版本或不一致的问题带来巨大的灾难，保证了其他过程域的正常执行。</p></blockquote><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20210413094612.png" /></p><blockquote><p>CAR 是5级成熟度的过程域，它建立在其他所有的过程域都能够良好执行的基础上。CAR 其实贯穿于组织和项目的始终，只是在不同成熟度的时候它的能力也有所不同。具体来说就是从只能排除具体原因到排除真正根源上的原因，它为组织的过程改进提供了方向和思路。而 DAR 是一个3级成熟度过程域，3 级是一个比较有特点的级别，在它之前是已管理，也就是说不管做的怎么样，反正先把项目做出来。而 3 级要求已定义，则是建立各种规章制度。比如 DAR 解决的问题就是到底该如何做决定，整个组织是遵循同一个标准做决策的。最直接的体现就是后续高成熟度的过程域都是带有预见性质的，也就是说需要在某些时刻作出正确且一致认可的决定。</p></blockquote><h3 id="lv2度量与分析ma">Lv2度量与分析(MA)</h3><blockquote><p><strong>目的</strong>: 开发并保持用于支持管理信息需要的度量能力。</p><p><strong>概要</strong></p><ul><li>SG 1 使度量与分析活动协调一致<ul><li>SP 1.1 建立度量目标</li><li>SP 1.2 明确说明度量项</li><li>SP 1.3 明确说明数据收集与存储的规程</li><li>SP 1.4 明确说明分析规程</li></ul></li><li>SG 2 提供度量结果<ul><li>SP 2.1 获得度量数据</li><li>SP 2.2 分析度量数据</li><li>SP 2.3 存储数据与结果</li><li>SP 2.4 沟通结果</li></ul></li></ul></blockquote><ol type="1"><li><p>度量分析的作用体现在哪些方面？(从项目和组织两个角度分析) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">项目组:提供了信息，为管理者提供决策信息，(告诉管理者项目所处在什么阶段，将来应该进行相应的项目管理决策。)</span><br><span class="line">组织:为组织及过程改进，提供决策信息。(要知道组织过程处于什么阶段，将来的改进方向)</span><br></pre></td></tr></table></figure></p></li><li><p>MA 和 PMC 的区别 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MA 中的度量信息类型可以包括进度、进展、工作量、规模、稳定性和质量。</span><br><span class="line">MA 针对的是状态而不是进度，与 PMC 有区别，目的是帮助我们了解目标的状态与实际的状态之间的差异。</span><br><span class="line">PMC 进行的是纠偏，而 MA 可以识别度量目标预期的行为变化，作为实施度量与分析活动的结果。</span><br></pre></td></tr></table></figure></p></li></ol><p><strong>下面这些题目应该是往年的资料，不一定是CMMI1.3的内容，至少我没有在文档中和ppt中找到相关的描述，请自行斟酌</strong></p><ol start="3" type="1"><li><p>度量的目的要支持质量的目标 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与产品质量有关:测试覆盖率、缺陷数量；一次性测试通过率；关键重要特性合格率；</span><br><span class="line">与成本有关:开发成本、维护成本、管理成本、现场服务时间；</span><br><span class="line">与产品交付有关:准时交付率；交付完整性、产品错发次数；延期交付率；一次准时交付率；</span><br><span class="line">与客户有关:顾客满意率；客户投诉次数；处理投诉时间；</span><br><span class="line">与人员及设备有关:员工满意率；设备利用率；设备完好率；设备故障率；培训效果；</span><br></pre></td></tr></table></figure></p></li><li><p>如何满足度量的可追踪性(哪些工作产品可以满足) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用度量数据库，例如项目度量表</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="lv2配置管理cm">Lv2配置管理(CM)</h3><blockquote><p><strong>目的</strong>: 使用配置识别、配置控制、配置状态记录与报告以及配置审计(<strong>也就是配置管理的四项主要工作</strong>)，来建立并维护工作产品的完整性。</p><p><strong>概要</strong></p><ul><li>SG 1 建立基线<ul><li>SP 1.1 识别配置项</li><li>SP 1.2 建立配置管理系统</li><li>SP 1.3 创建或发布基线</li></ul></li><li>SG 2 跟踪并控制变更<ul><li>SP 2.1 跟踪变更请求</li><li>SP 2.2 控制配置项</li></ul></li><li>SG 3 建立完整性<ul><li>SP 3.1 建立配置管理记录</li><li>SP 3.2 执行配置审计</li></ul></li></ul></blockquote><ol type="1"><li>一个软件开发过程中会产生很多工作产品artifacts/work product，但是并不是所有产品都是值得管理的，要去掉一些不那么重要的产品，确保重要的（为了让交付有完整性的）工作产品被管理。其实就是为了减少工作量。而除了管理项目的配置，该过程域也适用于组织级的工作产品，如标准、规程和其他的一些资源的配置管理。</li></ol><p><strong>因为往届的资料里有大量的关于CCB的问题，但是CMMI1.3文档中只是提到了几句，这里特别整理一下</strong> 2. CCB <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据wiki 上面的定义: Change Control Board (CCB) is a committee that consists of Subject Matter Experts (SME, e.g. software engineers, testing experts, etc.) and Managers (e.g. Quality Assurance managers), who decide whether to implement proposed changes to a project.</span><br><span class="line"></span><br><span class="line">简单来说 CCB 就是一群有权利控制变更的人。</span><br><span class="line">人员:项目经理，配置管理员，质量保证人员，开发人员代表，客户代表</span><br><span class="line">性质:为了控制项目基线的变更进行审批授权的临时性质的组织。</span><br><span class="line"></span><br><span class="line">他们的职责:</span><br><span class="line">确保变更被分类以及被评估</span><br><span class="line">评审和批准变更</span><br><span class="line">解决关于变更请求的争议</span><br><span class="line">做出关于变更的最终决策</span><br><span class="line">决定需要实施的变更的优先级</span><br><span class="line">确保只有被批准的变更得到实施</span><br></pre></td></tr></table></figure></p><ol start="3" type="1"><li><p>配置管理员的主要职责 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">制定配置管理计划；</span><br><span class="line">识别配置项；</span><br><span class="line">定义基线；</span><br><span class="line">定义配置库结构；</span><br><span class="line">管理、备份配置库；</span><br><span class="line">控制变更；</span><br><span class="line">生成配置管理状态报告；</span><br><span class="line">对项目成员进行配置管理培训</span><br></pre></td></tr></table></figure></p></li><li><p>配置项标示的规则，什么情况下改写Vx.y.z中的x和y？什么说情况下改写z？规则是怎样的 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">级别不同，修改不同。处于开发阶段只能改z，如果过了评审则由配置管理员改x，y。如果是比较小的变更处在一条基线上的话只改y，如果进行大规模的变更的话改x</span><br></pre></td></tr></table></figure></p></li><li><p>配置管理系统的等级？三个概念库如何体现配置库的等级？配置库需要注意什么 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过对不同库的配置项设置不同权限体现</span><br><span class="line">三个概念库:开发库，基线库，产品库。</span><br><span class="line">开发库:由项目组内部人员进行控制，可以随意的根据自己的需要进行修改，不需要变更申请。</span><br><span class="line">基线库:由项目的配置人员进行变更，要通过变更控制流程进行修改。</span><br><span class="line">产品库:由公司的配置管理员进行修改，发布的必须由公司的配置管理员进行发布。</span><br><span class="line"></span><br><span class="line">注意点：</span><br><span class="line">配置库应该包括采购的组件</span><br><span class="line">配置库中只需要保存关键性版本不需要全部版本保存</span><br></pre></td></tr></table></figure></p></li><li><p>基线的定义和特点 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">经过正式评审并取得共识的规格说明与工作产品的集合，该集 合成为之后进一步开发的基础，并且只能通过变更控制规程才 能进行变更。</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="lv2过程与产品质量保证ppqa">Lv2过程与产品质量保证(PPQA)</h3><blockquote><p><strong>目的</strong>: 向员工与管理层提供对过程及其相关工作产品的客观洞察。</p><p><strong>概要</strong></p><ul><li>SG 1 客观评价过程与工作产品<ul><li>SP 1.1 客观评价过程</li><li>SP 1.2 客观评价工作产品</li></ul></li><li>SG 2 提供客观洞察<ul><li>SP 2.1 沟通并解决不符合问题</li><li>SP 2.2 建立记录</li></ul></li></ul></blockquote><ol type="1"><li><p>软件项目质量的分类 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内部、外部、使用质量，过程和产品，但绝不是绝对的过程和绝对的产品，过程质量影响产品质量，产品质量取决于过程质量，互相影响。</span><br></pre></td></tr></table></figure></p></li><li><p>QA行使的角色 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">三类:警察、医生和老师 简要说明QA工作在项目全过程的三种角色体现</span><br><span class="line">老师的角色在项目前期，QA辅助项目经理制定项目计划，包括根据质量体系中的标准过程裁剪得到项目定义的过程，帮助项目进行估算，设定质量目标等；对项目成员进行过程和规范的培训以及在过程中进行指导等。</span><br><span class="line">警察的角色在项目过程中，QA有选择性地参加项目的技术评审，定期对项目的工作产品和过程进行审计和评审。</span><br><span class="line">医生的角色在项目过程中，QA也可以承担收集、统计、分析度量数据的工作，用于支持管理决策。</span><br><span class="line"></span><br><span class="line">关注的是产品的质量吗？QA并不对最终产品的质量负责，除非质量出现问题的原因来自流程和方法。QA 只关注方法流程是否正确，并不关注测试。QA 不应是测试人员，但是许多企业都把 QA 当作测试人员。</span><br></pre></td></tr></table></figure></p></li><li><p>解释 PPQA QA SQA NC QC OE <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PPQA:产品过程质量保证过程域</span><br><span class="line">QA:质量保证专员，质量保证学科</span><br><span class="line">SQA:软件的质量保证专员，软件质量保证</span><br><span class="line">NC:不符合项</span><br><span class="line">QC:质量控制</span><br><span class="line">OE:客观评价</span><br></pre></td></tr></table></figure></p></li><li><p>QA 和 QC差别？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QA 是质量保证，QC是质量控制 </span><br><span class="line">质量控制是质量保证的重要手段，质量控制是质量保证的一个部分，但是质量控制是发现问题的时候要去纠正的重要手段。</span><br></pre></td></tr></table></figure></p></li><li><p>执行PPQA的工具方法 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">评审、审计、checklist、因果图、饼图</span><br></pre></td></tr></table></figure></p></li><li><p>简述评审一般过程、审计一般过程 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)评审一般过程:</span><br><span class="line">1.前期准备:提前发资料，提前预审并提出问题!</span><br><span class="line">2.执行评审，怎么执行:采用检查单,不迟到，要签到。跑题不要太远</span><br><span class="line">3.评审过程怎么进行:进行度量、统计效率</span><br><span class="line">4.评审结束:记录表现</span><br><span class="line">(2)执行过程审计一般过程</span><br><span class="line">准备:选PA，检查单，计划，评审</span><br><span class="line">执行:审计，初步沟通，建议</span><br><span class="line">评审和审计活动以检查工作产品和访谈作为主要工作来源，估算过程，进行访谈，访谈步骤，检查文档结果</span><br><span class="line">后期:最终报告，跟踪NC，提供建议</span><br></pre></td></tr></table></figure></p></li><li><p>QA人员以及PPQA过程的质量保证如何实现 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QA要形成质量记录，由QA的经理来进行审查</span><br><span class="line">PPQA过程也要形成记录</span><br><span class="line"></span><br><span class="line">保证客观性。QA 人员往往是独立于开发部门的，以此来确保 QA 人员敢于指出问题。</span><br><span class="line">尽可能把审查做成检查表，以此来消除主观性。</span><br></pre></td></tr></table></figure></p></li><li><p>如何评价"测试驱动开发TDD可以显著提升质量"这一说法 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TDD不应该能给质量带来显著提升，如果这个提升十分显著，那么就说明之前的单元测试做的是有问题的。</span><br></pre></td></tr></table></figure></p></li><li><p>PPQA 的关注点 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PPQA 关注做的与规定的流程是否是否一致，不是最终产品的质量</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="lv3决策分析与解决dar">Lv3决策分析与解决(DAR)</h3><blockquote><p><strong>目的</strong>: 使用正式的评价过程，遵循已建立的准则，对已识别的多个备选方案进行评价，以分析可能的决策。</p><p><strong>概要</strong></p><ul><li>SG 1 评价备选方案<ul><li>SP 1.1 建立决策分析指南</li><li>SP 1.2 建立评价准则</li><li>SP 1.3 识别备选解决方案</li><li>SP 1.4 选择评价方法</li><li>SP 1.5 评价备选解决方案</li><li>SP 1.6 选择解决方案</li></ul></li></ul></blockquote><ol type="1"><li><p>DAR 适用于哪些场景 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">具有多种备选方案并具有评价准则的各类问题均适合采用正式评价过程</span><br></pre></td></tr></table></figure></p></li><li><p>选择备选方案的时候还需要注意什么 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择解决方案包括对备选方案的评价结果进行权衡考虑。应评估实施解决方案的关联风险。</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="lv5原因分析与解决car">Lv5原因分析与解决(CAR)</h3><blockquote><p><strong>目的</strong>: 识别所选结果的原因并采取行动，以改进过程性能。</p><p><strong>概要</strong></p><ul><li>SG 1 确定所选结果的原因<ul><li>SP 1.1 选择需要加以分析的结果</li><li>SP 1.2 分析原因</li></ul></li><li>SG 2 处理所选结果的原因<ul><li>SP 2.1 实施行动提议</li><li>SP 2.2 评价已实施行动的效果</li><li>SP 2.3 记录原因分析的数据</li></ul></li></ul></blockquote><ol type="1"><li><p>CAR 在本质上做的是什么 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CAR 认为不犯错比犯了错再改正更好。</span><br><span class="line">当有问题出现的时候找到问题的根本原因，并且预防这些问题的再次发生。</span><br><span class="line">CAR 是具有前瞻性质的，它可以主动分析以前的数据识别潜在问题并预防其发生。</span><br><span class="line">并且在文档中提到，CAR 发生在项目的每个阶段是更为有效的做法。</span><br><span class="line">除此之外 CAR 还可以将成功的原因纳入过程，将这些经验在组织内进行传递，以改进将来的过程性能。</span><br></pre></td></tr></table></figure></p></li><li><p>CAR 在4级和5级的不同 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4级主要排除因为特殊原因引起的问题，5级排除真正普适的根因</span><br></pre></td></tr></table></figure></p></li><li><p>CAR 为什么需要和 OPM 配合</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为5级的CAR不能做非常粗糙的改进，而是需要细化的改进，OPM 可以量化这个过程</span><br></pre></td></tr></table></figure><hr /><h1 id="ppt-中问题整理">PPT 中问题整理</h1><ol type="1"><li>Requirements Management <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Which of the following examples of requirements traceability are adequate?</span><br><span class="line"></span><br><span class="line">1. Customer requirements to system requirements and vice versa, but no other traceability</span><br><span class="line"></span><br><span class="line">2. System requirements to software and hardware requirements and vice versa, but no other traceability</span><br><span class="line"></span><br><span class="line">3. Software and hardware requirements to design components and test cases and vice versa, but no other traceability</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>此处系统需求等同于产品需求，软、硬件需求等同于产品组件需求。 和项目的上下文、粒度综合起来看，没有标准答案</p></blockquote><ol start="2" type="1"><li>Project Planing <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PASS is planning their resources. What project resources should be included?</span><br><span class="line"></span><br><span class="line">• Tools</span><br><span class="line">• Budget and funding</span><br><span class="line">• Staff</span><br><span class="line">• Project plans</span><br><span class="line">• Facilities</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>项目计划不是资源，其余都是。因为资源需要被安排到计划中</p></blockquote><ol start="3" type="1"><li>Project Management and Control <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Project Problems</span><br><span class="line">1) People are not showing up at peer review meetings.</span><br><span class="line">2) Actual costs continually exceed planned costs.</span><br><span class="line">3) People are delinquent on their action items.</span><br><span class="line">4) Management does not know PASS status.</span><br><span class="line">5) People are not meeting schedules.</span><br><span class="line"></span><br><span class="line">PMC SPs</span><br><span class="line">a) SP 1.1 Monitor Project Planning Parameters</span><br><span class="line">b) SP 1.2 Monitor Commitments</span><br><span class="line">c) SP 1.5 Monitor Stakeholder Involvement</span><br><span class="line">d) SP 1.6 Conduct Progress Reviews</span><br><span class="line">e) SP 2.3 Manage Corrective Action</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>1-c 2-a 3-e 4-d 5-b</p></blockquote><ol start="4" type="1"><li>Risk Management <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. PASS identified risks associated with their suppliers.</span><br><span class="line">2. Risks were grouped by likelihood of occurrence and impact.</span><br><span class="line">3. PASS identified risks associated with innovative technology.</span><br><span class="line">4. Impact can be high, medium, or low.</span><br><span class="line">5. At the risk management meeting, the status of some risks were changed to retired, mitigated, or closed.</span><br><span class="line"></span><br><span class="line">a) Risk source</span><br><span class="line">b) Risk category</span><br><span class="line">c) Risk parameter</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>13-a 2-b 45-c</p></blockquote><ol start="5" type="1"><li>Supplier Agreement Management <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PASS uses a supplier for motion sensors. Match PASS sample activities to SAM SPs.</span><br><span class="line"></span><br><span class="line">Sample Activities</span><br><span class="line">1) PASS wrote a contract with DetectEx.</span><br><span class="line">2) Supplier motion sensors were sent to integration and testing.</span><br><span class="line">3) A trade study conducted by PASS selected DetectEx for motion sensors.</span><br><span class="line">4) The motion sensors passed acceptance criteria.</span><br><span class="line">5) COTS were used for the keypad; sensors were secured from suppliers; and the controller consists of re-used PASS in-house software.</span><br><span class="line"></span><br><span class="line">SAM SPs</span><br><span class="line">a) SP 1.1 Determine Acquisition Type</span><br><span class="line">b) SP 1.2 Select Suppliers</span><br><span class="line">c) SP 1.3 Establish Supplier Agreements</span><br><span class="line">d) SP 2.2 Accept the Acquired Product</span><br><span class="line">e) SP 2.3 Ensure Transition of Products</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>1-c 2-e 3-b 4-d 5-a</p></blockquote><ol start="6" type="1"><li>Configuration Management <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Which CM SPs could have prevented the problem?</span><br><span class="line"></span><br><span class="line">PASS delivered updated software to SaveAll. SaveAll wanted to know what changed, but PASS wasn’t sure because change request records were incomplete.</span><br><span class="line"></span><br><span class="line">1. SP 1.1 Identify Configuration Items</span><br><span class="line">2. SP 1.2 Establish a Configuration Management System</span><br><span class="line">3. SP 1.3 Create or Release Baselines</span><br><span class="line">4. SP 2.1 Track Change Requests</span><br><span class="line">5. SP 2.2 Control Configuration Items</span><br><span class="line">6. SP 3.1 Establish Configuration Management Records</span><br><span class="line">7. SP 3.2 Perform Configuration Audits</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>全都是</p></blockquote><ol start="7" type="1"><li>Process and Product Quality Assurance <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Which are process evaluations? Which are product evaluations?</span><br><span class="line">1. QA attends a peer review and mentions there should be an attendance sheet.</span><br><span class="line">2. QA watches the engineers assemble a security system and notices a component was put in the wrong place.</span><br><span class="line">3. QA reviews the requirements and notices a missing requirement.</span><br><span class="line">4. QA reviews the design and notices some engineering drawings are missing.</span><br><span class="line">5. QA notices that the test group does not always fill out problem reports.</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>正确答案是1，2，3，4，5，过程和产品都是有可能的</p></blockquote><ol start="8" type="1"><li>Verification <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Which of the following are adequate for verification procedures and criteria?</span><br><span class="line"></span><br><span class="line">1. Peer review criteria that says, “Ensure products are complete, consistent, and correct.”</span><br><span class="line">2. Checklists for peer reviews</span><br><span class="line">3. A test procedure that lists test steps and how to judge whether each test step passed or failed</span><br><span class="line">4. A procedure on how to do the verification process</span><br><span class="line">5. A procedure on how to do peer reviews</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>没有一个标准答案，主要是依据项目的情况来看的。例如第二点，对一个大的项目，有很多专家来进行评审，一个检查表反而可能产生疏漏</p></blockquote><ol start="9" type="1"><li>Validation <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Which are verification and which are validation?</span><br><span class="line"></span><br><span class="line">1. PASS conducts a formal design review with SaveAll.</span><br><span class="line">2. PASS has a peer review with the systems engineers, software engineers, and QA.</span><br><span class="line">3. PASS demonstrates a prototype to SaveAll to get their feedback.</span><br><span class="line">4. PASS formally tests the product prior to delivery with both SaveAll and QA witnessing the test.</span><br><span class="line">5. PASS integrates the components and tests the system.</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>都有可能。5在大多数情况下是VER，如果考虑环境因素VAL。需要看在哪个阶段，大部分的时候集成了之后还有下一次迭代，这个时候是工作产品，所以是VER。而如果没有下一个迭代直接交给用户这个时候就是交产品，所以是VAL。</p></blockquote><ol start="10" type="1"><li>Organizational Process Focus <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Which of the following show incorporating experiences?</span><br><span class="line"></span><br><span class="line">1. PASS Process Group (PG) updates a policy based on feedback from projects at a monthly meeting.</span><br><span class="line">2. PASS PG notices a process step was poorly written and corrects it.</span><br><span class="line">3. PASS PG looks at how projects are using the templates and updates the templates.</span><br><span class="line">4. PASS PG improves the standard processes after analyzing appraisal metrics.</span><br><span class="line">5. PASS PG updates a process because of information found on the internet.</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>属于:1 3 4</p><p>不属于:2 5</p><p>2:如果是因为项目团队用了觉得写的不清晰:属于。大部分情况:不属于</p><p>3:根据别人使用的结果做修正、更新</p></blockquote><ol start="11" type="1"><li>Integrated Project Management <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Which PASS scenarios align with IPM?</span><br><span class="line"></span><br><span class="line">1. All PASS projects follow the standard process exactly as is.</span><br><span class="line">2. Projects can use their own processes and trace them to the PASS standard process.</span><br><span class="line">3. PASS provides a standard process and rules for tailoring.</span><br><span class="line">4. Once projects tailor the PASS standard process, it is called the projects’ standard process.</span><br><span class="line">5. If the customer says eliminate QA, but the standard process requires QA with no tailoring, it’s okay for PASS projects to tailor out QA to satisfy the customer.</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>234</p><p>1 是可以定制化的</p><p>5 某个SP中规定必须要有QA，所以QA必须有</p></blockquote><ol start="12" type="1"><li>Organizational Process Definition <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Match sample artifacts with OPD SPs.</span><br><span class="line"></span><br><span class="line">Sample Artifacts</span><br><span class="line"></span><br><span class="line">1) Instructions for when a process step can be deleted or modified</span><br><span class="line">2) Website for tools, templates, project examples, etc.</span><br><span class="line">3) Standard software that comes with all company computers</span><br><span class="line">4) Spiral lifecycle description</span><br><span class="line">5) Requirements process</span><br><span class="line"></span><br><span class="line">OPD SPs</span><br><span class="line"></span><br><span class="line">a) SP 1.1 Establish Standard Processes</span><br><span class="line">b) SP 1.2 Establish Lifecycle Model Descriptions</span><br><span class="line">c) SP 1.3 Establish Tailoring Criteria and Guidelines</span><br><span class="line">d) SP 1.5 Establish the Organization’s Process Assets Library</span><br><span class="line">e) SP 1.6 Establish Work Environment Standards</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>1-c 2-d 3-e 4-b 5-a</p></blockquote><ol start="13" type="1"><li>Organizational Training <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Match sample artifacts with OT SPs.</span><br><span class="line"></span><br><span class="line">Sample Artifacts</span><br><span class="line"></span><br><span class="line">1) Training classrooms</span><br><span class="line">2) Plan for 3-5 years in the future</span><br><span class="line">3) Analysis of course evaluations</span><br><span class="line">4) Plan that states PASS, not projects, will provide risk tool training</span><br><span class="line">5) Plan for the next year</span><br><span class="line"></span><br><span class="line">OT SPs</span><br><span class="line"></span><br><span class="line">a) SP 1.1 Establish Strategic Training Needs</span><br><span class="line">b) SP 1.2 Determine Which Training Needs are the Responsibility of the Organization</span><br><span class="line">c) SP 1.3 Establish an Organizational Training Tactical Plan</span><br><span class="line">d) SP 1.4 Establish a Training Capability</span><br><span class="line">e) SP 2.3 Assess Training Effectiveness</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>1-d 2-a 3-e 4-b 5-c</p></blockquote><ol start="14" type="1"><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">量化的过程性能目标包括了质量，然而，为强调质量在CMMI产品套件中的重要性，在CMMI中使用“质量与过程性能目标”一词。在哪个地方也出现了其实不是并列关系，实际上是包含关系，仅仅是因为比较重要，所以拿出来说的情况</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>VER SG2 SG3:SG3包含SG2</p><p>同行评审只是一种验证的手段，但是太过重要所以放到了标准流程里面</p></blockquote><ol type="1"><li>持续集成 vs 大爆炸集成</li></ol><blockquote><p>大爆炸</p><p>问题：定位错误、查找错误困难</p><p>好处：如果模块质量高，这是最有效的集成方式</p><p>持续集成：</p><p>好处：定位错误简单</p><p>问题：代价较高（同一个测试用例会反复测试）</p><p>通过自动化手段缓解代价较高的问题</p><p>部分测试无法自动化实现，所以不可能持续集成完直接上线（持续集成无法代替集成测试）</p></blockquote><h1 id="说人话版本的过程域描述">说人话版本的过程域描述</h1><h2 id="opd">OPD</h2><table><thead><tr class="header"><th>目标与实践</th><th>详细</th><th>人话</th></tr></thead><tbody><tr class="odd"><td><strong>SG</strong> 1 建立组织级过程资产</td><td>一套组织级过程资产得到建立和维护</td><td></td></tr><tr class="even"><td>SP 1.1 建立标准过程</td><td>建立并为维护组织的标准过程集</td><td></td></tr><tr class="odd"><td>SP 1.2 建立生命周期模型描述</td><td>建立并维护得到批准在组织中使用的生命周期模型的描述</td><td>不同客户不同场景下用什么生命周期模型</td></tr><tr class="even"><td>SP 1.3 建立裁剪准则与指南</td><td>建立并维护组织标准过程集的裁剪标准与指南</td><td>防止乱用</td></tr><tr class="odd"><td>SP 1.4 建立组织的度量库</td><td>建立并维护组织的度量库</td><td></td></tr><tr class="even"><td>SP 1.5 建立组织的过程资产库</td><td>建立并维护组织的过程资产库</td><td>保存通用的度量项和数据，用来支持其他过程，见p163</td></tr><tr class="odd"><td>SP 1.6 建立工作环境标准</td><td>建立并维护工作环境标准</td><td></td></tr><tr class="even"><td>SP 1.7 建立团队的规则与指南</td><td>建立并维护团队的结构、组建与运作的组织级规则与指南</td><td></td></tr></tbody></table><h2 id="opf">OPF</h2><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>目标与实践</th><th>详细</th><th>人话</th></tr></thead><tbody><tr class="odd"><td><strong>SG</strong> 1 确定过程改进机会</td><td>组织过程的强项、弱项与改进机会定期的以及在必要时得到识别</td><td></td></tr><tr class="even"><td>SP 1.1 建立组织级过程需要</td><td>建立并维护组织过程与需要的描述</td><td>对过程改进提出需求，希望做到什么地步，也就有了强弱的概念</td></tr><tr class="odd"><td>SP 1.2 评估组织的过程</td><td>定期以及在必要时，对组织的过程进行评估，以维护其强项与弱项的理解</td><td></td></tr><tr class="even"><td>SP 1.3 识别组织的过程改进</td><td>识别组织的过程与过程资产的改进</td><td>看哪些过程可以改进，排优先级，然后文档化</td></tr><tr class="odd"><td><strong>SG</strong> 2 计划并实施过程行动</td><td>过程行动得到计划与实施，以应对组织的过程与过程资产的改进。改进的成功实施需要过程负责人、执行过程的人以及支持组织</td><td></td></tr><tr class="even"><td>SP 2.1 建立过程行动计划</td><td>建立并维护过程行动计划，以应对组织的过程与过程资产的改进。</td><td>计划怎么改</td></tr><tr class="odd"><td>SP 2.2 实施过程行动计划</td><td>实施过程行动计划。</td><td>前期工作 + 试点</td></tr><tr class="even"><td><strong>SG</strong> 3 部署组织级过程资产并纳入经验</td><td>组织级过程资产在组织内得到全面部署，并且与过程相关的经验得以纳入组织级过程资产。</td><td></td></tr><tr class="odd"><td>SP 3.1 部署组织级过程资产</td><td>在组织内全面部署组织级过程资产。</td><td>比如规格约定了sonarqube能用，必须用，3.1就是部署sonarqube，让它真正能使用</td></tr><tr class="even"><td>SP 3.2 部署标准过程</td><td>在项目启动时，向其部署组织的标准过程集；并且在每个项目的整个生命期中，适当向其部署变更。</td><td>相当于定期git pull进行版本更新，把新的经验和教训再应用到项目中</td></tr><tr class="odd"><td>SP 3.3 监督实施</td><td>监督所有项目中组织标准过程集的实施与过程资产的使用。</td><td></td></tr><tr class="even"><td>SP 3.4 将经验纳入到组织级过程资产中</td><td>将源于过程的计划与执行的、与过程相关的经验纳入组织级过程资产。</td><td></td></tr></tbody></table><h2 id="opp">OPP</h2><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>目标与实践</th><th>详细</th><th>人话</th></tr></thead><tbody><tr class="odd"><td><strong>SG</strong> 1 建立性能基线与模型</td><td>描述组织标准过程集所期望过程性能特征的基线与模型得到建立与维护。</td><td></td></tr><tr class="even"><td>SP 1.1 建立质量与过程性能目标</td><td>建立并维护组织的质量与过程性能量化目标，这些目标可追溯到业务目标。</td><td>度量过程之后的目的，希望为业务目标做什么贡献</td></tr><tr class="odd"><td>SP 1.2 选择过程</td><td>在组织标准过程集中选择将要纳入组织过程性能分析的过程或子过程，并维护与业务目标的可追溯性。</td><td>哪些过程适合度量</td></tr><tr class="even"><td>SP 1.3 建立过程性能度量项</td><td>建立并维护纳入组织过程性能分析中的度量项定义。</td><td>被选择的过程中哪些属性会影响目标的实现</td></tr><tr class="odd"><td>SP 1.4 分析过程性能并建立过程性能基线</td><td>分析所选定过程的性能，以及建立并维护过程性能基线。</td><td>分析这些属性，设立一个期待达成的目标</td></tr><tr class="even"><td>SP 1.5 建立过程性能模型</td><td>为组织的标准过程集建立并维护过程性能模型。</td><td>建模，根据以前的、现在的数据预测能否达成这个目标</td></tr></tbody></table><h2 id="ipm">IPM</h2><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>目标与实践</th><th>详细</th><th>人话</th></tr></thead><tbody><tr class="odd"><td><strong>SG</strong> 1 使用项目已定义的过程</td><td>项目的进行得以使用从组织标准过程集裁剪得到的已定义的过程。</td><td></td></tr><tr class="even"><td>SP 1.1 建立项目已定义的过程</td><td>从项目启动开始并贯穿项目生命期的始终，建立并维护项目已定义的过程。</td><td>根据组织里的规定，把组织需要的过程应用在某个项目上</td></tr><tr class="odd"><td>SP 1.2 使用组织级过程资产计划项目活动</td><td>使用组织级过程资产与度量库来估算并计划项目活动。</td><td>按组织统一规定的文档要求、度量要求来估算项目</td></tr><tr class="even"><td>SP 1.3 建立项目工作环境</td><td>基于组织的工作环境标准，建立并维护项目的工作环境。</td><td>让工具、人员都到位，满足规定的开发要求</td></tr><tr class="odd"><td>SP 1.4 集成各类计划</td><td>集成项目计划与影响项目的其它计划，以描述项目已定义的过程。</td><td></td></tr><tr class="even"><td>SP 1.5 使用集成的计划管理项目</td><td>使用项目计划、影响项目的其它计划以及项目已定义的过程来管理项目。</td><td>根据和计划规定完成相关过程，做该做的事并好好做</td></tr><tr class="odd"><td>SP 1.6 建立团队</td><td>建立并维护团队。</td><td></td></tr><tr class="even"><td>SP 1.7 为组织级过程资产做出贡献</td><td>将过程相关经验贡献给组织级过程资产。</td><td>好的坏的经验都上报组织</td></tr><tr class="odd"><td><strong>SG</strong> 2 与相关干系人协调并协作</td><td>项目与项目相关干系人之间的协调与协作得到开展。</td><td></td></tr><tr class="even"><td>SP 2.1 管理干系人的参与</td><td>管理相关干系人在项目中的参与。</td><td></td></tr><tr class="odd"><td>SP 2.2 管理依赖</td><td>与相关干系人共同识别、协商并跟踪关键依赖。</td><td></td></tr><tr class="even"><td>SP 2.3 解决协调问题</td><td>与相关干系人共同解决问题。</td><td></td></tr></tbody></table><h2 id="ma">MA</h2><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>目标与实践</th><th>详细</th><th>人话</th></tr></thead><tbody><tr class="odd"><td><strong>SG</strong> 1 使度量与分析活动协调一致</td><td>度量目标和活动与所识别的信息需要和目标协调一致。</td><td></td></tr><tr class="even"><td>SP 1.1 建立度量目标</td><td>建立并维护从所识别的信息需要与目标中导出的度量目标。</td><td>确定为什么要做度量，意义是什么，能帮助做什么决策。一般这个是为了满足组织和项目的业务目标而服务的。</td></tr><tr class="odd"><td>SP 1.2 明确说明度量项</td><td>明确说明应对度量目标的度量项。</td><td>需要度量哪些东西</td></tr><tr class="even"><td>SP 1.3 明确说明数据收集与存储的规程</td><td>明确说明如何获得并存储度量数据。</td><td></td></tr><tr class="odd"><td>SP 1.4 明确说明分析规程</td><td>明确说明如何分析并沟通度量数据。</td><td></td></tr><tr class="even"><td><strong>SG</strong> 2 提供度量结果</td><td>应对所识别的信息需要与目标的度量结果得到提供。</td><td></td></tr><tr class="odd"><td>SP 2.1 获得度量数据</td><td>获得规定的度量数据。</td><td></td></tr><tr class="even"><td>SP 2.2 分析度量数据</td><td>分析并解释度量数据。</td><td></td></tr><tr class="odd"><td>SP 2.3 存储数据与结果</td><td>管理并存储度量数据、度量规格说明与分析结果。</td><td></td></tr><tr class="even"><td>SP 2.4 沟通结果</td><td>与所有相关干系人沟通度量与分析活动的结果。</td><td>反馈结果并让他们理解结果</td></tr></tbody></table><h2 id="cm">CM</h2><table><thead><tr class="header"><th>目标与实践</th><th>详细</th><th>人话</th></tr></thead><tbody><tr class="odd"><td><strong>SG</strong> 1 建立基线</td><td>所识别的工作产品的基线得到建立。</td><td></td></tr><tr class="even"><td>SP 1.1 识别配置项</td><td>识别将置于配置管理下的配置项、组件与相关的工作产品。</td><td>识别哪些是需要被管理起来的东西</td></tr><tr class="odd"><td>SP 1.2 建立配置管理系统</td><td>建立并维护用于控制工作产品的配置管理与变更管理系统。</td><td>例如对代码用git，例如对变更请求本身也创建数据库</td></tr><tr class="even"><td>SP 1.3 创建或发布基线</td><td>创建或发布供内部使用以及交付给客户的基线。</td><td>在某个时间点，赋予特定版本的工作产品的集合一个标识符</td></tr><tr class="odd"><td><strong>SG</strong> 2 跟踪并控制变更</td><td>置于配置管理下的工作产品的变更得到跟踪与控制。</td><td></td></tr><tr class="even"><td>SP 2.1 跟踪变更请求</td><td>跟踪对配置项的变更请求。</td><td>分析并评估这些请求，一直关注这些请求直到处理结束</td></tr><tr class="odd"><td>SP 2.2 控制配置项</td><td>控制配置项的变更。</td><td>有了请求的变更之后，配置项也会有变化，基线也可能会发生变化。那么就控制和跟踪这些变化</td></tr><tr class="even"><td><strong>SG</strong> 3 建立完整性</td><td>基线的完整性得到建立与维护。</td><td></td></tr><tr class="odd"><td>SP 3.1 建立配置管理记录</td><td>建立并维护描述配置项的记录。</td><td>把 2.1 2.2 的过程文档化并及时更新</td></tr><tr class="even"><td>SP 3.2 执行配置审计</td><td>执行配置审计，以维护配置基线的完整性。</td><td>确保配置符合需求并且这些信息是准确完备一致的</td></tr></tbody></table><!-- # 变更记录|日期|内容||---|---||4.14|发布第二版||4.15|DAR新增一个知识点、对VER VAL的比较进行了补充、增加课堂提问“持续集成vs大爆炸集成”、REQM中新增知识点双向可跟踪、补充了对目标概览图作用的说明||4.16|PMC、MA、PPQA、TS、DAR、CAR新增知识点、CMMI与过程部分增加很多知识点||4.19|修正了 TS 过程域中的错误描述、增加了对每个过程域说人话的描述||4.20|完善大部分内容| -->]]></content>
    
    <summary type="html">
    
      软件过程改进课堂笔记
    
    </summary>
    
    
    
      <category term="lecture" scheme="https://wym0120.github.io/tags/lecture/"/>
    
  </entry>
  
  <entry>
    <title>[ISER] [STA] Bugs as deviant behavior: A general approach to inferring errors in systems code</title>
    <link href="https://wym0120.github.io/2021/04/12/paper/ISER/Software%20Testing%20and%20Analysis/sta-2/"/>
    <id>https://wym0120.github.io/2021/04/12/paper/ISER/Software%20Testing%20and%20Analysis/sta-2/</id>
    <published>2021-04-12T15:01:26.110Z</published>
    <updated>2021-04-12T15:01:26.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote><p>A major obstacle to finding program errors in a real system is knowing what correctness rules the system must obey. These rules are often undocumented or specified in an ad hoc manner. This paper demonstrates techniques that automatically extract such checking information from the source code itself, rather than the programmer, thereby avoiding the need for a priori knowledge of system rules.</p></blockquote><blockquote><p>The cornerstone of our approach is inferring programmer "beliefs" that we then crosscheck for contra dictions. Beliefs are facts implied by code: a dereference of a pointer, p, implies a belief that p is nonnull, a call to "tmlock(1)" implies that 1 was locked, etc. For be liefs we know the programmer must hold, such as the pointer dereference above, we immediately flag contra dictions as errors. For beliefs that the programmer may hold, we can assume these beliefs hold and use a statistical analysis to rank the resulting errors from most to least likely. For example, a call to "spin_lock" followed once by a call to "spin_tmlock" implies that the programmer may have paired these calls by coincidence.</p></blockquote><blockquote><p>If the pairing happens 999 out of 1000 times, though, then it is probably a valid belief and the sole deviation a probable error. The key feature of this approach is that it requires no a priori knowledge of truth: if two beliefs contradict, we know that one is an error without knowing what the correct belief is. Conceptually, our checkers extract beliefs by tailor ing rule "templates" to a system for example, finding all functions that fit the rule template "&lt;a&gt; must be paired with &lt; b&gt;." We have developed six checkers that follow this conceptual framework. They find hundreds of bugs in real systems such as Linux and OpenBSD. From our experience, they give a dramatic reduction in the manual effort needed to check a large system. Com pared to our previous work , these template checkers find ten to one hundred times more rule instances and derive properties we found impractical to specify manually.</p></blockquote><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><p>这篇文章基于的一个假设是人是很难寻找和归纳出对于一个程序什么是必须遵循的正确的法则，什么是应该遵循的法则。这并不是指人不能总结出一些法则，而是说在编码过程中很难强制机器去遵守。因此，希望能够自动提取出某段特定代码应该有什么样的约束，例如在使用指针的时候指针指向的对象必须非空，例如lock和unlock应该要成对出现。而在静态检查的过程中如果发现代码违背了这些最基本的一些应该遵守的法则，那么就认为是一个可能的错误。 ### Evalution</p><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      Dawson Engler, David Yu Chen, Seth Hallem, Andy Chou, and Benjamin Chelf. Bugs as deviant behavior: A general approach to inferring errors in systems code. SOSP&#39;01
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Testing and Analysis" scheme="https://wym0120.github.io/tags/Software-Testing-and-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>How to write and publish technical papers in English</title>
    <link href="https://wym0120.github.io/2021/04/08/report/english-writing/"/>
    <id>https://wym0120.github.io/2021/04/08/report/english-writing/</id>
    <published>2021-04-08T08:00:41.000Z</published>
    <updated>2021-04-12T15:01:26.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="paper">Paper</h3><h4 id="title">Title</h4><ul><li>Use fewest possible words</li><li>Adequately describe the contents of the paper</li><li>To be read by thousands of people. Few may read the entire paper.</li><li>Choose all words in the title with great care</li><li>Carefully manage their association from one with each other</li></ul><h4 id="abstract">Abstract</h4><ul><li>A sumary of the information in a document</li><li>A single paragraph of 100-200 words</li><li>Self contained, no bibliographic, figure, or table references</li><li>No obscure abbreviations and acronyms</li><li>Write the paper before writing the Abstarct</li></ul><h4 id="introduction">Introduction</h4><ul><li>Answer the question "What was the problem?" Why is it important</li><li>Supply sufficient background information to allow the reader to understand and evaluate the results of the present study without needing to refer to previous on the topic.</li><li>Provide the rationale for the present study (e.g. a motivating example).</li><li>State briefly and clearly your purpose in writing the paper and <strong>your contributions</strong>.</li><li>Choose references carefully to provide the most important background infomation.</li></ul><h4 id="results">Results</h4><ul><li>Answer the question "What did you find?"</li><li>Experimental performance evaluation for system work</li><li>Empirical study for user interaction work</li><li>Complexity analysis for algorithm work</li><li>Case studies with real world applications</li></ul><h4 id="discussion">Discussion</h4><ul><li>Answer the question "What do these findings mean?"</li></ul><h4 id="related-work">Related Work</h4><ul><li>Review most relevant work</li><li>Comment on the similarity and differences of your work from them</li><li>What makes your work unique and worth doing?</li><li>Usually as Section 2, or second last section</li></ul><h4 id="conclusion-and-future-work">Conclusion and Future Work</h4><ul><li>Answer the question "What do you conclude?"</li><li>What actions need to be taken as future work?</li><li>Any discussion of controversial issues</li></ul><h4 id="acknowledgements">Acknowledgements</h4><ul><li>Give credit to individuals who have helped you</li><li>Acknowledge funding agencies that have partially supported your work</li></ul><h4 id="references">References</h4><ul><li>Use statndard bibliographic style</li><li>Be complete and consistent with sytle</li><li>Use more recent and more influential papers</li></ul><h3 id="practices">Practices</h3><ul><li>Read as many good papers as possible</li><li><strong>Adapt</strong> good sense of writing from good papers</li><li>Write as many papers (in English) as possible</li><li>Be serious with reviewers' comments and learn from them</li><li>Collaborate with other researchers</li><li>Volunteer to review papers</li></ul><h3 id="specific-rules">Specific Rules</h3><ul><li>A sentence should be under 3 lines in a single column or 5 lines in a double-column.</li><li>Without comparison, do not use "more" or "less"</li><li>Issues on passive voice ...<ul><li>避免被动语态除非主语很明确，可以给系统一个名字让系统作为主语</li><li>不要总是用 "we"，可以加上半句 "Having done this, we decide ..."</li></ul></li><li>Issues on tense ...<ul><li>过去时态用于描述过去的一个工作</li><li>将来时态只用在 future work 中</li><li>完成时只用在 conclusion 中</li></ul></li><li>Typical Chinglish<ul><li>A lot of -&gt; <strong>Many or Much</strong></li><li>Actually -&gt; <strong>In fact</strong></li><li>Based on -&gt; <strong>unnecessary in many contexts</strong></li><li>Be considered as -&gt; <strong>Be considered</strong></li><li>Besides -&gt; <strong>Apart from (和 Except 不一样，后者是不包含， Except for 也是错误用法)</strong></li><li>Especially -&gt; <strong>Particularly, or In particular</strong></li><li>Firstly, ..., Secondly -&gt; <strong>First, ..., Second -&gt; Bullet list</strong></li><li>For "A" (noun), we (verb) it -&gt; <strong>We (verb) "A"</strong></li><li>Kind of -&gt; <strong>Type of</strong></li><li>Not only A, but also B -&gt; <strong>除非真的想强调A和B不可或缺且互补，否则用and</strong></li><li>Painted with red color -&gt; <strong>Colored red</strong></li><li>Researches -&gt; <strong>只有 Researchers 或者 Research</strong></li><li>Some -&gt; <strong>你想说某些，因为你不知道哪些，所以delete它 (避免不能精确的字)</strong></li><li>Very -&gt; <strong>delete it!</strong></li><li>Want -&gt; <strong>Wish</strong></li><li>We can see from Figure X that -&gt; <strong>Figure X shows that</strong></li><li>Whole -&gt; <strong>Entire</strong></li></ul></li><li>Common Phrases and Suggested Subsitutes<ul><li>For the reason why -&gt; <strong>Why</strong></li><li>Starting a sentence with "And" -&gt; <strong>delete "And"</strong></li><li>The authors are unaware of the fact that -&gt; <strong>The authors are unaware that</strong></li><li>Their alogorithm is a fast one -&gt; <strong>Their alogorithm is fast</strong></li><li>Try to -&gt; <strong>Attempt to</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      How to write and publish technical papers in English
    
    </summary>
    
    
    
      <category term="writing" scheme="https://wym0120.github.io/tags/writing/"/>
    
      <category term="english" scheme="https://wym0120.github.io/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>[Lecture Notes] Software Architecture</title>
    <link href="https://wym0120.github.io/2020/12/17/lecture/software-architecture/SA-notes/"/>
    <id>https://wym0120.github.io/2020/12/17/lecture/software-architecture/SA-notes/</id>
    <published>2020-12-17T10:39:11.000Z</published>
    <updated>2021-04-19T09:10:31.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>科学和工程的本质区别：是否有人的参与。工程的本质上是改变这个世界</p><p>软件架构两个定义之间的区别与联系：SEI和IEEE的定义基本相同，IEEE更为宽泛，而多的定义是与外部环境的交互以及设计演进的指导原则。</p><p>为什么在设计当中需要抽象？</p><p>Use Case 会把四个视图结合起来</p><h2 id="chapter1">chapter1</h2><p>正确的设计顺序： constarins -&gt; quality attributes -&gt; functionalty attributes</p><h3 id="quality-attributes-and-tactics">Quality Attributes And Tactics</h3><h4 id="availability">Availability</h4><p>描述 availability -&gt; 使用时间</p><p>------------------------------------------------&gt; timeline ↑ ↑ ↑ ↑ failure detect correct restart Mean time between failures : restart - failure 高可用性：上面的三段时间都尽可能的小 -&gt; 缩短这些时间都可以提高可用性</p><h5 id="缩短检测时间">缩短检测时间：</h5><p>什么情况下使用ping/echo，什么情况下使用heartbeat? &gt; ping echo是双向的，heartbeat是单向的 &gt; 尽管heartbeat带宽更小，但是需要一直占用着资源，多用于长时间始终保持连接的，实时的监控 &gt; ping是只有需要的时候才去ping，不会始终占用着资源</p><p>volting:用三个detect技术来保持一致，这些detect可以用同样的实现也可以是不同的实现</p><h5 id="缩短恢复时间">缩短恢复时间</h5><p>假设有两台机器，一台是primary / secondary Active redundancy / passive redundancy / spare active : 两个都在运行，随时可以切换，两台都进行同样的工作，只是忽略备用的输出 passive : 备用机器定期同步，开着但是不会进行相同的工作 spare : 定期打primary的快照，down了之后在secondary上恢复 这三个时间会逐渐变长（本质是资源换时间） #### Reliability</p><hr /><h2 id="chapter1-software-architecture-in-general">chapter1 Software Architecture in General</h2><h2 id="chapter2-architecture-process">chapter2 Architecture Process</h2><h2 id="chapter3-quality-attributes">chapter3 Quality Attributes</h2><h2 id="chapter4-architecture-patterns">chapter4 Architecture Patterns</h2><h2 id="chapter5-designing-architecture">chapter5 Designing Architecture</h2><h2 id="chapter6-documenting-architecture">chapter6 Documenting Architecture</h2><h2 id="chapter7-evaluating-architecture">chapter7 Evaluating Architecture</h2><h2 id="chapter8-microservices-ddd">chapter8 Microservices &amp; DDD</h2>]]></content>
    
    <summary type="html">
    
      软件体系结构课堂笔记
    
    </summary>
    
    
    
      <category term="lecture notes" scheme="https://wym0120.github.io/tags/lecture-notes/"/>
    
  </entry>
  
  <entry>
    <title>transwarp-QA</title>
    <link href="https://wym0120.github.io/2020/12/08/transwarp/"/>
    <id>https://wym0120.github.io/2020/12/08/transwarp/</id>
    <published>2020-12-08T14:42:56.000Z</published>
    <updated>2021-04-12T15:01:26.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="练习题库一">练习题库(一)</h3><ol type="1"><li><p>在 HDFS 服务中，为了保证 Name Node 高可用性的角色不包括 A. Data Node☑️ B. Journal Node C. ZKFC D. Zookeeper</p></li><li><p>Namenode 在启动时自动进入安全模式，在安全模式阶段，说法错误的是 A. 安全模式目的是在系统启动时对数据有效性进行检查 B. 根据策略对数据块进行必要的复制或删除 C. 当数据块的上报数达到阈值时，会自动退出安全模式 D. 允许用户对文件系统进行读写操作☑️</p></li><li><p>在集群中配置 HDFS 的副本数为 3，设置数据块大小为 128M，此时我们上传一份 64M 的数据文件，该数据文件占用 HDFS 空间大小为 A. 64M B. 128M C. 384M☑️ D. 192M</p></li><li><p>下列对 YARN 角色在集群中的作用描述正确的是 A. 集群资源管理☑️ B. 集群任务调度与管理☑️ C. 存储部分 HDFS 上的数据块 D. 以上都正确</p></li><li><p>在 Yarn 服务中，不包含以下哪种角色 A. ResourceManager B. NodeManager C. ApplicationMaster D. Contianer☑️</p></li><li><p>下列计算框架中不属于分布式计算框架的是 A. MapReduce B. MATLAB☑️ C. SPARK D. Tez</p></li><li><p>以下关于外表和托管表描述正确的是 A. 外表的数据存储在本地，托管表的数据存储在 hdfs 上 B. 删除托管表只会删除 Inceptor 上的元数据不会删除数据文件，删除外表两者都会 被删除 C. 删除外表只会删除 Inceptor 上的元数据不会删除数据文件，删除托管表两者都会 被删除☑️ D. 删除托管表或外表，incepotr 上的元数据和数据文件都会被删除</p></li><li><p>以下对分桶表的描述正确的是 A. 分桶表通过改变数据的存储分布，对查询起到一定的优化作用☑️ B. 分桶键不能是表中的列 C. 分桶数应为素数 D. 事物表必须制定分桶，分桶字段可以被更新</p></li><li><p>以下关于 inceptor excutor 资源配置的说法正确的有 A. Excutor 资源配置 fixed 和 ratio 两种模式☑️ B. Excutor 内核数配置的是每个 excutor 所使用的逻辑 core 数量☑️ C. Excutor 内核数和内存配置比例一般为 1 core:2G memory☑️ D. Excutor 分布可以指定每个节点运行的 excutor 数量或 executor 在集群上运行的 总数量，但是不能指定运行的节点</p></li><li><p>假设使用场景中有如下查询语句 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sex, Region, <span class="keyword">COUNT</span>(<span class="keyword">ID</span>), <span class="keyword">AVG</span> (Salary)</span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Department = <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sex, Region</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sex, Region;</span><br></pre></td></tr></table></figure> 通过 holodesk 的 cube 和 index 手段对这种过滤率和聚合率高的业务进行优化，以下建表 正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A.☑️ <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span></span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Department&#x27;</span> )</span><br><span class="line"></span><br><span class="line">C. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;&#x27;</span>Department<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex&#x27;</span> )</span><br></pre></td></tr></table></figure></p></li><li><p>关于 Hyperbase 全局索引的描述，哪些是正确的？ A. 核心是倒排表☑️ B. 全局索引概念是对应 Rowkey 这个“一级”索引☑️ C. 全局索引使用平衡二叉树 D. 全局索引使用 B+树检索数据☑️</p></li><li><p>以下为 Hyperbase 分布式存储的最小单元的是 A. Region server B. Region☑️ C. StoreFile D. Store</p></li><li><p>以下有关 Hyperbase 说法正确的是 A. 数据类型丰富，支持 String. Int. Char 等类型 B. Key/value 系统，key 由 Row,Column Family,Column Qualifier 组成 C. Hyperbase 表中 rowkey 有序，按字典序降序排列 D. 以上说法都不正确☑️</p></li><li><p>以下关于 StreamSQL 的概念描述正确的是 A. Stream 是数据流☑️ B. Streamjob 是对一个或多个 stream 进行计算并将结果写进一个流的任务 C. Application 是一个或多个 streamjob 的集合☑️ D. 以上说法都不正确</p></li><li><p>某交通部门通过使用流监控全市过往 24 小时各个卡口数据，要求每分钟更新一次， 原始流为 org_stream，以下实现正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. <span class="keyword">CREATE</span> STREAMWINDOW traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAM w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line">B. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line">C.☑️ <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br><span class="line">D. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span></span><br><span class="line"><span class="keyword">second</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br></pre></td></tr></table></figure></p></li><li><p>以下不是 Zookeeper 的功能是 A. 配置管理 B. 集群管理 C. 分布式锁 D. 存储大量数据☑️</p></li><li><p>以下服务需要与 zookeeper 进行通信的是 A. HMaster B. Active NameNode C. InceptorSQL D. Active ResourceManager☑️</p></li><li><p>下列是关于 flume 和 sqoop 对比的描述，不正确的是 A. flume 主要用来采集日志而 sqoop 主要用来做数据迁移 B. flume 主要采集流式数据而 sqoop 主要用来迁移规范化数据☑️ C. flume 和 sqoop 都是分布式处理任务☑️ D. flume 主要用于采集多数据源小数据而 sqoop 用来迁移单数据源数据</p></li><li><p>有关使用 sqoop 抽取数据的原理的描述不正确的是 A. sqoop 在抽取数据的时候可以指定 map 的个数，map 的个数决定在 hdfs 生成的 数据文件的个数 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能越好☑️ C. sqoop 任务的切分是根据 split 字段的（最大值-最小值）/map 数 D. sqoop 抽取数据的时候需要保证执行当前用户有权限执行相应的操作</p></li><li><p>sqoop 抽取数据时需要做一些数据转换的工作，下面说法不正确的是 A. --fields-terminated-by '\01' 用来设置在 hdfs 生成的文件的分割符 B. --hive-drop-import-delims 用来设置在 hdfs 生成的文件的存储形式为列存储☑️ C. --null-string '\N' 用来把所有的 String 类型的空值 转换成 hive 的 NULL 值 D. --null-non-string '\N' 用来把非 String 类型的空值 转换成 hive 的 NULL 值</p></li><li><p>下列有关 flume 的描述不正确的是 A. flume 是 Apache 的一个子项目 B. flume 主要是一个日志采集，传输系统 C. flume 和 sqoop 功能相似，因此可以相互替代☑️ D. flume 可以同时采集集群内部和集群外部的日志数据</p></li><li><p>下列 sink 中哪些是 flume 不支持的 sink A. HDFS sink B. kafka sink C. memory sink☑️ D. file roll sink</p></li><li><p>以下对 ElasticSearch 描述不正确的是 A. ElasticSearch 是分布式全文搜索引擎 B. ElasticSearch 集群中分 master 和 data 节点 C. ElasticSearch 数据存储在 HDFS 上☑️ D. ElasticSearch 数据可以按 Shard 分布在不同的节点上</p></li><li><p>下列不属于 kafka 应用场景的是 A. 常规的消息收集 B. 网站活动性跟踪 C. 日志收集 D. 关系型数据库和大数据平台之间的数据迁移☑️</p></li><li><p>TDH 提供哪几种认证模式？ A. 所有服务使用简单认证模式——所有服务都无需认证即可互相访问☑️ B. 所有服务都启用 Kerberos 认证，用户要提供 Kerberos principal 和密码（或者keytab）来访问各个服务☑️ C. 所有服务都启用 Kerberos 同时 Inceptor 启用 LDAP 认证☑️ D. 所有服务都启用 LDAP 认证</p></li><li><p>以下对各组件的运维页面描述不正确的是 A. 通过 Name Node 的 50070 页面对 HDFS 进行监控 B. 通过 Resource Manager 的 8180 对 YARN 上运行的任务进行监控☑️ C. 通过 HMaster 的 60010 对 HBase 进行监控☑ D. 通过 Hue Server 的 8888 页面登入 Hue</p></li><li><p>Inceptor server 服务无法启动时，该如何查看日志是 A. 查看 TDH manager 所在节点/var/log/inceptorsql<em>/目录下的 hive-server2.log 日志 B. 查看 Inceptor server 所在节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志☑️ C. 查 看 Resource Manager 所 在 节 点 /var/log/Yarn<em>/ 目 录 下 的 yarn-yarn-resourcemanager-poc-node1.log 日志 D. 查看任意节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志</p></li><li><p>以下对 Hadoop 组件的应用场景描述正确的是 A. Hive 主要用于构建大数据数仓，主要做批处理. 统计分析型业务☑️ B. Hbase 主要用于检索查询的 OLTP 业务☑️ C. ElasticSearch 主要用于全文检索的关键字查询业务☑️ D. Spark Streaming 主要用于实时数据的业务场景☑️</p></li><li><p>以下不属于管理角色的是 A. Name Node B. HMaster C. Resource Manager D. Node Manager☑️</p></li><li><p>下面哪些工作不属于集群预安装工作 A. 为集群中每个节点的安装操作系统 B. 选一个节点作为管理节点，修改其 /etc/hosts 文件 C. 安装 Transwarp Manager 管理界面 D. 配置集群安全模式☑️</p></li></ol><h3 id="练习题库二">练习题库(二)</h3><ol type="1"><li><p>下列与 HDFS 有关的说法正确的是 A. HDFS DataNode 节点上的磁盘需要做 RAID1，用来保证数据的可靠性 B. HDFS 可以在磁盘之间通过 balance 操作，平衡磁盘之间的负载情况 C. HDFS 建议 DataNode 之间的数据盘个数. 容量大小不一致，以体现 HDFS 的负均 衡能力 D. 规划 HDFS 集群时，建议 Active NameNode 和 Standby NameNode 分配在不同机 架上☑️</p></li><li><p>在 HDFS 服务中，为了保证 Name Node 高可用性的角色不包括 A. Data Node☑️ B. Journal Node C. ZKFC D. Zookeeper</p></li><li><p>在集群中配置 HDFS 的副本数为 3，设置数据块大小为 128M，此时我们上传一份 64M 的数据文件，该数据文件占用 HDFS 空间大小为 A. 64M B. 128M C. 384M☑️ D. 192M</p></li><li><p>在 Yarn 服务中，不包含以下哪种角色 A. ResourceManager B. NodeManager C. ApplicationMaster☑️ D. Contianer</p></li><li><p>下列有关 YRAN 中角色的描述不正确的是 A. ResourceManager 控制整个集群并管理基础计算资源的分配 B. NodeManager 管理每个节点的资源，管理抽象容器 C. NodeManager 负责调度当前节点的所有 ApplicationMaster☑️ D. ApplicationMaster 管理一个 YARN 内运行的应用程序的实例</p></li><li><p>Spark 与 MapReduce 对比，突出的优势不包括 A. 基于内存的计算，效率更高 B. Spark 能支持比 MapReduce 更多的应用场景 C. Spark 支持多种编程语言接口，框架开销更低 D. Spark 可以运行在 YARN 之上而 MapReduce 不能☑️</p></li><li><p>以下关于外表和托管表描述正确的是 A. 外表的数据存储在本地，托管表的数据存储在 hdfs 上 B. 删除托管表只会删除 Inceptor 上的元数据不会删除数据文件，删除外表两者都会 被删除 C. 删除外表只会删除 Inceptor 上的元数据不会删除数据文件，删除托管表两者都会 被删除☑️ D. 删除托管表或外表，incepotr 上的元数据和数据文件都会被删除</p></li><li><p>导入数据经常会用到 LOAD 命令，以下关于 LOAD 的描述错误的是 A. 源数据文件存放于 hdfs 上，通过 load 命令加载数据文件，数据文件将被复制到 表目录下☑️ B. 目标表为分桶表时不能通过 load 命令加载数据 C. 目标表为分区表时不能通过 load 命令加载数据 D. 当元数据存放于本地时，需要通过指定 LOCAL 关键字</p></li><li><p>tableA 有 10G 的数据，tableB 有 100G 的数据，两个表通过共有的 id 列做关联查询 name 列，以下方式可以优化计算效率的是 A. select /<em>+MAPJOIN(a)</em>/ a.name,b.name from tableA a join tableB b on a.id=b.id B. select /<em>+MAPJOIN(b)</em>/ a.name,b.name from tableA a join tableB b on a.id=b.id C. 建表时将 tableA 和 tableB 根据 id 字段分相同数量的桶☑️ D. 建表时将 tableA 和 tableB 根据 name 字段分相同数量的桶</p></li><li><p>假设使用场景中有如下查询语句 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sex, Region, <span class="keyword">COUNT</span>(<span class="keyword">ID</span>), <span class="keyword">AVG</span> (Salary)</span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Department = <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sex, Region</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sex, Region;</span><br></pre></td></tr></table></figure> 通过 holodesk 的 cube 和 index 手段对这种过滤率和聚合率高的业务进行优化，以下建表 正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. ☑️<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span></span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Department&#x27;</span> )</span><br><span class="line"></span><br><span class="line">C. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;&#x27;</span>Department<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex&#x27;</span> )</span><br></pre></td></tr></table></figure></p></li><li><p>关于 Hyperbase 全局索引的描述，哪些是正确的？ A. 核心是倒排表☑️ B. 全局索引概念是对应 Rowkey 这个“一级”索引☑️ C. 全局索引使用平衡二叉树 D. 全局索引使用 B+树检索数据☑️</p></li><li><p>以下不属于 Hyperbase 存储模型单位的是 A. table B. region☑️ C. StoreFile D. block</p></li><li><p>有关 Minor Compact 的描述正确的是 A. 一个 store 下的所有文件合并 B. 删除过期版本数据 C. 删除 delete marker 数据 D. 把多个 HFile 合成一个☑️</p></li><li><p>以下的 stream 的描述不正确的是 A. Input 定义了如何从数据源读取数据 B. Derived stream 是对 stream 转换而来的，可分为单 batch 变形和多 batch 变形 C. 定义 Derived stream 后 stream 当即根据转换规则进行变形☑️ D. 窗口变形的长度必须是当前流的整数倍</p></li><li><p>某公司有部门 A. 部门 B…，各部门的源数据都取自于企业总线，要求部门内部共享 数据源，部门间做到资源隔离，以下设计合理的有 A. 部门里每个流任务起一个 application 管理 streamjob B. 每个部门起一个 application 管理本部门的 streamjob☑️ C. 公司起一个 application 管理所有的 streamjob D. 每个部门起一个 streamjob 管理本部门的 application</p></li><li><p>Zookeeper 服务描述正确的是 A. Zookeeper 可以存储文件，所以它是用于存储大量数据信息的文件系统。 B. 它是集群的管理服务，总控节点间所有通信。 C. 它是分布式应用程序协调服务。☑️ D. 它是保存所有集群服务的元数据库。</p></li><li><p>我们可以通过 hue 图形化的操作 HDFS，hue 可以实现 hdfs 的 A. 创建目录☑️ B. 上传文件☑️ C. 直接查看文件☑️ D. 更改权限☑️</p></li><li><p>通过 oozie workflow 调度 sqoop 任务，以下说法正确的是 A. 必须使用 sudo 用户 B. 确保对应的 jdbc 驱动正确上传到 hdfs 上☑️ C. Sqoop 导入的 hdfs 目录必须前提不存在☑️ D. 以上说法都对</p></li><li><p>有关使用 sqoop 抽取数据的原理的描述不正确的是 A. sqoop 在抽取数据的时候可以指定 map 的个数，map 的个数决定在 hdfs 生成的 数据文件的个数 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能 越好☑️ C. sqoop 任务的切分是根据 split 字段的（最大值-最小值）/map 数 D. sqoop 抽取数据的时候需要保证执行当前用户有权限执行相应的操作</p></li><li><p>有关 sqoop 的参数说法不正确的是 A. --username 是必需参数 B. --m 大于 1 时，--split-by 参数是必需参数 C. --query 是执行 sqoop 操作的必需参数☑️ D. --field-terminated-by 用来指定在 hdfs 生成数据文件时的列分隔符</p></li><li><p>下列是关于 flume 和 sqoop 对比的描述，不正确的是 A. flume 主要用来采集日志而 sqoop 主要用来做数据迁移 B. flume 主要采集流式数据而 sqoop 主要用来迁移规范化数据 C. flume 和 sqoop 都是分布式处理任务☑️ D. flume 主要用于采集多数据源小数据而 sqoop 用来迁移单数据源数据</p></li><li><p>以下不属于 Flume 的 Source 类型的是 A. exec source B. file source☑️ C. spooling directory source D. kafka source</p></li><li><p>有关 Elasticsearch 特性描述有误的一项是 A. 分布式实时文件存储，可将每一个字段存入索引 B. 实时分析的分布式搜索引擎。 C. 支持插件机制，分词插件. 同步插件 D. 以上都不正确☑️</p></li><li><p>下列不属于 kafka 应用场景的是 A. 常规的消息收集 B. 网站活动性跟踪 C. 日志收集 D. 关系型数据库和大数据平台之间的数据迁移☑️</p></li><li><p>TDH 提供哪几种认证模式？ A. 所有服务使用简单认证模式——所有服务都无需认证即可互相访问☑️ B. 所有服务都启用 Kerberos 认证，用户要提供 Kerberos principal 和密码（或者 keytab）来访问各个服务☑️ C. 所有服务都启用 Kerberos 同时 Inceptor 启用 LDAP 认证☑️ D. 所有服务都启用 LDAP 认证</p></li><li><p>在安装有 kerberos 服务的集群中如何切换用户 A. 不需要切换，所有用户都为服务公用用户，可以直接使用。 B. 直接使用 kinit 用户名称方式进行切换☑️ C. 必须先 destroy ，才能再使用 kinit 用户名称 方式登录 D. 以上都不正确</p></li><li><p>以下对 Transwarp Manager 描述不正确的是 A. Transwarp Manger 是 TDH 的管理运维平台 B. 通过 Transwarp Manager 的 8180 界面登入 C. 在 Transwarp Manager 上能启动和停止 Transwarp Agent 角色☑️ D. 在 Transwarp Manager 上能对 Inceptor 表进行赋权操作</p></li><li><p>以下对 Hadoop 组件的应用场景描述正确的是 A. Hive 主要用于构建大数据数仓，主要做批处理. 统计分析型业务☑️ B. Hbase 主要用于检索查询的 OLTP 业务☑️ C. ElasticSearch 主要用于全文检索的关键字查询业务☑️ D. Spark Streaming 主要用于实时数据的业务场景☑️</p></li><li><p>某电信部门有 100 亿条用户过往使用通讯记录，现需要提供客户终端根据电话号精 确查询历史通讯，满足用户同时并发访问，则该表应该设计为 A. Hyperbase 表+全局索引☑️ B. Hyperbase 表+es 索引 C. Es 表+es 索引 D. 以上方式都可以</p></li><li><p>可以安装 TDH 的操作系统有？ A. SUSE SP2-SP3。☑️ B. Win7/Win10。 C. CentOS 6.3-6.5。☑️ D. REHL 6.3-6.5。☑️</p></li></ol><h3 id="练习题库三">练习题库(三)</h3><ol type="1"><li><p>下列与 HDFS 有关的说法正确的是 A. HDFS DataNode 节点上的磁盘需要做 RAID1，用来保证数据的可靠性 B. HDFS 可以在磁盘之间通过 balance 操作，平衡磁盘之间的负载情况 C. HDFS 建议 DataNode 之间的数据盘个数. 容量大小不一致，以体现 HDFS 的负载 均衡能力 D. 规划 HDFS 集群时，建议 Active NameNode 和 Standby NameNode 分配在不同的 机架上☑️</p></li><li><p>NameNode 用于存储 HDFS 上数据块的元数据信息，它保存的数据形式是 A. block B. fsimage☑️ C. editlog☑️ D. blockid</p></li><li><p>在集群中配置 HDFS 的副本数为 3，设置数据块大小为 128M，此时我们上传一份 64M 的数据文件，该数据文件占用 HDFS 空间大小为 A. 64M B. 128M C. 384M☑️ D. 192M</p></li><li><p>下列对 YARN 角色在集群中的作用描述正确的是 A. 集群资源管理☑️ B. 集群任务调度与管理☑️ C. 存储部分 HDFS 上的数据块 D. 以上都正确</p></li><li><p>YARN 框架中，负责集群资源管理的组件是 A. ResourceManager☑️ B. NodeManager C. Container D. JobTracker</p></li><li><p>MapReduce 计算框架的特点包括 A. 自动化并行和分布式计算 B. 出错容忍度高 C. 优先数据本地化计算 D. 以上都是☑️</p></li><li><p>以下关于外表和托管表描述正确的是 A. 外表的数据存储在本地，托管表的数据存储在 hdfs 上 B. 删除托管表只会删除 Inceptor 上的元数据不会删除数据文件，删除外表两者都会 被删除 C. 删除外表只会删除 Inceptor 上的元数据不会删除数据文件，删除托管表两者都会 被删除☑️ D. 删除托管表或外表，incepotr 上的元数据和数据文件都会被删除</p></li><li><p>以下关于 Inceptor 数据倾斜场景正确的处理方式有 A. 对于数据倾斜的 SQL 重新跑一次即可解决 B. 剔除引起数据倾斜的数据，再重新执行 SQL C. 导入数据期间格式转换出现错误引起 null 过多，可以通过重新清理数据解决☑️ D. 将一起数据倾斜的数据和剩下的数据单独运行，再通过 union 合并的方式解决☑️</p></li><li><p>以下关于 inceptor 日志信息描述正确的有 A. Inceptor server 日志存放于各节点的/var/log/inceptorsql[x]/hive-server.log☑️ B. 可以通过 inceptor server 4040 查看 SQL 错误日志☑️ C. Excutor 日志存放于 excutor 节点的/var/log/inceptorsql[x]/spark-excutor.log☑️ D. ExcutorGC 日志存放于 excutor 节点的/var/log/inceptorsql[x]/spark-excutor.gc.log☑️</p></li><li><p>假设使用场景中有如下查询语句 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sex, Region, <span class="keyword">COUNT</span>(<span class="keyword">ID</span>), <span class="keyword">AVG</span> (Salary)</span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Department = <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sex, Region</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sex, Region;</span><br></pre></td></tr></table></figure> 通过 holodesk 的 cube 和 index 手段对这种过滤率和聚合率高的业务进行优化，以下建表 正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. ☑️<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span></span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Department&#x27;</span> )</span><br><span class="line"></span><br><span class="line">C. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex, Region&#x27;</span>)</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee TBLPROPERTIES (</span><br><span class="line"><span class="string">&#x27;cache&#x27;</span> = <span class="string">&#x27;RAM&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.index&#x27;</span> = <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;holodesk.dimension&#x27;</span> = <span class="string">&#x27;Sex&#x27;</span> )</span><br></pre></td></tr></table></figure></p></li><li><p>以下属于 HMaster 功能的是 A. 为 Region Server 分配 region☑️ B. 存储数据元信息 C. 对 region 进行 compact 操作 D. 管理用户对 table 的增删改查操作☑️</p></li><li><p>有关 Minor Compact 的描述正确的是 A. 一个 store 下的所有文件合并 B. 删除过期版本数据 C. 删除 delete marker 数据 D. 把多个 HFile 合成一个☑️</p></li><li><p>下列创建全局索引的语句，正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. add_index &#x27;t1&#x27;, &#x27;index_name&#x27;,&#x27;COMBINE_INDEX|INDEXED=f1:q1:9|rowKey:rowKey:10,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">B. add_global_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;☑️</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">C. add_fulltext_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">D. create_global_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></p></li><li><p>以下对流处理计算框架描述不正确的是 A. Spark Streaming 是基于微批（batch）对数据进行处理的 B. Apache Storm 是基于时间（event）对数据进行处理的 C. Transwarp StreamSQL 可基于微批或事件对数据进行处理 D. 以上说法都不对☑️</p></li><li><p>某交通部门通过使用流监控全市过往 24 小时各个卡口数据，要求每分钟更新一次， 原始流为 org_stream，以下实现正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. <span class="keyword">CREATE</span> STREAMWINDOW traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAM w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line"></span><br><span class="line">C. ☑️<span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span></span><br><span class="line"><span class="keyword">second</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br></pre></td></tr></table></figure></p></li><li><p>以下不是 Zookeeper 的功能是 A. 配置管理 B. 集群管理 C. 分布式锁 D. 存储大量数据☑️</p></li><li><p>关于 Hue 对 hive server 的支持度描述正确的是 A. 只支持 hive server1 B. 只支持 hive server2☑️ C. 同时支持 hive server1 和 hive server2 D. 只支持开启 LDAP 的 hive server2</p></li><li><p>以下关于 oozie 三个编辑器说法正确的是 A. bundle 构建在 workflow 工作方式之上，提供定时运行和触发运行任务的功能。 B. bundle 将多个 workflow 管理起来，这样我们只需提供一个 bundle 提交即可 C. workflow 是最简单的一种工作方式☑️ D. coordinator 可以包含一到多个 workflow☑️</p></li><li><p>有关使用 sqoop 抽取数据的原理的描述不正确的是 A. sqoop 在抽取数据的时候可以指定 map 的个数，map 的个数决定在 hdfs 生成的 数据文件的个数 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能 越好☑️ C. sqoop 任务的切分是根据 split 字段的（最大值-最小值）/map 数 D. sqoop 抽取数据的时候需要保证执行当前用户有权限执行相应的操作</p></li><li><p>下面与 sqoop 做数据迁移有关的描述不正确的是 A. sqoop 做数据迁移的主要瓶颈在网络带宽和 RDB 的 IO 限制 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能越 好☑️ C. sqoop 抽取数据分为全量抽取和增量抽取两种 D. 当-m 大于 1 时，就必须要设置--split-by 字段</p></li><li><p>下列有关 flume 的描述不正确的是 A. flume 是 Apache 的一个子项目 B. flume 主要是一个日志采集，传输系统 C. flume 和 sqoop 功能相似，因此可以相互替代☑️ D. flume 可以同时采集集群内部和集群外部的日志数据</p></li><li><p>下列是关于 flume 和 sqoop 对比的描述，不正确的是 A. flume 主要用来采集日志而 sqoop 主要用来做数据迁移 B. flume 主要采集流式数据而 sqoop 主要用来迁移规范化数据 C. flume 和 sqoop 都是分布式处理任务☑️ D. flume 主要用于采集多数据源小数据而 sqoop 用来迁移单数据源数据</p></li><li><p>以下对 ElasticSearch 描述不正确的是 A. ElasticSearch 是分布式全文搜索引擎 B. ElasticSearch 集群中分 master 和 data 节点 C. ElasticSearch 数据存储在 HDFS 上☑️ D. ElasticSearch 数据可以按 Shard 分布在不同的节点上</p></li><li><p>下列不属于 kafka 应用场景的是 A. 常规的消息收集 B. 网站活动性跟踪 C. 日志收集 D. 关系型数据库和大数据平台之间的数据迁移☑️</p></li><li><p>TDH 提供哪几种认证模式？ A. 所有服务使用简单认证模式——所有服务都无需认证即可互相访问☑️ B. 所有服务都启用 Kerberos 认证，用户要提供 Kerberos principal 和密码（或者 keytab）来访问各个服务☑️ C. 所有服务都启用 Kerberos 同时 Inceptor 启用 LDAP 认证☑️ D. 所有服务都启用 LDAP 认证</p></li><li><p>以下属于 Guardian 的功能是 A. 用户管理☑️ B. 用户认证☑️ C. 审计☑️ D. 权限管理☑️</p></li><li><p>Inceptor server 服务无法启动时，该如何查看日志是 A. 查看 TDH manager 所在节点/var/log/inceptorsql<em>/目录下的 hive-server2.log 日志 B. 查看 Inceptor server 所在节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志☑️ C. 查 看 Resource Manager 所 在 节 点 /var/log/Yarn<em>/ 目 录 下 的 yarn-yarn-resourcemanager-poc-node1.log 日志 D. 查看任意节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志</p></li><li><p>以下对 Hadoop 组件的应用场景描述正确的是 A. Hive 主要用于构建大数据数仓，主要做批处理. 统计分析型业务☑️ B. Hbase 主要用于检索查询的 OLTP 业务☑️ C. ElasticSearch 主要用于全文检索的关键字查询业务☑️ D. Spark Streaming 主要用于实时数据的业务场景☑️</p></li><li><p>现有一个表数据要存储在 hyperbase 上，并创建全文索引，原表数据 10GB，HDFS 配置为 3 副本，hyperbase 压缩比例按 1:3 计算，索引数据量为 20GB，ES 副本数为 1， ES 压缩比按 1:3 计算，则该表需要多大的存储空间存储 A. 16.67GB B. 23.33GB☑️ C. 30GB D. 70GB</p></li><li><p>下面哪些工作不属于集群预安装工作 A. 为集群中每个节点的安装操作系统 B. 选一个节点作为管理节点，修改其/etc/hosts 文件 C. 安装 Transwarp Manager 管理界面 D. 配置集群安全模式☑️</p></li></ol><h3 id="练习题库四">练习题库(四)</h3><ol type="1"><li><p>下列与 HDFS 有关的说法正确的是 A. HDFS DataNode 节点上的磁盘需要做 RAID1，用来保证数据的可靠性 B. HDFS 可以在磁盘之间通过 balance 操作，平衡磁盘之间的负载情况 C. HDFS 建议 DataNode 之间的数据盘个数. 容量大小不一致，以体现 HDFS 的负载 均衡能力 D. 规划 HDFS 集群时，建议 Active NameNode 和 Standby NameNode 分配在不同的 机架上☑️</p></li><li><p>以下哪个服务作为 HDFS 高可靠协调服务的共享存储？ A. ZooKeeper B. JournalNodes☑️ C. NameNode D. ZKFailoverController</p></li><li><p>在集群中配置 HDFS 的副本数为 3，设置数据块大小为 128M，此时我们上传一份 64M 的数据文件，该数据文件占用 HDFS 空间大小为 A. 64M B. 128M C. 384M☑️ D. 192M</p></li><li><p>在 Yarn 服务中，不包含以下哪种角色 A. ResourceManager B. NodeManager C. ApplicationMaster D. Contianer☑️</p></li><li><p>ResourceManager 是 YARN 的主要组成部分，有关其功能描述不正确的是 A. 它直接将集群所拥有的资源按需分配给运行在 YARN 上的应用程序☑️ B. 它负责将集群中的所有资源进行统一管理和分配 C. 它接受各个节点的资源汇报信息 D. 它把资源按照策略分配给各应用</p></li><li><p>当前用户提交了一个 wordcount 词频统计的任务，最后任务执行失败，可能的原因有 哪些 A. 当前集群中没有足够的资源，不足以满足当前 wordcount 任务的需求 B. 执行该任务的用户没有权限访问 HDFS 上的数据文件 C. 用户在执行任务之前在 HDFS 相应的目录下创建了提交任务时指定的输出目录 D. 以上原因都有可能☑️</p></li><li><p>以下关于外表和托管表描述正确的是 A. 外表的数据存储在本地，托管表的数据存储在 hdfs 上 B. 删除托管表只会删除 Inceptor 上的元数据不会删除数据文件，删除外表两者都会 被删除 C. 删除外表只会删除 Inceptor 上的元数据不会删除数据文件，删除托管表两者都会 被删除☑️ D. 删除托管表或外表，incepotr 上的元数据和数据文件都会被删除</p></li><li><p>SQL 运行中如果出现 maptask 数据特别多，执行时间又很短时可以通过小文件合并来 进行优化，以下是合并参数有 A. SET ngmr.partition.automerge = TRUE;☑️ B. SET ngmr.partition.mergesize = n;☑️ C. SET ngmr.partition.mergesize.mb = m;☑️ D. SET mapred.reduce.tasks = N;</p></li><li><p>以下关于 inceptor 日志信息描述正确的有 A. Inceptor server 日志存放于各节点的/var/log/inceptorsql[x]/hive-server.log☑️ B. 可以通过 inceptor server 4040 查看 SQL 错误日志☑️ C. Excutor 日志存放于 excutor 节点的/var/log/inceptorsql[x]/spark-excutor.log☑️ D. ExcutorGC 日志存放于 excutor 节点的/var/log/inceptorsql[x]/spark-excutor.gc.log☑️</p></li><li><p>tableA 有 10G 的数据，tableB 有 100G 的数据，两个表通过共有的 id 列做关联查询 name 列，以下方式可以优化计算效率的是 A. select /<em>+MAPJOIN(a)</em>/ a.name,b.name from tableA a join tableB b on a.id=b.id B. select /<em>+MAPJOIN(b)</em>/ a.name,b.name from tableA a join tableB b on a.id=b.id C. 建表时将 tableA 和 tableB 根据 id 字段分相同数量的桶☑️ D. 建表时将 tableA 和 tableB 根据 name 字段分相同数量的桶</p></li><li><p>以下属于 HMaster 功能的是 A. 为 Region Server 分配 region☑️ B. 存储数据元信息☑️ C. 对 region 进行 compact 操作 D. 管理用户对 table 的增删改查操作</p></li><li><p>Hyperbase 与 Inceptor 的关系，描述正确的是 A. 两者不可或缺，Inceptor 保证 Hyperbase 的服务的正常运行 B. 两者没有任何关系 C. Inceptor 可以访问 Hyperbase☑️ D. 两者相辅相成☑️</p></li><li><p>下列创建全局索引的语句，正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. add_index &#x27;t1&#x27;, &#x27;index_name&#x27;,</span><br><span class="line">&#x27;COMBINE_INDEX|INDEXED=f1:q1:9|rowKey:rowKey:10,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">B. ☑️add_global_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">C. add_fulltext_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">D. create_global_index &#x27;</span>t1<span class="string">&#x27;, &#x27;</span>index_name<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">&#x27;</span>COMBINE_INDEX|INDEXED=f1:q1:<span class="number">9</span>|rowKey:rowKey:<span class="number">10</span>,<span class="keyword">UPDATE</span>=<span class="literal">true</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></p></li><li><p>以下对流处理计算框架描述不正确的是 A. Spark Streaming 是基于微批（batch）对数据进行处理的 B. Apache Storm 是基于时间（event）对数据进行处理的 C. Transwarp StreamSQL 可基于微批或事件对数据进行处理 D. 以上说法都不对☑️</p></li><li><p>某交通部门通过使用流监控全市过往 24 小时各个卡口数据，要求每分钟更新一次， 原始流为 org_stream，以下实现正确的是 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">A. <span class="keyword">CREATE</span> STREAMWINDOW traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAM w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line"></span><br><span class="line">B. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span> slide <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span>);</span><br><span class="line"></span><br><span class="line">C. ☑️<span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream</span><br><span class="line">STREAMWINDOW w1 <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span> <span class="keyword">hour</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br><span class="line"></span><br><span class="line">D. <span class="keyword">CREATE</span> STREAM traffic_stream <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> original_stream <span class="keyword">AS</span> (<span class="keyword">length</span> <span class="string">&#x27;24&#x27;</span></span><br><span class="line"><span class="keyword">second</span> slide <span class="string">&#x27;1&#x27;</span> <span class="keyword">minute</span>);</span><br></pre></td></tr></table></figure></p></li><li><p>Zookeeper 服务描述正确的为 A. Zookeeper 中每一个 server 互为 leader。 B. Zookeeper 中只有一个 leader，并通过备份机制产生。 C. Zookeeper 中不存在 leader,所有 server 共同提供服务。 D. Zookeeper 通过选举机制确定 leader，有且仅有一个。☑️</p></li><li><p>通过 Hue 修改 HDFS 目录或文件的权限可以通过以下哪些方式实现 A. Hdfs 相应的权限☑️ B. 通过 Hue 超级用户 hue 登录 C. 以 hdfs 用户登录☑️ D. 以上都可以</p></li><li><p>通过 Oozie 使用 ssh，必须满足以下条件 A. 以 root 用户登录各个节点 B. Oozie 用户可以免密钥登录☑️ C. Oozie 用户必须要有 bash 权限☑️ D. 所访问必须是集群的节点</p></li><li><p>有关使用 sqoop 抽取数据的原理的描述不正确的是 A. sqoop 在抽取数据的时候可以指定 map 的个数，map 的个数决定在 hdfs 生成的 数据文件的个数 B. sqoop 抽取数据是个多节点并行抽取的过程，因此 map 的个数设置的越多性能 越好☑️ C. sqoop 任务的切分是根据 split 字段的（最大值-最小值）/map 数 D. sqoop 抽取数据的时候需要保证执行当前用户有权限执行相应的操作</p></li><li><p>在使用 sqoop 连接关系型数据时，下面哪个命令可以查看关系型数据库中有哪些表？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A. sqoop list-databases</span><br><span class="line">--username root</span><br><span class="line">--password 111111</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;192.168.164.25:3306&#x2F;</span><br><span class="line"></span><br><span class="line">B. sqoop list-databases</span><br><span class="line">--username root</span><br><span class="line">-P</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;192.168.164.25:3306&#x2F;</span><br><span class="line"></span><br><span class="line">C. sqoop list-databases</span><br><span class="line">--username root</span><br><span class="line">--password-file file:&#x2F;root&#x2F;.pwd</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;192.168.164.25:3306&#x2F;</span><br><span class="line"></span><br><span class="line">D. ☑️sqoop list-tables</span><br><span class="line">--username root</span><br><span class="line">--password 111111</span><br><span class="line">--connect jdbc:mysql:&#x2F;&#x2F;192.168.164.25:3306&#x2F;test</span><br></pre></td></tr></table></figure></p></li><li><p>要将采集的日志数据作为 kafka 的数据源，则 flume sink 需要设置为下列哪项参数 A. hdfs B. kafka C. org.apache.flume.sink.kafka.KafkaSink☑️ D. {topicname}</p></li><li><p>下列是关于 flume 和 sqoop 对比的描述，不正确的是 A. flume 主要用来采集日志而 sqoop 主要用来做数据迁移 B. flume 主要采集流式数据而 sqoop 主要用来迁移规范化数据 C. flume 和 sqoop 都是分布式处理任务☑️ D. flume 主要用于采集多数据源小数据而 sqoop 用来迁移单数据源数据</p></li><li><p>有关 Elasticsearch 描述有误的一项是 A. 它会利用多播形式发现节点。 B. 主节点(master node) 通过选举方式产生。 C. 主节点(master node)进行集群的管理，只负责集群节点添加和删除。☑️ D. 主节点会去读集群状态信息，必要的时候进行恢复工作。</p></li><li><p>下面措施中，不能保证 kafka 数据可靠性的是 A. kafka 会将所有消息持久化到硬盘中保证其数据可靠性 B. kafka 通过 Topic Partition 设置 Replication 来保证其数据可靠性 C. kafka 通过设置消息重发机制保证其数据可靠性 D. kafka 无法保证数据可靠性☑️</p></li><li><p>TDH 提供哪几种认证模式？ A. 所有服务使用简单认证模式——所有服务都无需认证即可互相访问☑️ B. 所有服务都启用 Kerberos 认证，用户要提供 Kerberos principal 和密码（或者keytab）来访问各个服务☑️ C. 所有服务都启用 Kerberos 同时 Inceptor 启用 LDAP 认证☑️ D. 所有服务都启用 LDAP 认证</p></li><li><p>开启 LDAP 后，应该使用哪个命令连接 Inceptor A. transwarp -t -h <span class="math inline">\(ip。 B. beeline -u jdbc:hive2://\)</span>ip:10000 -n $username -p <span class="math inline">\(password。☑️ C. beeline -u &quot;jdbc:hive2://\)</span>ip:10000/default;principal=hive/node1@TDH"。 D. beeline -u "jdbc:hive2://$ip:10000/default;principal=user1@TDH"。</p></li><li><p>Inceptor server 服务无法启动时，该如何查看日志是 A. 查看 TDH manager 所在节点/var/log/inceptorsql<em>/目录下的 hive-server2.log 日志 B. 查看 Inceptor server 所在节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志☑️ C. 查 看 Resource Manager 所 在 节 点 /var/log/Yarn<em>/ 目 录 下 的yarn-yarn-resourcemanager-poc-node1.log 日志 D. 查看任意节点/var/log/inceptorsql</em>/目录下的 hive-server2.log 日志</p></li><li><p>现有一批数据需要进行清洗，要求对其中 null 通过 update 转换为 0，删除重复的记 录，添加部分新的记录，则该表应该设计为 A. Tex 表 B. Orc 表 C. Orc 事务表☑️ D. Holodesk 表</p></li><li><p>现有一个表数据要存储在 hyperbase 上，并创建全文索引，原表数据 10GB，HDFS 配置为 3 副本，hyperbase 压缩比例按 1:3 计算，索引数据量为 20GB，ES 副本数为 1， ES 压缩比按 1:3 计算，则该表需要多大的存储空间存储 A. 16.67GB B. 23.33GB☑️ C. 30GB D. 70GB</p></li><li><p>下面哪些工作不属于集群预安装工作 A. 为集群中每个节点的安装操作系统 B. 选一个节点作为管理节点，修改其 /etc/hosts 文件 C. 安装 Transwarp Manager 管理界面 D. 配置集群安全模式☑️</p></li></ol><h3 id="问答题">问答题</h3><ol type="1"><li>集群有 8 个节点，每个节点有 8 块硬盘（默认 3 副本）。如果某个节点有 3 块盘损坏，是否可能存在数据块丢失情况；如果有 3 个节点发生故障，是否可能存在数据块丢失情况；并简述原因。</li><li>请描述 TDH 平台中在 Yarn 上可以使用哪几种调度策略，并分别阐述各调度策略的特点。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FIFO Scheduler（先进先出调度器）：(策略)将所有任务放入一个队列，先进队列的先获得资源，排在后面的任务只有等待。(缺点)－资源利用率低，无法交叉运行任务。－灵活性差。</span><br><span class="line"></span><br><span class="line">Capacity Scheduler（容量调度器）：(思想)提前做预算，在预算指导下分享集群资源。(策略)集群资源由多个队列分享。每个队列都要预设资源分配的比例（提前做预算）。空闲资源优先分配给“实际资源&#x2F;预算资源”比值最低的队列。队列内部采用FIFO调度策略。(特点)层次化的队列设计。容量保证：每个队列都要预设资源占比，防止资源独占。弹性分配：空闲资源可以分配给任何队列，当多个队列争用时，会按比例进行平衡。支持动态管理。访问控制。多租户：多用户共享集群资源。</span><br><span class="line"></span><br><span class="line">Fair Scheduler（公平调度器）：（调度策略)多队列公平共享集群资源。通过平分的方式，动态分配资源，无需预先设定资源分配比例。队列内部可配置调度策略：FIFO、Fair（默认）。</span><br></pre></td></tr></table></figure></li><li>请描述一个 100GB 文件写入 HDFS 的整个过程（使用 bulkload 方式实现） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">抽取：从数据源中抽取数据</span><br><span class="line">对于MySQL，运行mysqldump命令导出数据</span><br><span class="line"></span><br><span class="line">转换：利用MapReduce，将数据转换为HFile文件</span><br><span class="line">对于TSV或CSV文件，使用HBase ImportTsv工具将其转换成HFile文件 －每个输出文件夹中的每个区域都会创建一个HFile文件</span><br><span class="line"></span><br><span class="line">加载：将HFile文件加载到HBase</span><br><span class="line">利用HBase CompleteBulkLoad工具，将HFile文件移动到HBase表的相应目录中，完成加载</span><br><span class="line"></span><br><span class="line">具体来说：</span><br><span class="line">1)客户端发送创建文件指令给分布式文件系统</span><br><span class="line">2)文件系统告知namenode (检查权限，查看文件是否存在。EditLog增加记录。返回输出流对象)</span><br><span class="line">3)客户端往输出流中写入数据,分成一个个数据包</span><br><span class="line">4)根据namenode分配,输出流往datanode写数据(多个datanode构成一个管道pipeline,输出流写第一个,后面的转发)</span><br><span class="line">4)每个datanode写完一个块后，返回确认信息</span><br><span class="line">5)写完数据，关闭输出流</span><br><span class="line">6)发送完成信号给namenode</span><br></pre></td></tr></table></figure></li><li>请以 WordCount 为例描述 MapReduce 的运行过程，并列出 Spark 相较 MapReduce 的 优势 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">过程：todo</span><br><span class="line"></span><br><span class="line">优势：基于内存计算RDD;基于DAG优化任务流程(延迟计算);易于部署,更低的框架开销;丰富的API支持。</span><br></pre></td></tr></table></figure></li><li>写出以下场景下的优化思路</li></ol><ol type="a"><li>假设在 Inceptor 上执行任务，发现 Map Task 数量多、执行时间短，应采取哪种措施来提升性能？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对数据块进行合并：Automerge（碎片自动合并）</span><br></pre></td></tr></table></figure></li><li>请简述在 Inceptor 中大表与大表做 join、大表与小表做 join 时分别有哪些优化手段 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大表与大表的普通JOIN：实现普通JOIN的过程是这样的：扫描过滤两张表的数据（Map Stages），然后通过Shuffle将Key哈希值相同的数据分发到各个节点，在各节点内部执行JOIN（Reduce Stages）</span><br><span class="line"></span><br><span class="line">MapJoin是一种针对大表与小表JOIN的特殊实现方式，在大小表数据量悬殊的情况下能有效的提升JOIN执行效率，一般受优化开关或者Hint控制启动。</span><br></pre></td></tr></table></figure></li></ol><ol start="6" type="1"><li>请列出 TDH 下的 4 大组件（Inceptor、Hyperbase、StreamSQL、Discover）的特性以及适用场景。</li><li>假设集群的每个节点初始有 6 块硬盘，运行一段时间后，每个节点又加了 4 块新硬盘， 为了使数据在所有硬盘上分布均匀，能否通过 hdfs balancer 达到效果，为什么？并列出能达到效果的两种措施。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不能，旧版本的hdfs仅支持节点间的数据平衡，新版本可通过balancer实现</span><br><span class="line">1.手动重写所有数据  2.将数据全部移到几个节点上，再在节点间数据平衡</span><br></pre></td></tr></table></figure></li><li>请描述高并发检索和综合搜索的场景特点，这两种场景应使用哪种技术来做支撑， 并指出数据和索引各自的存储位置。</li><li>请描述 HDFS 的高可用性实现机制</li><li>请列举出平台支持的 5 种存储格式/引擎的表，并详细描述各自的存储特点、使用场景、支持的操作以及是否支持分区分桶 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Text 表：</span><br><span class="line">ORC 表：</span><br><span class="line">事务表：</span><br><span class="line">HoloDesk 表：</span><br><span class="line">Hyperbase 表：</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      星环考试问答
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[课堂笔记] 高级软件设计</title>
    <link href="https://wym0120.github.io/2020/11/12/lecture/software-design/SD-notes/"/>
    <id>https://wym0120.github.io/2020/11/12/lecture/software-design/SD-notes/</id>
    <published>2020-11-12T06:33:15.000Z</published>
    <updated>2021-04-12T15:01:26.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><ol type="1"><li><p>设计模式的定义 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在软件工程中，设计模式是一种在特定上下文中应对反复出现的问题的可重用的通用的解决方案</span><br></pre></td></tr></table></figure></p></li><li><p>设计模式的分类 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209212805.png" /></p></li></ol><h2 id="模式类图">模式类图</h2><h3 id="策略模式">策略模式</h3><p><img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215200.png" /> ### 状态模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215132.png" /> ### 观察者模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215105.png" /> ### 装饰者模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215537.png" /> ### 工厂方法模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215328.png" /> ### 抽象工厂模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215302.png" /> ### 命令模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215002.png" /> ### 适配器模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215450.png" /> ### 外观模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215602.png" /> ### 模版模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215225.png" /> ### 迭代器模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215659.png" /> ### 组合模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215511.png" /> ### 单例模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215353.png" /> ### 代理模式 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209215633.png" /></p><h2 id="题目">题目</h2><h3 id="模式体现什么设计原则">模式体现什么设计原则</h3><h3 id="意图汇总">意图汇总</h3><table><thead><tr class="header"><th>模式</th><th>意图</th></tr></thead><tbody><tr class="odd"><td>策略</td><td>定义一系列算法，封装每个算法，并使它们可互换。策略允许算法独立于使用它的客户机而变化。</td></tr><tr class="even"><td>状态</td><td>允许对象在内部状态发生改变时改变它的行为</td></tr><tr class="odd"><td>观察者</td><td>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</td></tr><tr class="even"><td>装饰者</td><td>允许向一个现有的对象添加新的功能，同时又不改变其结构</td></tr><tr class="odd"><td>工厂</td><td>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</td></tr><tr class="even"><td>抽象工厂</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</td></tr><tr class="odd"><td>命令</td><td>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化</td></tr><tr class="even"><td>适配器</td><td>将一个类的接口转换成客户希望的另外一个接口</td></tr><tr class="odd"><td>外观</td><td>为高层模块提供一个一致的接口访问多个复杂的子系统</td></tr><tr class="even"><td>模版</td><td>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td></tr><tr class="odd"><td>迭代器</td><td>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示</td></tr><tr class="even"><td>组合</td><td>将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性</td></tr><tr class="odd"><td>单例</td><td>保证一个类仅有一个实例，并提供一个访问它的全局访问点</td></tr><tr class="even"><td>代理</td><td>为其他对象提供一种代理以控制对这个对象的访问</td></tr></tbody></table><hr /><h3 id="设计原则">设计原则</h3><h4 id="principles">Principles</h4><ol type="1"><li>Encapsulate what varies.</li><li>Favor composition over inheritance.</li><li>Program to interfaces, not implementations.</li><li>Strive for loosely coupled designs between objects that interact.</li><li>The Open-Closed Principle ：Classes should be open for extension, but closed for modification</li><li>Dependency Inversion Principle ：Depend upon abstractions. Do not depend upon concrete classes.</li><li>The Hollywood Principle ：Don’t call me, we’ll call you</li><li>Single Responsibility ：A class should have only one reason to change</li><li>Principle of Least Knowledge ：talk only to your immediate friends</li></ol><p>⚠️以下分类不一定完全正确仅代表个人观点 <img src="https://mignuw-private-blog.oss-cn-shanghai.aliyuncs.com/img/20201209232932.png" /></p><h4 id="思考题">思考题</h4><ol type="1"><li>好莱坞原则与依赖倒置的关系 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">依赖倒置原则强调尽可能避免使用具体类，而多使用抽象。而好莱坞原则是让低层组件能够被 hook 进计算并且高层不依赖低层。两者的目的都是结偶，但是依赖倒置更加注重如何在设计中避免依赖</span><br></pre></td></tr></table></figure></li><li>好莱坞原则中低层组建不可以调用高层组建中的方法吗？ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不完全是，低层会调用高层中继承来的方法。好莱坞原则要避免的是高层和低层之间的环形依赖</span><br></pre></td></tr></table></figure></li><li>透明的组合模式和安全的组合模式之间的tradeoff <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">透明的组合模式：客户不去了解具体实现，采用一致处理，牺牲安全性</span><br><span class="line">安全的组合模式：先判断再处理，牺牲透明性</span><br></pre></td></tr></table></figure></li></ol><hr /><h3 id="不同模式之间的比较">不同模式之间的比较</h3><ol type="1"><li>比较策略模式和状态模式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 策略模式是定义一个算法家族，把他们封装起来，使得他们之间可以相互替换</span><br><span class="line">- 状态模式是将一个个状态封装成一个个类，当内部状态发生改变时，改变他们的行为</span><br><span class="line">- 策略模式和状态模式的类图几乎一样，策略模式中，客户端知道具体的策略有哪些，客户端能够通过setStrategy方法来动态的设置具体使用哪个策略，状态模式中，客户端不知道内部状态是怎么变化的，状态模式通过状态转移来组合State对象，最后把行为呈现出来</span><br></pre></td></tr></table></figure></li><li>比较策略模式和模版方法模式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 策略模式和模版方法模式的共同点是都封装算法</span><br><span class="line">- 策略模式是定义算法家族，让他们之间可以相互替换，模版方法是针对一个算法流程，某个步骤的具体细节交给子类去实现。策略模式可以改变算法流程，使一个个步骤可以相互替换，模版方法模式算法流程是固定的</span><br><span class="line">- 策略模式使用组合来实现，模版方法模式使用继承来实现</span><br></pre></td></tr></table></figure></li><li>比较适配器模式、外观模式、装饰者模式的意图 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 适配器模式是把一个类的接口转换成客户期望的接口，让原本接口不兼容的类兼容，适配器模式一般用于想要复用某个类的场景；外观模式是封装子系统，提供简单的子系统的入口，同时简化层间调用</span><br><span class="line">- 装饰者模式是动态的给被装饰者添加职责，主要目的是扩展功能</span><br><span class="line">- 对于装饰者和适配器，他们都属于包装模式，装饰者需要满足is-a关系，不管如何包装，都有共同的父类，而适配器主要解决兼容问题，不一定要统一父类</span><br></pre></td></tr></table></figure></li><li>比较模版方法模式和工厂模式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工厂模式是模版方法的特殊实现，工厂里面的创建对象，就相当于只有一个步骤的模版方法模式，这个步骤交给子类去实现</span><br></pre></td></tr></table></figure></li><li>比较装饰者模式和静态代理模式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 装饰者模式是动态的给组件对象添加“职责”，更多的考虑功能的扩展，而代理模式控制对象</span><br><span class="line">的访问，也能做方法的增强</span><br><span class="line">- 装饰者模式中，客户端可以看到具体的装饰有哪些，而代理模式把对象的具体信息给隐藏了</span><br><span class="line">起来</span><br><span class="line">- 装饰者模式是把原始组件对象传入构造器中，代理模式是创建一个对象的实例</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      软件设计课堂笔记 &amp; 复习
    
    </summary>
    
    
      <category term="Designing" scheme="https://wym0120.github.io/categories/Designing/"/>
    
    
      <category term="lecture notes" scheme="https://wym0120.github.io/tags/lecture-notes/"/>
    
  </entry>
  
  <entry>
    <title>[MIT Lecture] How to Speak</title>
    <link href="https://wym0120.github.io/2020/10/21/report/MIT-how-to-speck/"/>
    <id>https://wym0120.github.io/2020/10/21/report/MIT-how-to-speck/</id>
    <published>2020-10-21T07:48:02.000Z</published>
    <updated>2021-04-12T15:01:26.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何开始一个talk">如何开始一个talk</h3><p>不要在一开始就使用一个玩笑作为开场: 因为大部分人在这个时候正在习惯你的用词、声音，或者正在调整笔记本电脑。而是应该使用一个Promise，告诉听众们他们会在接下一段时间中听到什么东西。</p><h3 id="一些启发式的例子">一些启发式的例子</h3><p><strong><em>cycle</em></strong>： 你应该重复三次左右去确保你的每个听众在被弄混乱的时候都能够意识到你要说的是什么，这是一个概率问题 <strong><em>build fence</em></strong>：把自己的想法包围起来以区分于其他人的想法、其它的工作，划定一个边界 <strong><em>verbal punctuation</em></strong>：划定一些里程碑/标志点一样的东西让听众可以快速的回忆起来之前的内容，从整体上面把握对talk的理解，就像一个outline一样的东西。也方便talker快速的回到某个点 <strong><em>question</em></strong>：谨慎的选择问题，一般会等待7秒钟</p><h3 id="一些演讲的选择">一些演讲的选择</h3><p>time ： 11 AM 比较合适 place ： 尽量光线充足 cased ：提前适应场地 populated ： 场地大小要合适</p><p>board - 可以方便的使用图形 - 写字的速度和思考的速度接近 - 能找到放手的位置</p><p>props - 使用一些道具来让陈述更加有趣更加具有说服力</p><blockquote><p>board 和 props 也许都能够让人更感受到所说的东西的存在，但是 ppt 做不到这个效果</p></blockquote><h3 id="ppt中的一些技巧">ppt中的一些技巧</h3><ul><li>不要只是重复阅读ppt中的文字</li><li>每个透明度应该都只有很少的词，并且这些词应该易于阅读</li><li>不要有太多的字</li><li>尽量在ppt的旁边讲述，以免听众反复转移视线</li><li>去除掉无用的杂乱的背景、logo、去掉无用的单词，甚至可以去掉title（但是需要告知听众title）</li><li>用箭头代替激光笔、指挥棒</li></ul><h3 id="如何激励听众">如何激励听众</h3><blockquote><p>talker对自己的演讲充满热情</p></blockquote><h3 id="steps-of-giving-a-job-talk-technical-talk">Steps of giving a job talk / technical talk</h3><ol type="1"><li>vision</li></ol><ul><li>probelms</li><li>approaches</li></ul><ol start="2" type="1"><li>have done something 列举出来每一步需要做什么， 一些约束，怎么才能够完成这些事情</li><li>contributions</li></ol>]]></content>
    
    <summary type="html">
    
      How To Speak by Patrick Winston
    
    </summary>
    
    
      <category term="report" scheme="https://wym0120.github.io/categories/report/"/>
    
    
  </entry>
  
  <entry>
    <title>Bridging the gap between AI and SE</title>
    <link href="https://wym0120.github.io/2020/10/19/report/school-report-1/"/>
    <id>https://wym0120.github.io/2020/10/19/report/school-report-1/</id>
    <published>2020-10-19T05:58:17.000Z</published>
    <updated>2021-04-12T15:01:26.112Z</updated>
    
    <content type="html"><![CDATA[<p>background : 大量的软件开发过程中间产品 problem : 大量的噪音和数据具有异构性 key point : 把软件过程中产生的产品逆向来造各种各样的工具 + 机器来理解人的行为 -&gt; 智能软件开发</p><p>research topics: - intelligent code assistant - code completion - clone detection - API recommenddation - stackoverflow + API doc - knowledge graphbased api misuse detection - automated answer - interactive query refinement for technical question retrieval - intelligent bug management and fixing - feature engineering for invalid bug determination - just in time defect identification and localization(data from github) - automatic document generation - code summarization - code comment updating - commit message generation - pull request generation - hunman-centric software engineering - predicting coding context - development intention and behavior</p><p>research methodology: empirical study -&gt; (intelligent tools &lt;-&gt; empirical study)</p>]]></content>
    
    <summary type="html">
    
      Bridging the gap between AI and SE
    
    </summary>
    
    
      <category term="report" scheme="https://wym0120.github.io/categories/report/"/>
    
    
  </entry>
  
  <entry>
    <title>Citrine: Providing Intelligent Copy-and-Paste</title>
    <link href="https://wym0120.github.io/2020/09/25/paper/copy-and-paste-1/"/>
    <id>https://wym0120.github.io/2020/09/25/paper/copy-and-paste-1/</id>
    <published>2020-09-25T06:27:31.000Z</published>
    <updated>2021-04-12T15:01:26.111Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote></blockquote><p>keywords:</p><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><h3 id="evalution">Evalution</h3><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      Citrine: Providing Intelligent Copy-and-Paste
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
  </entry>
  
  <entry>
    <title>Types and Programming Languages notes</title>
    <link href="https://wym0120.github.io/2020/09/25/lecture/fspl/tpl-notes/"/>
    <id>https://wym0120.github.io/2020/09/25/lecture/fspl/tpl-notes/</id>
    <published>2020-09-25T05:59:52.000Z</published>
    <updated>2021-04-12T15:01:26.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ch3-untyped-arithmetic-expressions">ch3 Untyped Arithmetic Expressions</h2>]]></content>
    
    <summary type="html">
    
      Types and Programming Languages notes
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[ISER] [SEP] Automating string processing in spreadsheets using input-output examples</title>
    <link href="https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Engineering%20Process/sep-5/"/>
    <id>https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Engineering%20Process/sep-5/</id>
    <published>2020-09-18T10:56:03.000Z</published>
    <updated>2021-04-12T15:01:26.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote></blockquote><p>keywords:</p><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><h3 id="evalution">Evalution</h3><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      Sumit Gulwani. Automating string processing in spreadsheets using input-output examples. POPL&#39;11
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Engineering Process" scheme="https://wym0120.github.io/tags/Software-Engineering-Process/"/>
    
  </entry>
  
  <entry>
    <title>[ISER] [SEP] code2vec: Learning distributed representations of code</title>
    <link href="https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Engineering%20Process/sep-4/"/>
    <id>https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Engineering%20Process/sep-4/</id>
    <published>2020-09-18T10:48:08.000Z</published>
    <updated>2021-04-12T15:01:26.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote></blockquote><p>keywords:</p><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><h3 id="evalution">Evalution</h3><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      Uri Alon, Meital Zilberstein, Omer Levy, and Eran Yahav. code2vec: Learning distributed representations of code. POPL&#39;19
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Engineering Process" scheme="https://wym0120.github.io/tags/Software-Engineering-Process/"/>
    
  </entry>
  
  <entry>
    <title>[ISER] [SME] Ten years of implementation and experience</title>
    <link href="https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-4/"/>
    <id>https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-4/</id>
    <published>2020-09-18T10:26:42.000Z</published>
    <updated>2021-04-12T15:01:26.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote></blockquote><p>keywords:</p><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><h3 id="evalution">Evalution</h3><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      Kirk Glerum, Kinshuman Kinshumann, Steve Greenberg, Gabriel Aul, Vince Orgovan, Greg Nichols, David Grant, Gretchen Loihle, and Galen Hunt. Debugging in the (very) large: Ten years of implementation and experience. SOSP&#39;09
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Maintence and Evolution" scheme="https://wym0120.github.io/tags/Software-Maintence-and-Evolution/"/>
    
  </entry>
  
  <entry>
    <title>[ISER] [SME] A technique for cheap recovery</title>
    <link href="https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-3/"/>
    <id>https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-3/</id>
    <published>2020-09-18T10:26:39.000Z</published>
    <updated>2021-04-12T15:01:26.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote></blockquote><p>keywords:</p><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><h3 id="evalution">Evalution</h3><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      George Candea, Shinichi Kawamoto, Yuichi Fujiki, Greg Friedman, and Armando Fox. Microreboot – A technique for cheap recovery. OSDI&#39;04
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Maintence and Evolution" scheme="https://wym0120.github.io/tags/Software-Maintence-and-Evolution/"/>
    
  </entry>
  
  <entry>
    <title>[ISER] [SME] Simplifying and isolating failure-inducing input</title>
    <link href="https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-2/"/>
    <id>https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-2/</id>
    <published>2020-09-18T10:26:36.000Z</published>
    <updated>2021-04-12T15:01:26.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote><p>Given some test case, a program fails. Which circumstances of the test case are responsible for the particular failure? The Delta Debugging algorithm generalizes and simplifies some failing test case to a minimal test case that still produces the failure; it also isolates the difference between a passing and a failing test case.</p></blockquote><blockquote><p>In a case study, the Mozilla web browser crashed after 95 user actions. Our prototype implementation automatically simplified the input to 3 relevant user actions. Likewise, it simplified 896 lines of HTML to the single line that caused the failure. The case study required 139 automated test runs, or 35 minutes on a 500 MHz PC.</p></blockquote><p>keywords: Terms—automated debugging, debugging aids, testing tools, combinatorial testing, diagnostics, tracing.</p><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><p>对于开发者们来说bug report有一个固有的矛盾，他们既希望report能够special且详尽，又希望report能够集中在关键的几个语句上以便定位bug和将类似的问题聚集在一起。这篇文章希望模拟人的思考逻辑通过二分的方法来定位到bug的存在。这篇文章通过ddmin的方法来找到一个最小的能够正好触发bug的集合和一个与它几乎一致但是略微不同的且不能触发bug的集合。来帮助开发者减少debug所消耗的时间。</p><h3 id="evalution">Evalution</h3><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      Andreas Zeller and Ralf Hildebrandt. Simplifying and isolating failure-inducing input. IEEE Transactions on Software Engineering (TSE), 28(2), 2002.
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Maintence and Evolution" scheme="https://wym0120.github.io/tags/Software-Maintence-and-Evolution/"/>
    
  </entry>
  
  <entry>
    <title>[ISER] [SME] Visualization of test information to assist fault localization</title>
    <link href="https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-1/"/>
    <id>https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Maintenance%20and%20Evolution/sme-1/</id>
    <published>2020-09-18T10:26:34.000Z</published>
    <updated>2021-04-12T15:01:26.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote><p>One of the most expensive and time-consuming components of the debugging process is locating the errors or faults. To locate faults, developers must identify statements involved in failures and select suspicious statements that might contain faults. This paper presents a new technique that uses visualization to assist with these tasks. The technique uses color to visually map the participation of each program statement in the out ome of the execution of the program with a test suite, onsisting of both passed and failed test cases. Based on this visual mapping, a user can inspe t the statements in the program, identify statements involved in failures, and locate potentially faulty statements. The paper also describes a prototype tool that implements our technique along with a set of empirical studies that use the tool for evaluation of the technique. The empirical studies show that, for the subject we studied, the technique can be eeffective in helping a user locate faults in a program.</p></blockquote><p>keywords: software visualization,fault localization,debugging,testing</p><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><p>人工定位bug是想当费事的事情，因此希望使用自动执行测试的办法在执行过程中使用不同的颜色以及颜色的不同深度来映射代码的可信程度，帮助用户来定位bug</p><h3 id="evalution">Evalution</h3><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      James A. Jones, Mary Jean Harrold, and John Stasko. Visualization of test information to assist fault localization. ICSE&#39;02
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Maintence and Evolution" scheme="https://wym0120.github.io/tags/Software-Maintence-and-Evolution/"/>
    
  </entry>
  
  <entry>
    <title>[ISER] [STA] AddressSanitizer: A fast address sanity checker</title>
    <link href="https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Testing%20and%20Analysis/sta-4/"/>
    <id>https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Testing%20and%20Analysis/sta-4/</id>
    <published>2020-09-18T10:24:23.000Z</published>
    <updated>2021-04-12T15:01:26.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote><p>Memory access bugs, including buffer overflows and uses of freed heap memory, remain a serious problem for programming languages like C and C++. Many memory error detectors exist, but most of them are either slow or detect a limited set of bugs, or both.</p></blockquote><blockquote><p>This paper presents AddressSanitizer, a new memory error detector. Our tool finds out-of-bounds accesses to heap, stack, and global objects, as well as use-after-free bugs. It employs a specialized memory allocator and code instrumentation that is simple enough to be implemented in any compiler, binary translation system, or even in hardware.</p></blockquote><blockquote><p>AddressSanitizer achieves efficiency without sacrificing comprehensiveness. Its average slowdown is just 73% yet it accurately detects bugs at the point of occurrence. It has found over 300 previously unknown bugs in the Chromium browser and many bugs in other software.</p></blockquote><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><p>目前检测边界溢出和访问已释放问题的工具要么不够快要么开销太大（好简单粗暴</p><h3 id="evalution">Evalution</h3><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitry Vyukov. AddressSanitizer: A fast address sanity checker. USENIX ATC&#39;12
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Testing and Analysis" scheme="https://wym0120.github.io/tags/Software-Testing-and-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>[ISER] [STA] A lightweight, general system for finding serious storage system errors</title>
    <link href="https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Testing%20and%20Analysis/sta-3/"/>
    <id>https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Testing%20and%20Analysis/sta-3/</id>
    <published>2020-09-18T10:24:20.000Z</published>
    <updated>2021-04-12T15:01:26.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote><p>Storage systems such as file systems, databases, and RAID systems have a simple, basic contract: you give them data, they do not lose or corrupt it. Often they store the only copy, making its irrevocable loss almost arbitrarily bad. Unfortunately, their code is exceptionally hard to get right, since it must correctly recover from any crash at any program point, no matter how their state was smeared across volatile and persistent memory.</p></blockquote><blockquote><p>This paper describes EXPLODE, a system that makes it easy to systematically check real storage systems for errors. It takes user-written, potentially system-specific checkers and uses them to drive a storage system into tricky corner cases, including crash recovery errors. EXPLODE uses a novel adaptation of ideas from model checking, a comprehensive, heavyweight formal verification technique, that makes its checking more systematic (and hopefully more effective) than a pure testing approach while being just as lightweight.</p></blockquote><blockquote><p>EXPLODE is effective. It found serious bugs in a broad range of real storage systems (without requiring source code): three version control systems, Berkeley DB, an NFS implementation, ten file systems, a RAID system, and the popular VMware GSX virtual machine. We found bugs in every system we checked, 36 bugs in total, typically with little effort.</p></blockquote><p>keywords:</p><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><p>文件系统中会有各种各样的机制来预防崩溃，而如果这些机制中也出现了bug，那会是十分严重的。但是目前已有的工作检测文件系统中的bug的方法还是非常的原始和低效的，因此就开发了一个新的工具（严重缺乏操作系统关于文件系统的知识，很多地方没看懂） ### Evalution</p><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      Junfeng Yang, Can Sar, and Dawson Engler. eXplode: A lightweight, general system for finding serious storage system errors. OSDI&#39;06
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Testing and Analysis" scheme="https://wym0120.github.io/tags/Software-Testing-and-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>[ISER] [STA] Dynamically discovering likely program invariants to support program evolution</title>
    <link href="https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Testing%20and%20Analysis/sta-1/"/>
    <id>https://wym0120.github.io/2020/09/18/paper/ISER/Software%20Testing%20and%20Analysis/sta-1/</id>
    <published>2020-09-18T10:24:15.000Z</published>
    <updated>2021-04-12T15:01:26.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><blockquote><p>Explicitly stated program invariants can help programmers by identifying program properties that must be preserved when modifying code. In practice, however, these invariants are usually implicit. An alternative to expecting programmers to fully annotate code with invariants is to automatically infer likely invariants from the program itself. This research focuses on dynamic techniques for discovering invariants from execution traces.</p></blockquote><blockquote><p>This article reports three results. First, it describes techniques for dynamically discovering invariants,along with an implementation, named Daikon, that embodies these techniques. Second, it reports on theapplication of Daikon to two sets of target programs. In programs from Gries's work on program derivation,the system rediscovered predened invariants. In a C program lacking explicit invariants, the system discovered invariants that assisted a software evolution task. These experiments demonstrate that, at least forsmall programs, invariant inference is both accurate and useful. Third, it analyzes scalability issues such asinvariant detection runtime and accuracy as functions of test suites and program points instrumented.</p></blockquote><p>keywords: Program invariants, formal specication, software evolution, dynamic analysis, execution traces, logical inference, pattern recognition</p><h3 id="总体评价">总体评价</h3><h3 id="motivation">Motivation</h3><p>不变式在程序开发的过程中是十分重要的，它能够保证程序不会因为修改代码而破坏原有的代码正确性。但是大多数时候不变式都是非显式的，这篇文章就想通过追踪变量值的变化来动态的推导出不变式。</p><h3 id="evalution">Evalution</h3><h3 id="details">Details</h3>]]></content>
    
    <summary type="html">
    
      Michael D. Ernst, Jake Cockrell, William G. Griswold, and David Notkin. Dynamically discovering likely program invariants to support program evolution. IEEE Transactions on Software Engineering (TSE), 27(2), 2001
    
    </summary>
    
    
      <category term="paper" scheme="https://wym0120.github.io/categories/paper/"/>
    
    
      <category term="Software Testing and Analysis" scheme="https://wym0120.github.io/tags/Software-Testing-and-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>[课堂笔记] 软件工程研究入门</title>
    <link href="https://wym0120.github.io/2020/09/18/lecture/iser/iser-notes/"/>
    <id>https://wym0120.github.io/2020/09/18/lecture/iser/iser-notes/</id>
    <published>2020-09-18T02:10:16.000Z</published>
    <updated>2021-04-12T15:01:26.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="conduct-rigorous-and-scientific-research">Conduct Rigorous And Scientific Research</h3><h4 id="写作中的presentation">写作中的presentation</h4><ul><li>前后用词一致</li><li>类似句子不要换用句式</li><li>并排枚举的时候强制加上逗号</li><li>宾语从句里面也不要省略that，例如Suppose that / We assume that</li></ul><h4 id="research-formulation">Research Formulation</h4><p>整体上来说，做科研和写论文通常是一起进行的。</p><p>关键概念：必须先定义再使用，用数学上可表达或者机器可执行的形式去定义 非关键概念：尽量把它扔掉 在同一篇论文中每个概念都需要一个很明确的指代，而不能经常变换</p><p>Research Problem 需要有明确的定义的问题边界，不要over claim</p><p>Motivating Example 找到一些有区分度的例子——已有工作在这个例子中不能做，而我们的工作可以做</p><p>Inadequacy Of Related Work 只需要展示不同点，而不要去批判</p><p>Insight 最重要的点，为什么我们的工作比相关工作做的更好</p><h4 id="experimentation">Experimentation</h4><p>Experimentation 和 Case Study的区别：实验环节是可以控制变量的，并且是在一个实验室的环境中。case study是无法控制变量的，是在实际生产环境中的结果</p><h5 id="questions-and-subjects">Questions and Subjects</h5><p>问题设置：在<strong><em>什么条件下</em></strong>通过<strong><em>什么途径</em></strong>在什么<strong><em>方面</em></strong>做得好 主体的选择是否具有代表性</p><h5 id="experimentation-design">Experimentation Design</h5><p>Variable Independent variables（factors） ： 类似与函数中的自变量 Dependent variables ：类似于函数中的应变量，是用于衡量实验结果的一些指标 Controlled variables ：由于难以控制因此一些被固定下来的值，但是这些值对实验不会产生决定性的影响</p><h5 id="threats-to-validity">Threats to Validity</h5><ul><li>constuct validity</li><li>internal validity</li><li>external validity</li><li>concluusion validity</li></ul><p>todo：看一下原文</p><h5 id="exercise-and-discussion">Exercise and discussion</h5><p>回答为什么这些threats会影响实验数据<strong><em>但是</em></strong>为什么不会影响结论的正确性</p>]]></content>
    
    <summary type="html">
    
      软件工程研究入门课堂笔记
    
    </summary>
    
    
    
      <category term="lecture notes" scheme="https://wym0120.github.io/tags/lecture-notes/"/>
    
  </entry>
  
</feed>
